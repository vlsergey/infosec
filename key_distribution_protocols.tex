\chapter{Распространение ключей}\index{протокол!распространения ключей}\label{chapter-key-distribution-protocols}
\selectlanguage{russian}

Задачей распространения ключей между двумя пользователями является создание секретных псевдослучайных сеансовых ключей шифрования и аутентификации сообщений. Пользователи предварительно создают и обмениваются ключами аутентификации один раз. В дальнейшем для создания защищённой связи пользователи производят взаимную аутентификацию и вырабатывают сеансовые ключи\index{ключ!сеансовый}.

\section{Симметричные протоколы}

\subsection{Аутентификация и атаки воспроизведения}

Рассмотрим такую ситуацию: обе стороны $A$ и $B$ имеют общий долговременный ключ $K_{AB}$ и симметричную систему шифрования. Нужно выработать сеансовый секретный ключ $K$. Сторона $A$ создаёт ключ $K$ и желает его передать стороне $B$.

\begin{enumerate}
    \item Для этого сторона $A$ с помощью общего ключа $K_{AB}$ создаёт и передаёт $B$ шифрованное сообщение:
            \[ A \rightarrow B: ~ E_{K_{AB}}(K, B, A). \]
        В этом сообщении имеются так называемые поля -- $(B,A)$ -- информация для дополнительного подтверждения.
    \item Сторона $B$, используя общий ключ $K_{AB}$, расшифровывает полученное сообщение:
            \[ D_{K_{AB}}( E_{K_{AB}}( K, B, A)) = (K, B, A). \]
        В результате сторона $B$ получает сеансовый ключ $K$ и дополнительные данные $(B,A)$.
\end{enumerate}

Недостаток этого протокола состоит в том, что криптоаналитик может перехватывать сообщения и через некоторое время пересылать их стороне $A$.

Рассмотрим другие варианты решения задачи о передаче сеансового ключа.
Задача остаётся прежней: обе стороны $A$ и $B$ имеют общий долговременный секретный ключ $K_{AB}$, сторона $A$ должна выработать сеансовый секретный ключ $K$ и доставить его стороне $B$.

Протокол включает \emph{метки времени} -- информацию о моменте $t_A$ отправки сообщения и моменте получения сообщения $t_B$.

\begin{enumerate}
    \item Сторона $A$ вырабатывает $K$, с помощью долговременного ключа $K_{AB}$ создаёт шифрованное сообщение с меткой времени $t_A$ и передаёт его стороне $B$:
            \[ A \rightarrow B: ~ E_{K_{AB}}(K, t_A). \]
    \item Сторона $B$ получает сообщение и расшифровывает его с помощью общего ключа:
            \[ D_{K_{AB}}( E_{K_{AB}}( K, t_A)) = (K, t_A). \]
        В результате $B$ получает $(K, t_A)$, то есть секретный ключ и метку времени. $B$ измеряет время прихода $t_B$ и интервал запаздывания. Если $|t_B - t_A| \leq \delta$, то $B$ аутентифицирует $A$.
\end{enumerate}
Метка времени является одноразовой меткой и защищает от атак воспроизведения ранее записанных сообщений.

Рассмотрим другой способ передачи ключа с дополнительной информацией в виде \emph{одноразовых случайных меток} (nonce -- number used once) вместо меток времени. Протокол передачи состоит в следующем.

\begin{enumerate}
    \item Сторона $A$ вырабатывает случайное число $r_A$, шифрует сообщение, в котором $(r_A, A)$ -- реквизиты $A$, и передаёт его стороне $B$:
            \[ A \rightarrow B: ~ E_{K_{AB}}(r_A, A). \]
    \item Сторона $B$ вырабатывает сеансовый ключ $K$, создаёт шифрованное сообщение и посылает его $A$:
            \[ A \leftarrow B: ~ E_{K_{AB}}(K, r_A, A). \]
    \item Сторона $A$ расшифровывает полученное сообщение
            \[ D_{K_{AB}}( E_{K_{AB}}( K, r_A, A)) = (K, r_A, A). \]
        В результате $A$ получает сеансовый ключ и подтверждение своих реквизитов, что является дополнительной аутентификацией.
\end{enumerate}

Предположим, что сторона $B$ тоже желает убедиться, что имеет дело со стороной $A$. Тогда этот протокол следует дополнить передачей реквизитов $B$. По-прежнему считаем, что у $A$ и $B$ общая система шифрования с долговременным секретным ключом $K_{AB}$.

\begin{enumerate}
    \item Сторона $A$ вырабатывает случайное число $r_A$, шифрует и передаёт стороне $B$ сообщение, в котором $(r_A, A)$ -- реквизиты $A$:
            \[ A \rightarrow B: ~ E_{K_{AB}}(r_A, A). \]
    \item Сторона $B$ вырабатывает случайное число $r_B$ и отправляет стороне $A$ зашифрованное сообщение:
            \[ A \leftarrow B: ~ E_{K_{AB}}(K_B, r_B, r_A, A), \]
        где $K_B$ -- ключ $B$.
     \item Сторона $A$ осуществляет расшифрование:
            \[ D_{K_{AB}}(E_{K_{AB}}(K_B, r_B, r_A, A)) = (K_B, r_B, r_A, A) \]
        и получает ключ $K_B$ и реквизиты $r_B, r_A, A$. Для аутентификации себя сторона $A$ создаёт свой ключ $K_A$ и отправляет стороне $B$ шифрованное сообщение:
            \[ A \rightarrow B: ~ E_{K_{AB}}(K_A, r_B, r_A, B). \]
     \item Сторона $B$ осуществляет расшифрование
            \[ D_{K_{AB}}(E_{K_{AB}}(K_A, r_B, r_A, B)) = (K_A, r_B, r_A, B), \]
        которое определяет ключ $K_A$ и аутентифицирует $A$.
\end{enumerate}

Таким образом, обе стороны имеют в своём распоряжении ключи $K_A, K_B$ в качестве сеансовых секретных ключей.

\subsection{Протокол с ключевым кодом аутентификации}

При использовании хэш-функции $K = h(K_{A} ~\|~ K_{B})$ происходит усиление секретности. Здесь $(K_{A} ~\|~ K_{B})$ -- конкатенация $K_{A} $ и $K_{B}$.

% Достоинства: предположим, $K_{A} ,K_{B} $ -- не обладают «хорошими» свойствами случайности (биты распределены неравномерно или зависимы друг от друга), то есть, $P_{K_{A} ,K_{B} } (0)=\frac{1}{2} -\varepsilon $, где $\varepsilon $ - мало, но не 0. Тогда вероятность того, что этот бит в \emph{K }будет равным нулю, $P_{K} (0)=\frac{1}{2} -\varepsilon ',\varepsilon '<\varepsilon $- усиление секретности.

Вычисление хэш-значения, как правило, выполняется быстрее, чем расшифрование. Поэтому были разработаны протоколы, в которых вместо функции шифрования используется имитовставка\index{имитовставка} на основе хэш-функции ($\MAC_K$). Рассмотрим протокол такого рода.
\begin{enumerate}
    \item Сторона $A$ вырабатывает сеансовый ключ $K$, создаёт сообщение, используя одноразовую метку $t_{A}$, и пересылает его стороне $B$:
            \[ A \rightarrow B: ~ t_A, ~ B, ~ K \oplus \MAC_{K_{AB}}( t_A, B), ~ \MAC_{K_{AB}}(K, t_A, B). \]
    \item Сторона $B$ вычисляет
            \[ \MAC_{K_{AB}}(t_A, B) \oplus K \oplus \MAC_{K_{AB}}(t_A, B) = K \]
        и получает сеансовый ключ $K$.
\end{enumerate}

Заметим, что криптоаналитик может добавить в поле случайную последовательность, тогда вместо $K$ получаем <<$K$ плюс помеха>>. Вмешательство криптоаналитика будет выявлено благодаря наличию четвёртого поля в сообщении. Используя полученное значение $K$, вычисляют $\MAC_{K_{AB}}(K, t_A, B)$ и сравнивают с четвёртым полем. Если значения совпадают, то вмешательства криптоаналитика не было.

\input{needham-schroeder_protocol}

\input{three-pass_protocols}

\section{Асимметричные протоколы}

Асимметричные протоколы, или же протоколы, основанные на криптосистемах с открытыми ключами, позволяют ослабить требования к предварительному этапу протоколов. Вместо общего секретного ключа, который должны иметь две стороны (либо обе стороны и доверенный центр), в рассматриваемых ниже протоколах стороны должны предварительно обменяться открытыми ключами (между собой либо между собой и доверенным центром). Такой предварительный обмен может проходить по открытому каналу связи, в предположении, что криптоаналитик не может повлиять на содержимое канала связи на данном этапе.

\subsection{Простой протокол}

Рассмотрим протокол распространения ключей с помощью асимметричных шифров. Введём обозначения: $K_B$ -- открытый ключ стороны $B$, а $K_A$ -- открытый ключ стороны $A$. Протокол включает три сеанса обмена информацией.
\begin{enumerate}
    \item В первом сеансе сторона $A$ посылает стороне $B$ сообщение:
            \[ A \rightarrow B: ~ E_{K_B}(K_1, A), \]
        где $K_1$ -- ключ, выработанный стороной $A$.
    \item Сторона $B$ получает $(K_1, A)$ и передаёт стороне $A$ наряду с другой информацией свой ключ $K_2$ в сообщении, зашифрованном с помощью открытого ключа $K_A$:
            \[ A \leftarrow B: ~ E_{K_A}(K_2, K_1, B). \]
    \item Сторона $A$ получает и расшифровывает сообщение $(K_2, K_1, B)$. Во время третьего сеанса сторона $A$, чтобы подтвердить, что она знает ключ $K_2$, посылает стороне $B$ сообщение:
            \[ A \rightarrow B: ~ E_{K_B}(K_2). \]
\end{enumerate}
Общий ключ формируется из двух ключей: $K_1$ и $K_2$.

\subsection{Протоколы с цифровыми подписями}

Существуют протоколы обмена, в которых перед началом обмена ключами генерируются подписи сторон $A$ и $B$, соответственно $S_A(m)$ и $S_B(m)$. В этих протоколах можно использовать различные одноразовые метки. Рассмотрим пример.
\begin{enumerate}
    \item Сторона $A$ выбирает ключ $K$ и вырабатывает сообщение:
            \[ \left( K, ~ t_A, ~ S_A(K, t_A, B) \right), \]
        где $t_A$ -- метка времени. Зашифрованное сообщение передаёт стороне $B$:
        \[ A \rightarrow B: ~ E_{K_B}(K, ~ t_A, ~ S_A(K, t_A, B)). \]
    \item Сторона $B$ получает это сообщение, расшифровывает $\left( K, ~ t_A, ~ S_A(K, t_A, B) \right)$ и вырабатывает свою метку времени $t_B$. Проверка считается успешной, если $|t_B - t_A | < \delta $. Сторона $B$ знает свои реквизиты и может осуществлять проверку подписи.
\end{enumerate}

Имеется второй вариант протокола, в котором шифрование и подпись выполняются раздельно.
\begin{enumerate}
    \item Сторона $A$ вырабатывает ключ $K$, использует одноразовую метку (или метку времени) $t_{A}$ и передаёт стороне $B$ два различных зашифрованных сообщения:
            \[ \begin{array}{ll}
                A \rightarrow B: & ~ E_{K_B}(K, t_A), \\
                A \rightarrow B: & ~ S_A(K, t_A, B). \\
            \end{array} \]
    \item Сторона $B$ получает это сообщение, расшифровывает $K, t_A$ и, добавив свои реквизиты $B$, может проверить подпись $S_A(K, t_A, B)$.
\end{enumerate}

В третьем варианте протокола сначала производится шифрование, потом подпись.
\begin{enumerate}
    \item Сторона $A$ вырабатывает ключ $K$, использует одноразовую случайную метку или метку времени $t_A$ и передаёт стороне $B$ сообщение:
        \[ A \rightarrow B: ~ t_A, ~ E_{K_B}(K, A), ~ S_A(t_A, ~ K, ~ E_{K_B}(K, A)). \]
    \item Сторона $B$ получает это сообщение, расшифровывает $\left( t_A, ~ K, ~ A, ~ E_{K_B}(K, A) \right)$ и проверяет подпись $S_A(t_A, ~ K, ~ E_{K_B}(K, A))$.
\end{enumerate}

\input{diffie-hellman}

%\section{Протоколы с аутентификацией}

\subsection{Односторонняя аутентификация}

\input{el-gamal_protocol}

\input{mti}

\input{sts}

\input{girault_scheme}

\input{bloms_scheme}

\input{quantum_protocols}
