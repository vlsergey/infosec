<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="14_5_Аутентификация_в_веб_сервисах">14.5. Аутентификация в веб-сервисах</h2><p>В настоящий момент HTTP<a name="N110106"><!--протокол!HTTP--></a> (вместе с HTTPS<a name="N110112"><!--протокол!HTTPS--></a>) является основным протоколом, используемым в сети Интернет для доступа к веб-сервисам (например к социальным сетям или веб-клиентам электронной почты). Данный протокол является протоколом типа &laquo;запрос-ответ&raquo;<a name="N110118"><!--протокол!запрос-ответ--></a>, причём для каждого запроса открывается новое соединение с сервером</p><command name="footnote"><argument required="true">Для версии протокола HTTP/1.0 существует неофициальное<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Totty:2002">[48]</a> расширение в виде заголовка <tt>Connection: Keep-Alive</tt>, который позволяет использовать одно соединение для нескольких запросов. Версия протокола HTTP/1.1 по умолчанию<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#rfc7230">[38]</a> устанавливает поддержку выполнения нескольких запросов в рамках одного соединения. Однако все запросы всё равно выполняются независимо друг от друга.</argument></command><p>. То есть протокол HTTP не является сессионным протоколом<a name="N110146"><!--протокол!сессионный--></a>. В связи с этим задачу аутентификации на веб-сервисах можно разделить на задачи первичной и вторичной аутентификаций. <em>Первичной аутентификацией</em><a name="N110157"><!--аутентификация!первичная--></a> будем называть механизм обычной аутентификации пользователя в рамках некоторого HTTP-запроса, а <em>вторичной</em><a name="N110168"><!--аутентификация!вторичная--></a> (или <em>повторной</em><a name="N110179"><!--аутентификация!повторная--></a>) &ndash; некоторый механизм подтверждения в рамках последующих HTTP-запросов, что пользователь уже был <em>ранее</em> аутентифицирован веб-сервисом в рамках первичной аутентификации.</p><p>Аутентификация в веб-сервисах также бывает <em>односторонней</em><a name="N110196"><!--аутентификация!односторонняя--></a> (как со стороны клиента, так и со стороны сервиса) и <em>взаимной</em><a name="N110207"><!--аутентификация!взаимная--></a>. Под аутентификацией веб-сервиса обычно понимается возможность сервиса доказать клиенту, что он является именно тем веб-сервисом, к которому хочет получить доступ пользователь, а не его мошеннической подменой, созданной злоумышленниками. Для аутентификации веб-сервисов используется механизм сертификатов открытых ключей<a name="N110213"><!--сертификат открытого ключа--></a> протокола HTTPS<a name="N110219"><!--протокол!HTTPS--></a> с использованием инфраструктуры открытых ключей<a name="N110225"><!--инфраструктура открытых ключей--></a> (см. раздел<span class="nonbreaking-interword-space"> </span><a href="#chapter-public-key-infrastructure">9.5</a>).</p><p>При использовании протокола HTTPS<a name="N110238"><!--протокол!HTTPS--></a> и наличии соответствующей поддержки со стороны веб-сервиса клиент также имеет возможность аутентифицировать себя с помощью своего сертификата открытого ключа<a name="N110244"><!--сертификат открытого ключа--></a>. Данный механизм редко используется в публичных веб-сервисах, так как требует от клиента иметь на устройстве, с которого осуществляется доступ, файл сертификата открытого ключа.</p><h3 data-command-name="subsection" id="14_5_1_Первичная_аутентификация_по_паролю">14.5.1. Первичная аутентификация по паролю</h3><p>Стандартная первичная аутентификация в современных веб-сервисах происходит посредством обычной передачи логина и пароля в открытом виде по сети. Если SSL-соединение не используется, логин и пароль могут быть перехвачены. Даже при использовании SSL-соединения веб-приложение имеет доступ к паролю в открытом виде.</p><p>Более защищённым, но малоиспользуемым способом аутентификации является вычисление хеша от пароля <span class="mathjax">$m$</span>, &laquo;соли&raquo; <span class="mathjax">$s$</span> и псевдослучайных одноразовых меток <span class="mathjax">$n_1, n_2$</span> с помощью JavaScript в браузере и отсылка по сети только результата вычисления хеша.</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{ll}
    \text{Браузер} ~\rightarrow~ \text{Сервис:} &amp; \text{HTTP GET-запрос,} \\
    \text{Браузер} ~\leftarrow~ \text{Сервис:}  &amp; s ~\|~ n_1, \\
    \text{Браузер} ~\rightarrow~ \text{Сервис:} &amp; n_2 ~\|~ h( h(s ~\|~ m) ~\|~ n_1 ~\|~ n_2). \\
\end{array} $$</div><p>Если веб-сервис хранит хеш от пароля и &laquo;соли&raquo; <span class="mathjax">$h(s ~\|~ m)$</span>, то пароль не может быть перехвачен ни по сети, ни веб-сервисом, ни какими-либо прокси-серверами, находящимися между браузером и веб-сервисом.</p><p>В массовых интернет-сервисах пароли часто хранятся в открытом виде на сервере, что не является хорошей практикой для обеспечения защиты персональных данных пользователей.</p><h3 data-command-name="subsection" id="14_5_2_Первичная_аутентификация_в_OpenID">14.5.2. Первичная аутентификация в OpenID</h3><p>Из-за большого числа различных логинов, которые приходится использовать для доступа к различным сервисам, постепенно происходит внедрение единых систем аутентификации для различных сервисов (single sign-on), например OpenID. Одновременно происходит концентрация пользователей вокруг больших порталов с единой аутентификацией, например Google Account. Яндекс.Паспорт также уменьшает число используемых паролей для различных служб.</p><p>Принцип аутентификации состоит в следующем.</p><ol><li>Веб-сервисы доверяют аутентификацию пользователя третьей стороне &ndash; центру аутентификации. Центров может быть несколько, но владельцы веб-сервиса могут ограничить выбор такого центра &laquo;белым&raquo; или &laquo;чёрным&raquo; списком.</li><li>Когда пользователь заходит на интернет-ресурс, веб-при<wbr></wbr>ло<wbr></wbr>же<wbr></wbr>ние перенаправляет его на центр аутентификации с защитой TLS-соединением.</li><li>Центр аутентифицирует пользователя и выдаёт ему токен аутентификации, который пользователь предъявляет ин<wbr></wbr>тер<wbr></wbr>нет-сер<wbr></wbr>ви<wbr></wbr>су.</li><li>Сервис по токену аутентификации определяет имя пользователя.</li></ol><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 90%;"><a name="fig:openid" style="vertical-align: top; align-self: start;"></a><img src="images/B7DCF871DC442D843ED30A2375BE3BD8.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 14.1 &mdash; Схема аутентификации в OpenID</figcaption></figure><p>На рис.<span class="nonbreaking-interword-space"> </span><a href="14_5_Autentifikatsija_v_veb_servisah.html#fig:openid">14.1</a> показана схема аутентификации в OpenID версии 2 для доступа к стороннему интернет-сервису.</p><p>Если сервис и центр вместе создают общий секретный ключ <span class="mathjax">$K$</span> для имитовставки<a name="N110355"><!--имитовставка--></a> <span class="mathjax">${\textrm{MAC}}_K$</span>, выполняются шаги 4, 5 по протоколу Диффи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Хеллмана<a name="N110368"><!--протокол!Диффи—Хеллмана--></a>:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    \text{4. Сервис} ~\rightarrow~ \text{центр: модуль}~ p ~\text{группы}~ {{\mathbb{Z}}}_p^*, ~\text{генератор}~ g, \\
        ~~~~~~~~~~~~~~~\text{число}~ g^a \mod p, \\
    \text{5. Сервис} ~\leftarrow~ \text{центр: число}~ g^b \mod p, ~\text{гаммированный} \\
        ~~~~~~~~~~~~~~~\text{ключ}~ K \oplus (g^{ab} \mod p),
\end{array} $$</div><p>то аутентификатор содержит <span class="mathjax">${\textrm{MAC}}_K$</span>, проверяемый шагом 10 на выданном ключе <span class="mathjax">$K$</span></p><command name="footnote"><argument required="true">Более правильным подходом является использование в качестве ключа <span class="mathjax">$K = g^{ab} \mod p$</span>, так как в этом случае ключ создаётся совместно, а не выдаётся центром.</argument></command><p>. Имитовставка<a name="N110395"><!--имитовставка--></a> определяется как описанный ранее <span class="mathjax">${\textrm{HMAC}}$</span> с хеш-функцией SHA-256.</p><p>Если сервис и центр не создают общий ключ (этапы 4, 5 не выполняются), то сервис делает запрос на проверку аутентификатора в шагах 10, 11.</p><p>В OpenID аутентификатор состоит из следующих основных полей: имени пользователя, URL сервиса, результата аутентификации в OpenID, одноразовой метки и, возможно, кода аутентификации от полей аутентификатора на секретном ключе <span class="mathjax">$K$</span>, если он был создан на этапах 4, 5. Одноразовая метка является <em>одноразовым</em> псевдослучайным идентификатором результата аутентификации, который центр сохраняет в своей БД. По одноразовой метке сервис запрашивает центр о верности результата аутентификации на этапах 10, 11. Одноразовая метка дополнительно защищает от атак воспроизведения.</p><p>Можно было бы исключить шаги 4, 5, 10, 11, но тогда сервису пришлось бы реализовывать и хранить в БД использованные одноразовые метки для защиты от атак воспроизведения. Цель OpenID &ndash; предоставить аутентификацию с минимальными издержками на интеграцию. Поэтому в OpenID реализуется модель, в которой сервис делегирует все проверки центру с помощью соответствующих запросов.</p><p>Важно отметить, что в аутентификации через OpenID необходимо использовать TLS-соединения<a name="N110413"><!--протокол!SSL/TLS--></a> (то есть протокол HTTPS<a name="N110419"><!--протокол!HTTPS--></a>) при всех взаимодействиях с центром, так как в самом протоколе OpenID не производится аутентификация сервиса и центра, конфиденциальность<a name="N110425"><!--конфиденциальность--></a> и целостность<a name="N110431"><!--целостность--></a> не поддерживаются.</p><h3 data-command-name="subsection" id="14_5_3_Вторичная_аутентификация_по_cookie">14.5.3. Вторичная аутентификация по cookie</h3><p>Если веб-сервер использует первичную аутентификацию по паролю, который передаётся в виде данных формы в теле POST-запроса, то осуществлять подобную передачу данных при каждом обращении неудобно. Клиент должен иметь возможность доказать серверу, что он уже прошёл первичную аутентификацию. Должен быть предусмотрен механизм вторичной аутентификации. Для этого используется случайный токен, который уникален для каждого пользователя (обычно &ndash; для каждого сеанса работы пользователя), который сервер передаёт пользователю после первичной аутентификации. Данный токен должен передаваться клиентом на сервис при каждом обращении к страницам, которые относятся к защищённой области сервиса. На практике применяются следующие механизмы для передачи данного токена при каждом запросе.</p><ul><li>Первым способом является автоматическая модификация на стороне сервера вывода страницы клиенту, которая добавляет ко всем URL в HTML-коде страницы этот токен. В результате, переходя по ссылкам на HTML-странице (а также заполняя формы и отправляя их на сервер), клиент будет автоматически отправлять токен как часть запроса в URL-адресе страницы:

<tt>http://tempuri.org/page.html?token=12345.</tt></li><li>Вторым способом является использование механизма cookie (&laquo;куки&raquo;, &laquo;кукиз&raquo;, на русский обычно не переводится, подробнее см.<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Totty:2002">[48]</a>). Данный механизм позволяет серверу передать пользователю некоторую строку, которая будет отправляться на сервер при каждом последующем запросе.</li></ul><p>Основным механизмом для вторичной аутентификации пользователей в веб-сервисах является механизм cookie, а токены, как часть URL, используются в распределённых системах, наподобие уже рассмотренной OpenID, так как сервисы, находящиеся в разных доменах, не имеют доступа к общим cookie. Далее рассмотрим подробнее механизм использования cookie.</p><p>Когда браузер в первый раз делает HTTP-запрос:</p><div style="display: flex; align-items: center; justify-content: center;"> <pre>GET /index.html HTTP/1.1
Host: www.wikipedia.org
Accept: */*</pre> </div><p>В заголовок ответа сервера веб-приложение может добавить заголовок <tt>Set-Cookie</tt>, который содержит новые значения cookie:</p><div style="display: flex; align-items: center; justify-content: center;"> <pre>HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name1=value1; name2=value2; ...

...далее HTML-страница...</pre> </div><p>Браузер, если это разрешено настройками, при последующих запросах к веб-серверу автоматически будет отсылать cookie назад веб-приложению:</p><div style="display: flex; align-items: center; justify-content: center;"> <pre>GET /wiki/HTTP_cookie HTTP/1.1
Host: www.wikipedia.org
Cookie: name1=value1; name2=value2; ...
Accept: */*</pre> </div><p>Далее веб-приложение может создать новый cookie, изменить значение старого и<span class="nonbreaking-interword-space"> </span>т.&nbsp;д. Браузер хранит cookie на устройстве клиента. То есть cookie позволяет хранить переменные на устройстве клиента, отсылать сохранённые значения, получать новые переменные. В результате создаётся передача состояний, что даёт возможность не вводить логин и пароль каждый раз при входе в интернет-сервис, использовать несколько окон для одного сеанса работы в интернет-магазине и<span class="nonbreaking-interword-space"> </span>т.&nbsp;д. При создании cookie может указываться его конечное время действия, после которого браузер удалит устаревший cookie.</p><p>Для вторичной аутентификации в cookie веб-приложение записывает токен в виде текстовой строки. В качестве токена можно использовать <em>псевдослучайную</em> текстовую строку достаточной длины, созданную веб-приложением. Например:</p><div style="display: flex; align-items: center; justify-content: center;"> <pre>Cookie: auth=B35NMVNASUY26MMWNVZ87.</pre> </div><p>В этом случае веб-сервис должен вести журнал выданных токенов пользователям и их сроков действия. Если информационная система небольшого размера (один или десятки серверов), то вместо журнала может использоваться механизм session storage.</p><ul><li>При первом заходе на сайт сервер приложений (платформа исполнения веб-приложения) &laquo;назначает&raquo; клиенту сессию, отправляя ему через механизм cookie новый (псевдо-)слу<wbr></wbr>чай<wbr></wbr>ный токен сессии, а в памяти сервера выделяя структуру, которая недоступна самому клиенту, но которая соответствует данной конкретной сессии.</li><li>При каждом последующем обращении клиент передаёт токен (идентификатор) сессии с помощью механизма cookie. Сервер приложений берёт из памяти соответствующую структуру сессии и передаёт её приложению вместе с параметрами запроса.</li><li>В момент прохождения первичной аутентификации приложение добавляет в указанную область памяти ссылку на информацию о пользователе.</li><li>При последующих обращениях приложение использует информацию о пользователе, записанную в области памяти сессии клиента.</li><li>Сессия автоматически стирается из памяти после прохождения некоторого времени неактивности клиента (что контролируется настройками сервера) либо если приложение явно вызвало функцию инвалидации сессии (англ. <span lang="en"><i>invalidate</i></span>).</li></ul><p>Плюсом использования session storage является то, что этот механизм уже реализован в большинстве платформ для построения веб-приложений (см., например, <a href="Literatura.html#Brittain:Darwin:2007">[20]</a>). Его минусом является сложность синхронизации структур сессий в памяти серверов для распределённых информационных систем большого размера.</p><p>Вторым способом вторичной аутентификации с использованием cookie является непосредственное включение аутентификационных данных (идентификатор пользователя, срок действия) в cookie вместо случайного токена. К данным в обязательном порядке добавляется имитовставка<a name="N110567"><!--имитовставка--></a> по ключу, который известен только сервису. С одной стороны, данный подход может значительно увеличить размер передаваемых cookie. С другой &ndash; он облегчает вторичную аутентификацию в распределённых системах, так как промежуточным сервисом, хранящим информацию о произошедшей аутентификации, является только клиент, а не сервер.</p><p>Конечно, беспокоиться об аутентификации в веб-сервисах при использовании обычного HTTP-протокола<a name="N110573"><!--протокол!HTTP--></a> без защиты канала с помощью TLS-соединения<a name="N110579"><!--протокол!SSL/TLS--></a> (HTTPS-протокола) имеет смысл только по отношению к угадыванию токенов аутентификации другими пользователями, не имеющих доступа к маршрутизаторам и сети, через которые клиент общается с сервисом (в том числе к радиоканалу используемой Wi-Fi сети). Кража компьютера или одного cookie-файла и перехват незащищённого трафика протокола HTTP<a name="N110585"><!--протокол!HTTP--></a> приводят к доступу в систему под именем взломанного пользователя.</p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="14_4_Hranenie_paroley_i_.html">&#129080; 14_4_Hranenie_paroley_i_</a></li><li class="page-item"><a class="page-link" href="Glava_15_Programmnie_ujazvimosti.html">Glava_15_Programmnie_ujazvimosti &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>