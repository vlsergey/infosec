<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="8_5_Имитовставка_MAC_">8.5. Имитовставка (MAC)</h2><p><a name="N89371"><!--имитовставка--></a>Для обеспечения целостности и подтверждения авторства информации, передаваемой по каналу связи, используют <em>имитовставку</em> <span class="mathjax">${\textrm{MAC}}$</span> (англ. <span lang="en"><i>Message Authentication Code</i></span>).</p><command name="displayquote"><argument required="true">displayquote</argument><content>
Имитовставка, код аутентичности сообщения (англ. <span lang="en"><i>message authentication code, seal, integrity check value</i></span>) &mdash;  в  протоколах аутентификации сообщений с доверяющими друг другу участниками &mdash; специальный набор символов, добавляемый к сообщению и предназначенный для обеспечения его целостности и аутентификации источника данных.
<command name="flushright"><argument required="true">flushright</argument><content>Словарь криптографических терминов<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Pogorelov:Sachkov:2006">[132]</a>
</content></command>
</content></command><p>Далее под имитовставкой мы будем понимать некоторую ключевую функцию (класс функций) <span class="mathjax">${\textrm{MAC}}(K,m)$</span></p><div class="mathjax" style="text-align: center;">$$
    \textrm{MAC}: \{0,1\}^{|K|} \times \{0,1\}^* \to \{0,1\}^{|MAC|},
$$</div><p>зависящую от передаваемого сообщения <span class="mathjax">$m$</span> и некоторого ключа <span class="mathjax">$K$</span> отправителя <span class="mathjax">$A$</span>, обеспечивающую свойства аутентификации сообщения:</p><ul><li>свойство корректности получатель <span class="mathjax">$B$</span>, используя такой же или другой связанный ключ, имеет возможность проверить целостность<a name="N89459"><!--целостность--></a> и доказать принадлежность информации участнику, знающему ключ <span class="mathjax">$K$</span><command name="footnote"><argument required="true">В случае использования симметричной криптографии участник <span class="mathjax">$B$</span> знает секретный ключ <span class="mathjax">$K$</span> и доказать авторство отправителя <span class="mathjax">$A$</span> он может только самому себе. При попытке доказать другому участнику оригинальный отправитель <span class="mathjax">$A$</span> может отрицать авторство сообщения и настаивать, что имитовставку сгенерировал получатель <span class="mathjax">$B$</span>, так как он тоже знает секретный ключ <span class="mathjax">$K$</span>.</argument></command>;</li><li>свойство надёжности злоумышленник (криптоаналитик) не может (за обозримое время или же в принципе) сфальсифицировать значение имитовставки, то есть сгенерировать новое сообщение или модифицировать старое таким образом, чтобы получатель <span class="mathjax">$B$</span> некорректно принял сообщение как от отправителя <span class="mathjax">$A$</span> с вероятностью, больше заданной.</li></ul><p>Имитовставка может быть построена либо на симметричной криптосистеме (в таком случае обе стороны имеют один общий секретный ключ), либо на криптосистеме с открытым ключом, в которой <span class="mathjax">$A$</span> использует свой секретный ключ, а <span class="mathjax">$B$</span> &ndash; открытый ключ отправителя <span class="mathjax">$A$</span>.</p><h3 data-command-name="subsection" id="8_5_1_HMAC">8.5.1. HMAC</h3><p>Наиболее универсальный способ аутентификации сообщений с использованием схем ЭЦП на криптосистемах с открытым ключом состоит в том, что сторона <span class="mathjax">$A$</span> отправляет стороне <span class="mathjax">$B$</span> сообщение</p><div class="mathjax" style="text-align: center;">$$ m ~\|~ \textrm{ЭЦП}(K, h(m)), $$</div><p>где <span class="mathjax">$h(m)$</span> &ndash; криптографическая хеш-функция в схеме ЭП и <span class="mathjax">$\|$</span> является операцией конкатенации битовых строк. Для аутентификации большого объёма информации этот способ не подходит из-за медленной операции вычисления подписи. Например, вычисление одной ЭЦП на криптосистемах с открытым ключом занимает порядка 10 мс на ПК. При средней длине IP-пакета 1 Кбайт, для каждого из которых требуется вычислить имитовставку, получим максимальную пропускную способность в <span class="mathjax">$\frac{1 ~ \text{Кбайт}}{10 ~ \text{мс}} = 100$</span> Кбайт/с.</p><p>Поэтому для большого объёма данных, которые нужно аутентифицировать, <span class="mathjax">$A$</span> и <span class="mathjax">$B$</span> создают общий секретный ключ аутентификации <span class="mathjax">$K$</span>. Далее имитовставка вычисляется либо с помощью модификации блочного шифра, либо с помощью криптографической хеш-функции.</p><p>Для каждого пакета информации <span class="mathjax">$m$</span> отправитель <span class="mathjax">$A$</span> вычисляет <span class="mathjax">${\textrm{MAC}}(K,m)$</span> и присоединяет его к сообщению <span class="mathjax">$m$</span>:</p><div class="mathjax" style="text-align: center;">$$ m ~ \|~ {\textrm{MAC}}(K,m). $$</div><p>Зная секретный ключ <span class="mathjax">$K$</span>, получатель <span class="mathjax">$B$</span> может удостовериться с помощью кода аутентификации, что информация не была изменена или фальсифицирована, а была создана отправителем.</p><p>Требования к длине кода аутентификации в общем случае такие же, как и для криптографической хеш-функции, то есть длина должна быть не менее 160--256 бит. На практике часто используют усечённые имитовставки.</p><p>Стандартные способы использования имитовставки сообщения следующие.</p><ul><li>Если шифрование данных не применяется, отправитель <span class="mathjax">$A$</span> для каждого пакета информации <span class="mathjax">$m$</span> отсылает сообщение
        <div class="mathjax" style="text-align: center;">$$ m ~\|~ {\textrm{MAC}}(K, m) .$$</div></li><li>Если используется шифрование данных симметричной криптосистемой с помощью ключа <span class="mathjax">$K_e$</span>, то имитовставка с ключом <span class="mathjax">$K_a$</span> может вычисляться как до, так и после шифрования:
        <div class="mathjax" style="text-align: center;">$$ E_{K_e}(m) ~\|~ {\textrm{MAC}}(K_a, E_{K_e}(m)) ~~ \text{ или } ~~ E_{K_e}(m ~\|~ {\textrm{MAC}}(K_a, m)). $$</div></li></ul><p>Первый способ, используемый в IPsec<a name="N89596"><!--протокол!IPsec--></a>, хорош тем, что для проверки целостности достаточно вычислить только имитовставку, тогда как во втором случае перед проверкой необходимо дополнительно расшифровать данные. С другой стороны, во втором способе, используемом в системе PGP<a name="N89602"><!--протокол!PGP--></a>, защищённость имитовставки не зависит от потенциальной уязвимости алгоритма шифрования.</p><p>Вычисление имитовставки от пакета информации <span class="mathjax">$m$</span> с использованием блочного шифра <span class="mathjax">$E$</span> осуществляется в виде:</p><div class="mathjax" style="text-align: center;">$$ {\textrm{MAC}}(K, m) = E_K(H(m)), $$</div><p>где <span class="mathjax">$H$</span> &ndash; криптографическая хеш-функция.</p><p>Имитовставка на основе хеш-функции обозначается <span class="mathjax">${\textrm{HMAC}}$</span> (англ. <span lang="en"><i>Hash-based MAC</i></span>)<a name="N89636"><!--HMAC--></a> и стандартно вычисляется в виде:</p><div class="mathjax" style="text-align: center;">$$ {\textrm{HMAC}}(K, m) = H(K \| H(K \| m)). $$</div><p>Возможно также вычисление в виде:</p><div class="mathjax" style="text-align: center;">$$ {\textrm{HMAC}}(K, m) = H(K \| m \| K). $$</div><p>В протоколе IPsec<a name="N89648"><!--протокол!IPsec--></a> используется следующий способ вычисления кода аутентификации:</p><div class="mathjax" style="text-align: center;">$$ {\textrm{HMAC}}(K, m) = H((K \oplus ~ \textrm{opad}) ~\|~ H((K \oplus ~ \textrm{ipad}) ~\|~ m)), $$</div><p>где <span class="mathjax">$\textrm{opad}$</span> &ndash; последовательность повторяющихся байтов</p><div class="mathjax" style="text-align: center;">$$ \text{\texttt{0x5C}}= [01011100]_2, $$</div><p><span class="mathjax">$\textrm{ipad}$</span> &ndash; последовательность повторяющихся байтов</p><div class="mathjax" style="text-align: center;">$$ \text{\texttt{0x36}} = [00110110]_2, $$</div><p>которые инвертируют половину битов ключа. Считается, что использование различных значений ключа повышает криптостойкость.</p><p>В протоколе защищённой связи SSL/TLS<a name="N89669"><!--протокол!SSL/TLS--></a>, используемом в интернете для инкапсуляции, в том числе, протокола HTTP<a name="N89675"><!--протокол!HTTP--></a> в протокол HTTPS<a name="N89681"><!--протокол!HTTPS--></a>, код <span class="mathjax">${\textrm{HMAC}}$</span> определяется почти так же, как в IPsec. Отличие состоит в том, что вместо операции XOR для последовательностей <span class="mathjax">$\textrm{ipad}$</span> и <span class="mathjax">$\textrm{opad}$</span> осуществляется конкатенация:</p><div class="mathjax" style="text-align: center;">$$ {\textrm{HMAC}}(K, m) = H((K ~\|~ \textrm{opad}) ~\|~ H((K ~\|~ \textrm{ipad}) ~\|~ m)). $$</div><p>Двойное хеширование<a name="N89699"><!--двойное хеширование--></a> с ключом в</p><div class="mathjax" style="text-align: center;">$$ {\textrm{HMAC}}(K, m) = H(K \| H(K \| m)) $$</div><p>применяется для защиты от атаки на расширение сообщений. Вычисление хеш-функции от сообщения <span class="mathjax">$m$</span>, состоящего из <span class="mathjax">$n$</span> блоков <span class="mathjax">$m_{1}, m_2 \dots m_n$</span>, можно записать в виде:</p><div class="mathjax" style="text-align: center;">$$\begin{array}{l}
	m \equiv m_1 \Vert m_2 \Vert \dots \Vert m_n, \\
	H_0 \equiv IV = \textrm{const}, \\
	H_i = f(H_{i-1}, m_i), i \in \{ 1, 2, \dots, n \},\\
	H(m) \equiv H_n,
\end{array}$$</div><p>где <span class="mathjax">$f$</span> &ndash; известная сжимающая функция.</p><p>Пусть имитовставка использует одинарное хеширование с ключом:</p><div class="mathjax" style="text-align: center;">$$ {\textrm{MAC}}(K, m) = H(K \| m) = H (m_0 = K \| m_1 \| m_2 \| \dots \| m_n). $$</div><p>Тогда криптоаналитик, не зная секретного ключа, имеет возможность вычислить имитовставку для некоторого расширенного сообщения <span class="mathjax">$m \| m_{n+1}$</span>:</p><div class="mathjax" style="text-align: center;">$$
    {\textrm{MAC}}(K, m \| m_{n+1}) = \underbrace{H \left( K \| m_1 \| m_2 \| \dots \| m_n \right.}_{{\textrm{MAC}}(K, m)} \left. \| m_{n+1} \right) =
$$</div><div class="mathjax" style="text-align: center;">$$
     = f({\textrm{MAC}}(K, m), m_{n+1}).
$$</div><h3 data-command-name="subsection" id="8_5_2_Универсальное_хеширование">8.5.2. Универсальное хеширование</h3><p>Наличие одного единственного правила хеширования может привести к тому, что злоумышленник, зная точную формулу вычисления хеша, сможет подобрать такой набор входных данных, который с большой степенью вероятности даёт коллизии обычной (не криптографической) хеш-функции. Кроме того, сами хеш-функции также разрабатываются исходя из определённого предположения о входных данных. Алгоритмы хеширования могут содержать некоторые константы, которые разработчику информационной системы предлагается выбрать самостоятельно, основываясь на его предположениях об особенностях входных данных. Но квалификации разработчика, либо его априорных знаний, может не хватать для эффективного выбора конкретной реализации (алгоритм и параметры) хеширования. Исходя из этого Картер и Вегман в 1979 году (англ. <span lang="en"><i>John Lawrence Carter, Mark N. Wegman</i></span>, <a href="Literatura.html#Carter:Wegman:1979">[23]</a>) предложили определить класс алгоритмов хеширования с возможностью выбора одного из них непосредственно в момент вызова.</p><p>Обозначим через <span class="mathjax">$\delta$</span> возможный факт совпадения значения некоторой унарной функции для некоторых значений аргументов:</p><div class="mathjax" style="text-align: center;">$$
\delta_{f}( x, y ) = \left\{\begin{matrix}
1, &amp; f(x) = f(y);\\ 
0, &amp; f(x) \neq f(y).
\end{matrix}\right.
$$</div><p>Пусть <span class="mathjax">$H$</span> &ndash; класс функций, преобразующих <span class="mathjax">$M \to R$</span>. Будем называть класс <span class="mathjax">$H$</span> универсальным<span class="mathjax">$_{2}$</span>, если</p><div class="mathjax" style="text-align: center;">$$
\forall x, y \in M: \sum_{h \in H} \delta_{h}( x, y ) \leq |H| / |R|.
$$</div><p>То есть класс функций <span class="mathjax">$H$</span> универсален<span class="mathjax">$_{2}$</span>, если для любых пар аргументов <span class="mathjax">$x$</span> и <span class="mathjax">$y$</span> значения функций совпадают не более чем для <span class="mathjax">$1/|R|$</span>-ой части функций из множества <span class="mathjax">$H$</span>. Нижний индекс &laquo;<span class="mathjax">$_{2}$</span>&raquo; подчёркивает тот факт, что речь идёт о совпадении значений только для пар элементов. В дальнейшем мы его будем опускать.</p><p>Примеры универсальных классов для хеширования:</p><command name="footnote"><argument required="true">Универсальность первых двух примеров была показана ещё в работе Картера и Вегмана<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Carter:Wegman:1979">[23]</a>. Последний описан, например, в<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Dietzfelbinger:Gil:Matias:Pippenger:1992">[84]</a>.</argument></command><ul><li>функции хеширования для чисел <span class="mathjax">$x$</span>
    <div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    h(x) = ax + b \bmod p,\\
    a \in {{\mathbb{Z}}}^*_p, b \in {{\mathbb{Z}}}_p;\\
    \end{array} $$</div></li><li>функции хеширования для векторов <span class="mathjax">$\vec{x}$</span>
    <div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    \vec{x} = \left \langle x_0, x_1, \dots, x_r \right \rangle,\\
    \vec{a} = \left \langle a_0, a_1, \dots, a_r \right \rangle,\\
    \forall i \in {{\mathbb{Z}}}_{r+1}: a_i \in {{\mathbb{Z}}}_{p},\\
    h( \vec{x} ) = \sum_{i=0}^{r} a_i x_i \bmod p;\\
    \end{array} $$</div></li><li>функции хеширования для строк (последовательностей переменной длины) <span class="mathjax">$\vec{x}$</span>
    <div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    \vec{x} = \left \langle x_0, x_1, \dots, x_l \right \rangle,\\
    \forall x_i: x_i \in {{\mathbb{Z}}}_{u}, \\
    p \geq u, \\
    a \in {{\mathbb{Z}}}_{p}, a \neq 0,\\
    h( \vec{x} ) = \sum_{i=0}^{l} a^{i} x_i \bmod p.\\
    \end{array} $$</div></li></ul><p>На основе универсального хеширования построены такие криптографические примитивы, как UMAC и Poly1305 (RFC 8439).</p><h3 data-command-name="subsection" id="8_5_3_Одноразовая_имитовставка">8.5.3. Одноразовая имитовставка</h3><p>Одноразовый MAC (англ. <span lang="en"><i>One-Time MAC</i></span>) можно рассматривать как аналог одноразового шифрблокнота для целей аутентификации сообщения. Если использовать один ключ для ровно одного сообщения, можно построить код аутентификации, который гарантированно не может быть подделан злоумышленником.</p><p>Если сообщение короткое, то можно считать ключом два числа <span class="mathjax">$a$</span> и <span class="mathjax">$b$</span>, а в качестве значения MAC для сообщения <span class="mathjax">$m \in M$</span> будет выступать</p><div class="mathjax" style="text-align: center;">$$
h(m) = a \times m + b \bmod p.
$$</div><p>Если <span class="mathjax">$p$</span> &ndash; простое, то вероятность угадать значение MAC для некоторого сообщения <span class="mathjax">$m_2$</span> (то есть подменить сообщение <span class="mathjax">$m_1$</span> с одновременной генерацией нового MAC) без знания ключа <span class="mathjax">$k=\overrightarrow{(a,b)}$</span>, равна строго <span class="mathjax">$1/p$</span>.</p><p>Можно воспользоваться описанной ранее функцией хеширования для сообщений переменной длины и использовать чуть более сложную формулу для вычисления MAC:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
\vec{m} = \left \langle m_1, m_2, \dots, m_l \right \rangle, \\
h(\vec{m}) = b + \sum_{i=1}^{l} a^i m_i \mod p. \\
\end{array}  $$</div><p>Для этой формулы по прежнему сохраняется свойство, что если ключ <span class="mathjax">$k=\overrightarrow{(a,b)}$</span> используется ровно один раз, злоумышленник не сможет подделать (угадать) MAC с вероятностью более <span class="mathjax">$1/p$</span>.</p><h3 data-command-name="subsection" id="8_5_4_Конструкция_Вегмана_Картера">8.5.4. Конструкция Вегмана-Картера</h3><p>В 1981 году Вегман и Картер предложили (<a href="Literatura.html#Wegman:Carter:1981">[108]</a>) использовать универсальное хеширование (раздел<span class="nonbreaking-interword-space"> </span><a href="#sec:universal-hashing">8.5.2</a>) для построение алгоритмов имитовставок. В оригинале авторы предполагали, что каждое сообщение содержит неповторяющийся номер <span class="mathjax">$i$</span>, а секретный ключ между отправителем и получателем состоит из двух частей:</p><ul><li>параметра <span class="mathjax">$k_1$</span>, задающего способ выбора функции из универсального класса хеширования <span class="mathjax">$H: K \times A \to B$</span>;</li><li>параметра <span class="mathjax">$k_2$</span>, который является <em>последовательностью</em> строк <span class="mathjax">$b_1, b_2, \dots, b_n$</span>, длина каждой из которых совпадает с размером элементов множества <span class="mathjax">$B$</span>.</li></ul><p>Результатом вычисления имитовставки является:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    m' = \langle i, m \rangle,\\
    \textrm{MAC} (m') = H_{k_1}(m) \oplus b_i.
\end{array} $$</div><p>Авторы показали надёжность данной схемы при условии случайного выбора ключей и универсальности класса хеширования. Однако с практической точки зрения использовать ключи, состоящие из <em>последовательностей</em> очень непрактично. Более того, можно было передать столько сообщений, сколько элементов последовательности задано в <span class="mathjax">$k_2$</span>. Для передачи сообщения сверх этого лимита нужно было либо расширить существующий ключ, либо сгенерировать новый.</p><p>По этой причине сейчас вместо использования последовательности строк <span class="mathjax">$b_1, b_2, \dots, b_n$</span> в качестве ключа предполагается наличие некоторого класса псевдослучайных функций (англ. <span lang="en"><i>pseudorandom function family, PRF</i></span>), который эмулирует <em>случайного оракула</em><a name="N90009"><!--оракул!случайный--></a>. В своей идеализированной модели он для каждого некоторого входа может выдать ответ, случайно распределённой по области значений. Однако если на вход случайного оракула будет подано уже ранее подававшееся значение, он должен выдать прежний ответ. Входом этого оракула являются, во-первых, некоторое случайное число <span class="mathjax">$r$</span>, которое заменило собой номер сообщения, во-вторых часть общего секретного ключа <span class="mathjax">$k_2$</span>, которая будет служить для выбора конкретной функции из класса псевдослучайных.</p><p>В качестве практической реализации такого класса функций могут, с некоторым приближением, выступать другие реализации имитовставок, даже если они медленно работают. Например, основанные на криптографических хеш-функциях или блочных шифрах. Потому что им на вход (в отличие от быстрой функции универсального хеширования) подаётся только небольшой блок информации &ndash; случайное число <span class="mathjax">$r$</span>.</p><p>Таким образом, современную конструкцию Вегмана-Картера можно описать так. Пусть выбран некоторый класс универсальных хеш-функций (например, в качестве него можно использовать одноразовую имитовставку из раздела<span class="nonbreaking-interword-space"> </span><a href="#sec:one-time-mac">8.5.3</a>)</p><div class="mathjax" style="text-align: center;">$$
    H: \{0,1\}^{|k_1|} \times \{0,1\}^* \to \{0,1\}^n,
$$</div><p>и некоторая надёжная реализация медленной имитовставки</p><div class="mathjax" style="text-align: center;">$$
    PRF: \{0,1\}^{|k_2|} \times \{0,1\}^{|r|} \to \{0,1\}^n.
$$</div><p>Тогда получение быстрой имитовставки можно сделать следующим образом</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
\textrm{secret key: } k: \langle k_1, k_2 \rangle,\\
\textrm{random nonce: } r \leftarrow \{0,1\}^n,\\
\textrm{MAC} (m) = \langle r, H_{k_1}(m) \oplus PRF_{k_2}(r) \rangle.
\end{array} $$</div><p>Как утверждается в<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Krovetz:2000">[57]</a>, использование данной конструкции позволяет достичь скорости хеширования в <span class="mathjax">$0{,}5$</span> циклов процессора на один байт сообщения (англ. <span lang="en"><i>cycles per byte, cpb</i></span>).</p><h3 data-command-name="subsection" id="8_5_5_UMAC">8.5.5. UMAC</h3><p>Конструкция UMAC, предложенная в 1999 году (<a href="Literatura.html#Black:Halevi:Krawczyk:etc:1999">[103]</a>), также использует подход с быстрым универсальным хешированием большого исходного сообщения и хешированием небольшого блока информации надёжной (на 1999 год), но медленной ключевой функцией HMAC-SHA1. В 2003 году вошёл в список алгоритмов, отобранных инициативой NESSIE (англ. <span lang="en"><i>New European Schemes for Signatures, Integrity, and Encryptions</i></span>) как безопасный алгоритм вычисления имитовставки. В 2006 году был стандартизован как RFC<span class="nonbreaking-interword-space"> </span>4418 (<a href="Literatura.html#rfc4418">[104]</a>). На сегодняшний день не считается криптографически стойким из-за уязвимостей, найденных в SHA-1.</p><p>Используемый в UMAC универсальный<span class="mathjax">$_2$</span> класс хеш-функций <span class="mathjax">$\textrm{NH}_K (m)$</span> описывается следующим образом. Битовая строка <span class="mathjax">$m$</span> длиной до 1024 32-битовых &laquo;слов&raquo; и размером, кратная 2 &laquo;словам&raquo;, разбивается на отдельные блоки по 32 бита <span class="mathjax">$m_1, m_2, \dots, m_l$</span>. 32-битные ключи <span class="mathjax">$K_1, K_2, \dots, K_l$</span> получаются из исходного ключа <span class="mathjax">$K$</span> с помощью генератора псевдослучайных чисел. Далее вычисление 64-битового хеша выглядит так:</p><div class="mathjax" style="text-align: center;">$$\begin{array}{ll}
    \textrm{NH}_K (m) = &amp; ( m_1 +_{32}K_1) \times_{64} (m_2 +_{32} K_2) +_{64} \dots \\
                        &amp; \dots ~ +_{64} ~ \dots \\
                        &amp; \dots ~ +_{64} ~ (m_{l-1} +_{32} K_{l-1}) \times_{64} (m_l+_{32}K_l),
\end{array} $$</div><p>где <span class="mathjax">$+_{32}$</span> &ndash; сложение 32-битных строк, в результате которого получается 32-битная сумма, <span class="mathjax">$\times_{64}$</span> &ndash; произведение двух 32-битных строк, и получаемый 64-битный результат умножения (рис.<span class="nonbreaking-interword-space"> </span><a href="8_5_Imitovstavka_MAC_.html#fig:UMAC">8.11</a>).</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:UMAC" style="vertical-align: top; align-self: start;"></a><img src="images/3E9377D94A8046DED2F39803C04C0602.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 8.11 &mdash; Универсальное хеширование <span class="mathjax">$\textrm{NH}_K (m)$</span> в UMAC</figcaption></figure><p>Генерация имитовставки делается следующим образом. Предполагается, что вместе с сообщением <span class="mathjax">$m$</span> передаётся случайная строка <em>nonce</em> (должна быть уникальна для каждого сообщения), а у отправителя и получателя есть общий секретный ключ <span class="mathjax">$K$</span>.</p><ol><li>Пусть Len это остаток от деления длины сообщения в битах <span class="mathjax">$|m|$</span> на 4096:<div class="mathjax" style="text-align: center;">$$
        \textrm{Len} = |m| \bmod 4096.
    $$</div></li><li>Сообщение <span class="mathjax">$m$</span> в битовом представлении дополняется нулями таким образом, чтобы длина сообщения <span class="mathjax">$|m|$</span> была кратна 64 бит (8 байт).</li><li>Сообщение <span class="mathjax">$m$</span> разбивается на блоки по 32768 бита (1024 &laquo;слова&raquo; по 32 бита) <span class="mathjax">$m_1, m_2, \dots, m_t$</span>. Последний блок будет содержать от 2 до 1024 &laquo;слов&raquo;.</li><li>Каждый блок хешируется ключевой хеш-функцией <span class="mathjax">$\textrm{NH}_K$</span>, результаты конкатенируются между собой и <span class="mathjax">$Len$</span>:<div class="mathjax" style="text-align: center;">$$
        H_K(m) = \textrm{NH}_K (m_1) ~ \| ~ \textrm{NH}_K (m_2) ~ \| ~ \dots ~ \| ~ \textrm{NH}_K (m_t) ~ \| ~ \textrm{Len}.
    $$</div></li><li>Итоговое значение имитовставки получается через хеширование ключевой функцией HMAC-SHA1:<div class="mathjax" style="text-align: center;">$$
        \textrm{UMAC}_K( m, \textrm{nonce} ) = \textrm{HMAC-SHA1}_K( \textrm{nonce} ~ \| ~ H_K(m) ).
    $$</div></li></ol><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="8_4_Hesh_funktsija_Stribog_.html">&#129080; 8_4_Hesh_funktsija_Stribog_</a></li><li class="page-item"><a class="page-link" href="8_6_Kollizii_v_hesh_funktsijah.html">8_6_Kollizii_v_hesh_funktsijah &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>