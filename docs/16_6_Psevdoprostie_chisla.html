<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="16_6_Псевдопростые_числа">16.6. Псевдопростые числа</h2><p><a name="N116048"><!--число!псевдопростое--></a></p><h3 data-command-name="subsection" id="16_6_1_Оценка_числа_простых_чисел">16.6.1. Оценка числа простых чисел</h3><p>Функция <span class="mathjax">$\pi(n)$</span> определяется как количество простых<a name="N116074"><!--число!простое--></a> чисел из диапазона <span class="mathjax">$[2, n]$</span>.
Существует предел<span class="nonbreaking-interword-space"> </span>[<a href="Literatura.html#ValleePoussin:1896">27</a>, <a href="Literatura.html#Hadamard:1896">44</a>]</p><div class="mathjax" style="text-align: center;">$$ \lim\limits_{n \rightarrow \infty}\frac{ \pi(n)}{ \frac{n}{\ln n}}=1. $$</div><p>Для <span class="mathjax">$n \geq 17$</span> верно неравенство <span class="mathjax">$\pi(n) &gt; \frac{n}{\ln n}$</span>.</p><p>Идея поиска(генерации) простых чисел состоит в случайном выборе числа и тестировании его на простоту.</p><p>Вероятность <span class="mathjax">$P_k$</span> того, что случайное <span class="mathjax">$k$</span>-битовое число <span class="mathjax">$n$</span> будет простым, равна</p><div class="mathjax" style="text-align: center;">$$ \lim\limits_{k \rightarrow \infty} P_k = \frac{1}{\ln n} = \frac{1}{k \ln 2}. $$</div><p><span style="font-variant: small-caps;"><b>Пример.</b></span> 
    Вероятность того, что случайное 500-битное число, включая чётные числа, будет простым, примерно равна <span class="mathjax">$\frac{1}{347}$</span>, вероятность простоты случайного 2000-битного числа примерно равна <span class="mathjax">$\frac{1}{1386}$</span>.</p><p>Для дальнейшего рассмотрения интересен также вопрос об оценке вероятности того, что число <span class="mathjax">$n$</span> будет простым, если оно априори взаимно простое с первыми <span class="mathjax">$L$</span> простыми числами.</p><p>Пусть</p><div class="mathjax" style="text-align: center;">$$ \Delta_L = 2 \cdot 3 \cdot 5 \cdot ~\cdots~ \cdot p_L = \prod \limits_{p \leq p_L} p $$</div><p>&ndash; произведение первых <span class="mathjax">$L$</span> простых чисел. Из теоремы о распределении простых чисел<a name="N116139"><!--теорема!о распределении простых чисел--></a> следует:</p><div class="mathjax" style="text-align: center;">$$ L \approx \frac{p_L}{\ln p_L}, ~~ p_L \approx L \ln L. $$</div><!--%TODO Что то из Чебышева--><p>Вероятность того, что случайное <em>нечётное</em> число не будет иметь общих делителей с первыми <span class="mathjax">$L$</span> простыми числами, равна</p><div class="mathjax" style="text-align: center;">$$ P(L) = \prod \limits_{3 \leq p \leq p_L} \left( 1 - \frac{1}{p} \right). $$</div><p>Используя приближение <span class="mathjax">$1-x \leq e^{-x}$</span>, получаем:</p><div class="mathjax" style="text-align: center;">$$ P(L) ~\lesssim~ \operatorname{exp}\left(-\sum\limits_{3 \leq p \leq p_L} \frac{1}{p}\right) = \operatorname{exp}\left(\frac{1}{2}  - \sum\limits_{p \leq p_L} \frac{1}{p}\right). $$</div><p>Существует предел</p><div class="mathjax" style="text-align: center;">$$ \lim \limits_{n \rightarrow \infty} \left( \sum \limits_{p \leq n} \frac{1}{p} - \ln \ln n \right) = M, $$</div><p>называемый константой Мейсселя<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Мертенса:<a name="N116175"><!--константа!Мейсселя—Мертенса--></a></p><div class="mathjax" style="text-align: center;">$$ M \approx 0.261497. $$</div><p>Упрощая уравнение, получаем:</p><div class="mathjax" style="text-align: center;">$$ P(L) \approx e^{\frac{1}{2} - \ln \ln p_L - M} = \frac{e^{\frac{1}{2} - M}}{\ln(L \ln L)}. $$</div><h3 data-command-name="subsection" id="16_6_2_Генерирование_псевдопростых_чисел">16.6.2. Генерирование псевдопростых чисел</h3><p>Значительная часть криптосистем на открытых ключах основывается на использовании больших простых чисел. Однако получение таких чисел не является тривиальной операцией.</p><p>Генерировать большие простые числа заранее и сохранять их в некоторой таблице, например, для их последующего использования в качестве множителей модуля <span class="mathjax">$n$</span> в криптосистеме RSA, небезопасно. Криптоаналитику для факторизации <span class="mathjax">$n$</span> вместо перебора всех простых чисел в качестве кандидатов делителей <span class="mathjax">$n$</span> будет достаточно перебрать заранее сохранённую таблицу возможных кандидатов. Однако и эффективной процедуры <em>генерации</em> больших простых чисел, пригодных для использования в криптографии, неизвестно. Поэтому под генерацией больших простых чисел обычно используют и подразумевают процедуру <em>поиска</em> больших простых чисел, описанную ниже.</p><ol><li>Выбрать большое (псевдо)случайное нечётное число нужной битовой длины.</li><li>Проверить, является ли число простым<a name="N116235"><!--число!простое--></a>.</li><li>Если не является, то вернуться к п. 1. Иначе вернуть число как результат процедуры.</li></ol><p>Дополнительной проблемой является тот факт, что быстрые и качественные алгоритмы проверки на простоту также неизвестны. Все существующие алгоритмы можно классифицировать следующим образом.</p><ul><li>Алгоритмы &laquo;<em>доказанные</em>&raquo; и &laquo;<em>недоказанные</em>&raquo;. Корректность &laquo;доказанных&raquo; алгоритмов основывается на доказанных математических утверждениях. Остальные алгоритмы могут приводиться без доказательств либо могут быть основаны на недоказанных математических гипотезах, таких как гипотеза Римана. Существуют также <em>некорректные</em> алгоритмы, для которых доказано, что результат их работы для некоторых чисел ошибочен.</li><li>Некоторые алгоритмы для своей работы используют случайные числа, из-за чего результат их работы может отличаться от запуска к запуску. Такие алгоритмы называются <em>вероятностными</em>, остальные &ndash; <em>детерминированными</em>. Для вероятностных алгоритмов существует вероятность ошибки <span class="mathjax">$\epsilon$</span>, которая может являться функцией от дополнительного аргумента алгоритма (например, от числа раундов). В зависимости от теста, ошибка может быть как в объявлении простого числа составным, так и в объявлении составного числа простым.</li><li>По производительности алгоритмы проверки чисел на простоту разделяют на <em>полиномиальные</em> и <em>неполиномиальные</em> от длины числа. Количество операций для полиномиального алгоритма не должно превышать значение некоторого полинома от битовой длины числа.</li></ul><p>Идеальный алгоритм проверки чисел на простоту должен быть доказанным, детерминированным и полиномиальным. Кроме ограниченного роста количества операций (&laquo;полиномиального&raquo;) алгоритм должен обладать высокой скоростью работы для тех чисел, которые используются уже сейчас (2000 бит и выше) на современных персональных компьютерах. К сожалению, такие алгоритмы неизвестны.</p><ul><li>&laquo;Наивный&raquo; алгоритм (разд.<span class="nonbreaking-interword-space"> </span><a href="#section-prime-check-naive">16.6.3</a>) является доказанным, детерминированным, но неполиномиальным (экспоненциальным) и медленным.</li><li>Тест Ферма<a name="N116309"><!--тест!Ферма--></a> (разд.<span class="nonbreaking-interword-space"> </span><a href="#section-prime-check-ferma">16.6.4</a>) также является доказанным, детерминированным, но неполиномиальным и медленным.</li><li>Тест Миллера<a name="N116324"><!--тест!Миллера--></a> (разд.<span class="nonbreaking-interword-space"> </span><a href="#section-prime-check-miller">16.6.5</a>) является детерминированным, полиномиальным, но недоказанным и относительно медленным.</li><li>Тест Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина<a name="N116343"><!--тест!Миллера—Рабина--></a> (разд.<span class="nonbreaking-interword-space"> </span><a href="#section-prime-check-miller-rabin">16.6.6</a>) является доказанным, полиномиальным, относительно быстрым, но вероятностным. Существует вероятность, что он объявит составное число простым.</li><li>Тест AKS (разд.<span class="nonbreaking-interword-space"> </span><a href="#section-prime-check-aks">16.6.7</a>) является доказанным, детерминированным, полиномиальным, но для существующей технологической базы медленным.</li></ul><p>В настоящий момент для проверки числа на простоту используют комбинацию &laquo;наивного&raquo; алгоритма и теста Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина<a name="N116374"><!--тест!Миллера—Рабина--></a>.</p><ol><li>Выбрать параметр &laquo;уверенности&raquo; (англ. <span lang="en"><i>certainty</i></span>), который вместе с требуемой битовой длиной числа будет являться входом алгоритма.</li><li>Выбрать большое (псевдо)случайное нечётное число <span class="mathjax">$n$</span> нужной битовой длины.</li><li>Проверить, является ли число <span class="mathjax">$n$</span> простым по &laquo;наивному&raquo; тесту до некоторого числа <span class="mathjax">$m \ll n$</span> (часто &ndash; константа алгоритма).</li><li>Проверить, является ли число <span class="mathjax">$n$</span> простым по тесту Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина с числом раундов, которое зависит от значения параметра &laquo;уверенности&raquo;.</li><li>Если число <span class="mathjax">$n$</span> прошло все тесты, то оно является выходом алгоритма. Иначе возвращаемся к п. 2.</li></ol><p>Числа, полученные с помощью подобного алгоритма (или любого другого, если для проверки на простоту используются вероятностные алгоритмы), называются <em>псевдопростыми</em><a name="N116433"><!--число!псевдопростое--></a>.</p><p>Согласно формулам из предыдущего раздела, в среднем за <span class="mathjax">$\ln n$</span> попыток встретится простое число. Если выбирать только нечётные числа, то среднее число попыток <span class="mathjax">$\frac{\ln n}{2}$</span>. Однако если выбирать такие числа, которые гарантированно не имеют малых делителей (&laquo;просеивание чисел&raquo;), то значительно повышаются шансы, что это число окажется простым. Например, для <span class="mathjax">$L = 10^4$</span> вероятность, что 1024-битовое нечётное число</p><div class="mathjax" style="text-align: center;">$$ n \approx 2^{1024} $$</div><p>окажется простым, повышается в</p><div class="mathjax" style="text-align: center;">$$ \frac{1}{P(10^4)} \approx 10 $$</div><p>раз. В среднем, каждое</p><div class="mathjax" style="text-align: center;">$$ \frac{\ln n}{2} \cdot P(L) \approx \frac{710}{2} \frac{1}{10} \approx 36 $$</div><p>36-е нечётное число может быть простым вместо каждого <span class="mathjax">$\frac{\ln n}{2} \approx 355$</span>-го числа, если нечётные числа выбирать без ограничений (без просеивания).</p><p>В этом случае средняя сложность генерирования <span class="mathjax">$k$</span>-битового псевдопростого числа имеет порядок:</p><div class="mathjax" style="text-align: center;">$$ O \left( \frac{\ln n}{2} \cdot \frac{1}{P(L)} \cdot \left( t k^3 \right) \right) = O(t k^4). $$</div><h3 data-command-name="subsection" id="16_6_3_Наивный_тест">16.6.3. &laquo;Наивный&raquo; тест</h3><p>&laquo;Наивный&raquo; тест состоит в проверке того, что число <span class="mathjax">$n$</span> не делится на числа от <span class="mathjax">$2$</span> до <span class="mathjax">$\sqrt{n}$</span>. Из определения простоты<a name="N116493"><!--число!простое--></a> числа следует, что алгоритм будет являться корректным. Также очевидно, что алгоритм будет являться неполиномиальным относительно битовой длины числа <span class="mathjax">$n$</span>. Однако на нём можно удачно проиллюстрировать определение &laquo;свидетеля простоты&raquo;, которое будет использоваться в алгоритмах в дальнейшем.</p><p>Будем называть число <span class="mathjax">$a$</span> <em>свидетелем простоты числа <span class="mathjax">$n$</span> по наивному алгоритму</em>, если выполняется условие</p><div class="mathjax" style="text-align: center;">$$
	n / a \notin {\mathbb{Z}}.
$$</div><p>Теперь детерминированный &laquo;наивный&raquo; алгоритм можно сформулировать следующим образом: если все числа <span class="mathjax">$a$</span> от 2 до <span class="mathjax">$\sqrt{n}$</span> являются свидетелями простоты числа <span class="mathjax">$n$</span> по наивному алгоритму, то число <span class="mathjax">$n$</span> является простым<a name="N116529"><!--число!простое--></a>. Иначе &ndash; составным<a name="N116535"><!--число!составное--></a>.</p><p>Детерминированный &laquo;наивный&raquo; тест можно превратить в вероятностный.</p><ol><li>Выберем случайным образом <span class="mathjax">$k$</span> различных <span class="mathjax">$a_1, a_2, \dots, a_k$</span> от 2 до <span class="mathjax">$\sqrt{n}$</span>.</li><li>Проверим, являются ли они все свидетелями простоты числа <span class="mathjax">$n$</span> по наивному алгоритму.</li><li>Если являются, то будем утверждать, что число <span class="mathjax">$n$</span> является псевдопростым<a name="N116563"><!--число!псевдопростое--></a> с вероятностью ошибки <span class="mathjax">$\epsilon &lt; \left( 1 - 1 / \sqrt{n} \right)^k$</span>, иначе &ndash; составным<a name="N116572"><!--число!составное--></a><command name="footnote"><argument required="true">Вероятность ошибки получена из вероятности &laquo;наткнуться&raquo; на <em>несвидетеля простоты числа <span class="mathjax">$n$</span> по наивному алгоритму</em>, которая для чисел от 2 до <span class="mathjax">$\sqrt{n}$</span> не менее <span class="mathjax">$1 / \sqrt{n}$</span> (минимальная вероятность для случая, когда <span class="mathjax">$n = p \times q$</span>, <span class="mathjax">$p &lt; \sqrt{n} &lt; q$</span>).</argument></command>.</li></ol><p>Так как проверку каждого &laquo;свидетеля&raquo; можно сделать за одну операцию деления (полиномиальное число операций относительно длины числа <span class="mathjax">$n$</span>), то для заданного числа проверок <span class="mathjax">$k$</span> данный вариант алгоритма будет являться доказанным, полиномиальным, но вероятностным. Кроме того, вероятность ошибки <span class="mathjax">$\epsilon$</span> слишком велика. Для того чтобы вероятность ошибки составляла менее 99, число проверок <span class="mathjax">$k$</span> должно быть сравнимо по величине с <span class="mathjax">$\sqrt{n}$</span>.</p><h3 data-command-name="subsection" id="16_6_4_Тест_Ферма">16.6.4. Тест Ферма</h3><p><a name="N116637"><!--тест!Ферма--></a>
Многие тесты на простоту основаны на малой теореме Ферма<a name="N116643"><!--теорема!Ферма малая--></a><span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Vinberg:2008">[113]</a>: если <span class="mathjax">$n$</span> &ndash; простое число и <span class="mathjax">$a$</span> &ndash; целое число, не делящееся на <span class="mathjax">$n$</span>, то</p><command name="equation"><argument required="true">equation</argument><content><a name="#eq:prime-check-ferma"></a>
    a^n-1 <command name="equiv"></command>1 <command name="mod"></command>n.
</content></command><p>Можно сформулировать следующую &laquo;обратную&raquo; теорему. Если для некоторого <span class="mathjax">$a: 1 &lt; a &lt; n$</span> не выполняется утверждение<span class="nonbreaking-interword-space"> </span><a href="#eq:prime-check-ferma">[eq:prime-check-ferma]</a>, то число <span class="mathjax">$n$</span> не является простым. На этой теореме основан следующий алгоритм, который и называется тестом Ферма.</p><p>Будем называть число <span class="mathjax">$a$</span> <em>свидетелем простоты числа <span class="mathjax">$n$</span> по Ферма</em>, если для него выполняется<span class="nonbreaking-interword-space"> </span><a href="#eq:prime-check-ferma">[eq:prime-check-ferma]</a>.</p><p>Тест Ферма для числа <span class="mathjax">$n$</span> состоит в том, чтобы проверить, что все числа от <span class="mathjax">$2$</span> до <span class="mathjax">$n$</span> являются свидетелями простоты числа <span class="mathjax">$n$</span> по Ферма. С точки зрения производительности, тест Ферма хуже &laquo;наивного&raquo; теста.</p><p>Вероятность встретить &laquo;свидетеля непростоты&raquo; аналогична &laquo;наивному&raquo; тесту в худшем случае (для чисел <span class="mathjax">$n$</span>, являющихся числами Кармайкла<a name="N116729"><!--число!Кармайкла--></a>), а скорость проверки одного свидетеля много меньше, чем у &laquo;наивного&raquo; теста.</p><h3 data-command-name="subsection" id="16_6_5_Тест_Миллера">16.6.5. Тест Миллера</h3><p><a name="N116752"><!--тест!Миллера--></a>
Улучшение теста Ферма<a name="N116758"><!--тест!Ферма--></a> основано на следующем утверждении: для простого<a name="N116764"><!--число!простое--></a> <span class="mathjax">$p$</span> из сравнений</p><div class="mathjax" style="text-align: center;">$$ a^2 \equiv 1 \mod p, $$</div><div class="mathjax" style="text-align: center;">$$ (a-1)(a+1) \equiv 0 \mod p $$</div><p>следует одно из двух утверждений:</p><div class="mathjax" style="text-align: center;">$$ \left[ \begin{array}{l}
     a \equiv 1 \mod p, \\
     a \equiv -1 \mod p. \\
\end{array} \right. $$</div><p>Для того чтобы использовать это утверждение, представим чётное число <span class="mathjax">$n - 1$</span> в виде произведения:</p><div class="mathjax" style="text-align: center;">$$ n-1 = 2^s r, $$</div><p>где <span class="mathjax">$s$</span> является натуральным числом, а <span class="mathjax">$r$</span> &ndash; нечётным. Возьмём некоторое <span class="mathjax">$a$</span>, <span class="mathjax">$1 &lt; a &lt; n$</span>, и рассмотрим последовательность чисел (все вычисления делаются по модулю <span class="mathjax">$n$</span>)</p><command name="equation"><argument required="true">equation</argument><content><a name="#eq:prime-check-miller-sequence"></a>
	a^r, a^2r, a^2^2 r, a^2^3 r, <command name="dots"></command>, a^2^s-1 r, a^2^s r = a^n-1 <command name="mod"></command>n.
</content></command><p>Если число <span class="mathjax">$n$</span> простое, то данная последовательность<span class="nonbreaking-interword-space"> </span><a href="#eq:prime-check-miller-sequence">[eq:prime-check-miller-sequence]</a> будет заканчиваться единицей. Причём в ряду<span class="nonbreaking-interword-space"> </span><a href="#eq:prime-check-miller-sequence">[eq:prime-check-miller-sequence]</a> перед единицей, если число <span class="mathjax">$n$</span> простое, должно идти либо число <span class="mathjax">$1$</span>, либо <span class="mathjax">$-1 \equiv n-1 \mod n$</span>. Основываясь на этом свойстве, можно сформулировать определение свидетеля простоты.</p><p>Будем говорить, что число <span class="mathjax">$a, 1 &lt; a &lt; n$</span>, является <em>свидетелем простоты числа <span class="mathjax">$n$</span> по Миллеру</em>, если ряд<span class="nonbreaking-interword-space"> </span><a href="#eq:prime-check-miller-sequence">[eq:prime-check-miller-sequence]</a> либо начинается с единицы, либо содержит число <span class="mathjax">$n-1$</span> и заканчивается единицей.</p><p><span style="font-variant: small-caps;"><b>Пример.</b></span> 
Рассмотрим <span class="mathjax">$n=4033$</span>. Значение <span class="mathjax">$s$</span> для <span class="mathjax">$n$</span> равно <span class="mathjax">$6$</span>, то есть <span class="mathjax">$n - 1 = 4032 = 63 \cdot 2^6$</span>. То есть степени, в которые нужно будет возводить потенциальные свидетели простоты, равны:</p><div class="mathjax" style="text-align: center;">$$ 63 \cdot 2^0, 63 \cdot 2^1, 63 \cdot 2^2, 63 \cdot 2^3, 63 \cdot 2^4, 63 \cdot 2^5, 63 \cdot 2^6= $$</div><div class="mathjax" style="text-align: center;">$$ 63, 126, 252, 504, 1008, 2016, 4032. $$</div><ul><li>Проверим, является ли число <span class="mathjax">$a_1 = 1592$</span> свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру. Вычислим степенной ряд:
		<div class="mathjax" style="text-align: center;">$$ a_1^{63}, a_1^{126}, a_1^{252}, a_1^{504}, a_1^{1008}, a_1^{2016}, a_1^{4032} \mod 4033 = $$</div>
		<div class="mathjax" style="text-align: center;">$$ 1, 1, 1, 1, 1, 1, 1. $$</div>
		Ряд состоит из всех единиц (начинается с единицы), поэтому <span class="mathjax">$a_1 = 1592$</span> является свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру.</li><li>Проверим, является ли число <span class="mathjax">$a_2 = 1094$</span> свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру. Вычислим степенной ряд:
		<div class="mathjax" style="text-align: center;">$$ a_2^{63}, a_2^{126}, a_2^{252}, a_2^{504}, a_2^{1008}, a_2^{2016}, a_2^{4032} \mod 4033 =$$</div>
		<div class="mathjax" style="text-align: center;">$$ 4032, 1, 1, 1, 1, 1, 1. $$</div>
		Ряд начинается с числа <span class="mathjax">$4032 \equiv -1 \mod 4033$</span> (содержит число <span class="mathjax">$n-1$</span> и заканчивается единицей), поэтому <span class="mathjax">$a_2 = 1094$</span> является свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру.</li><li>Проверим, является ли число <span class="mathjax">$a_3 = 368$</span> свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру. Вычислим степенной ряд:
		<div class="mathjax" style="text-align: center;">$$ a_3^{63}, a_3^{126}, a_3^{252}, a_3^{504}, a_3^{1008}, a_3^{2016}, a_3^{4032} \mod 4033 =$$</div>
		<div class="mathjax" style="text-align: center;">$$ 142, 4032, 1, 1, 1, 1, 1. $$</div>
		Ряд содержит число <span class="mathjax">$4032 \equiv -1 \mod 4033$</span> (содержит число <span class="mathjax">$n-1$</span> и заканчивается единицей), поэтому <span class="mathjax">$a_3 = 368$</span> является свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру.</li><li>Проверим, является ли число <span class="mathjax">$a_4 = 955$</span> свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру. Вычислим степенной ряд:
		<div class="mathjax" style="text-align: center;">$$ a_4^{63}, a_4^{126}, a_4^{252}, a_4^{504}, a_4^{1008}, a_4^{2016}, a_4^{4032} \mod 4033 = $$</div>
		<div class="mathjax" style="text-align: center;">$$ 591, 2443, 3442, 2443, 3442, 2443, 3442. $$</div>
		Ряд не заканчивается на единицу, поэтому <span class="mathjax">$a_4 = 955$</span> <em>не</em> является свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру.</li><li>Проверим, является ли число <span class="mathjax">$a_5 = 2593$</span> свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру. Вычислим степенной ряд:
		<div class="mathjax" style="text-align: center;">$$ a_5^{63}, a_5^{126}, a_5^{252}, a_5^{504}, a_5^{1008}, a_5^{2016}, a_5^{4032} \mod 4033 =$$</div>
		<div class="mathjax" style="text-align: center;">$$ 2256, 3923, 1, 1, 1, 1, 1. $$</div>
		Ряд хотя и заканчивается на единицу, но перед первой единицей не находится <span class="mathjax">$n-1$</span>, то есть ряд не содержит число <span class="mathjax">$n-1$</span> и не начинается на <span class="mathjax">$1$</span>, поэтому <span class="mathjax">$a_4 = 2593$</span> <em>не</em> является свидетелем простоты числа <span class="mathjax">$n = 4033$</span> по Миллеру. Можно ещё сказать, что данный пример показал наличие в мультипликативной группе<a name="N117036"><!--группа!мультипликативная--></a> <span class="mathjax">${\mathbb{Z}}_{4033}^{*}$</span> нетривиального <em>делителя нуля</em>, то есть существование нетривиального корня уравнения <span class="mathjax">$ x^2 \equiv 1 \mod 4033$</span>, а именно числа 3923.</li></ul><p>Вычисление ряда <span class="nonbreaking-interword-space"> </span><a href="#eq:prime-check-miller-sequence">[eq:prime-check-miller-sequence]</a> делается не дольше, чем вычисление элемента <span class="mathjax">$a^{n-1}$</span>. Сначала вычисляем <span class="mathjax">$a^{r}$</span>, а все остальные элементы ряда получаем, возводя предыдущий элемент в квадрат.</p><p>В 1975 году Миллер (англ. <span lang="en"><i>Gary L. Miller</i></span>, [<a href="Literatura.html#Miller:1975">74</a>, <a href="Literatura.html#Miller:1976">75</a>]) показал, что если число <span class="mathjax">$n$</span> является составным, и если верна расширенная гипотеза Римана</p><command name="footnote"><argument required="true">Гипотеза о распределении нулей дзета-функции Римана на комплексной плоскости.</argument></command><p>, то между 2 и <span class="mathjax">$O \left( \log^2 n \right)$</span> существует хотя бы одно число, не являющееся свидетелем простоты <span class="mathjax">$n$</span>. В 1985 году Эрик Бах (англ. <span lang="en"><i>Eric Bach</i></span>, <a href="Literatura.html#Bach:1990">[7]</a>) уменьшил границу до <span class="mathjax">$2 \ln^2 n$</span>. Что в результате приводит нас к тесту Миллера<a name="N117122"><!--тест!Миллера--></a>.</p><ol><li>Возьмём все целые (можно простые) числа от <span class="mathjax">$2$</span> до <span class="mathjax">$2 \ln^2 n$</span> и проверим, являются ли они свидетелями простоты числа <span class="mathjax">$n$</span> по Миллеру.</li><li>Если являются, то число <span class="mathjax">$n$</span> является простым<a name="N117145"><!--число!простое--></a>, иначе &ndash; составным<a name="N117151"><!--число!составное--></a>.</li></ol><p>Данный тест является недоказанным (основывается на недоказанной гипотезе Римана), детерминированным и полиномиальным, так как и проверка одного свидетеля, и общее число требуемых свидетелей являются полиномиальными функциями от длины <span class="mathjax">$n$</span>. Тем не менее, число проверок в тесте остаётся достаточно большим (для чисел размером в 2048 бит это составляет более 250 тыс. проверок).</p><h3 data-command-name="subsection" id="16_6_6_Тест_Миллера_Рабина">16.6.6. Тест Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина</h3><p><a name="N117182"><!--тест!Миллера—Рабина--></a>
В 1980 году Рабин (англ. <span lang="en"><i>Michael O. Rabin</i></span>, <a href="Literatura.html#Rabin:1980">[86]</a>) обратил внимание на то, что у нечётного составного числа <span class="mathjax">$n$</span> количество свидетелей простоты <span class="mathjax">$1 &lt; a &lt; n$</span> по Миллеру не превышает <span class="mathjax">$n/4$</span>. Это означает, что если число <span class="mathjax">$1 &lt; a &lt; n$</span> является свидетелем простоты числа <span class="mathjax">$n$</span> по Миллеру, то число <span class="mathjax">$n$</span> является простым с вероятностью ошибки не более чем <span class="mathjax">$1/4$</span>. Что приводит нас к вероятностному тесту Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина.</p><p>Тест Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина<a name="N117238"><!--тест!Миллера—Рабина--></a> состоит в проверке <span class="mathjax">$t$</span> случайно выбранных чисел <span class="mathjax">$1 &lt; a &lt; n$</span>. Если для всех <span class="mathjax">$t$</span> чисел <span class="mathjax">$a$</span> тест пройден, то <span class="mathjax">$n$</span> называется псевдопростым<a name="N117263"><!--число!псевдопростое--></a>, и вероятность того, что число <span class="mathjax">$n$</span> не простое, имеет оценку:</p><div class="mathjax" style="text-align: center;">$$ P_{error} &lt; \left( \frac{1}{4} \right)^t. $$</div><p>Если для какого-то числа <span class="mathjax">$a$</span> тест не пройден, то число <span class="mathjax">$n$</span> точно составное<a name="N117281"><!--число!составное--></a>.</p><p>Описание теста приведено в алгоритме<span class="nonbreaking-interword-space"> </span><a href="#miller-rabin">[miller-rabin]</a>.</p><command name="algorithm"><argument required="true">algorithm</argument><argument required="false">ht</argument><content>
    <command name="caption"><argument required="true">Вероятностный тест Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина проверки числа на простоту<a name="#miller-rabin"></a></argument></command>
    <command name="algorithmic"><argument required="true">algorithmic</argument><content>
        <command name="STATE"></command>Вход: нечётное <span class="mathjax">$n&gt;1$</span> для проверки на простоту и <span class="mathjax">$t$</span> &ndash; параметр надёжности.
        <command name="STATE"></command>Выход: <span style="font-variant: small-caps;">Составное</span> или <span style="font-variant: small-caps;">Псевдопростое</span>.
        <command name="STATE"></command><span class="mathjax">$n - 1 = 2^s r, ~ r$</span> &ndash; нечётное.
        <command name="FOR"><argument required="true"><span class="nonbreaking-interword-space"> </span><span class="mathjax">$j = 1$</span> <span class="nonbreaking-interword-space"> </span><b>to</b><span class="nonbreaking-interword-space"> </span> <span class="mathjax">$t$</span><span class="nonbreaking-interword-space"> </span></argument></command>
            <command name="STATE"></command>Выбрать случайное число <span class="mathjax">$a \in [2, n-2]$</span>.
            <command name="IF"><argument required="true"><span class="nonbreaking-interword-space"> </span><span class="mathjax">$(a_0 = a^r ~\neq~ \pm 1 \mod n)$</span> <span class="nonbreaking-interword-space"> </span><b>and</b> <line-break></line-break>
            <command name="indent"></command><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span> <span class="mathjax">$(\forall i \in [1, s-1] \rightarrow a_i = a_0^{2^i} ~\neq~ -1 \mod n)$</span><span class="nonbreaking-interword-space"> </span></argument></command>
               <command name="STATE"></command><b>return</b> <span style="font-variant: small-caps;">Составное</span>.
           <command name="ENDIF"></command>
        <command name="ENDFOR"></command>
       <command name="STATE"></command><b>return</b> <span style="font-variant: small-caps;">Псевдопростое</span> с вероятностью ошибки <span class="mathjax">$P_{error} &lt; \left( \frac{1}{4} \right)^t$</span>.
    </content></command>
</content></command><p>Сложность алгоритма Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина для <span class="mathjax">$k$</span>-битового числа <span class="mathjax">$n$</span> имеет порядок</p><div class="mathjax" style="text-align: center;">$$ O(t k^3) $$</div><p>двоичных операций, где <span class="mathjax">$t$</span> &ndash; количество раундов.</p><p><span style="font-variant: small-caps;"><b>Пример.</b></span> 
Пример выполнения теста Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина для <span class="mathjax">$n = 169, ~ n-1 = 21 \cdot 2^3$</span>.</p><p>Выберем следующие числа в качестве возможных кандидатов в свидетели простоты числа <span class="mathjax">$n$</span>: 2, 19, 22, 23.</p><p>Степени, в которые нужно возводить <span class="mathjax">$a$</span>: 21, 42, 84, 168.</p><ul><li><span class="mathjax">$a = 2$</span>
        <div class="mathjax" style="text-align: center;">$$\begin{matrix}
        a^{21} \bmod 169 &amp; = &amp; 2^{21} \bmod 169 &amp; = &amp; 31 \\ 
        a^{42} \bmod 169 &amp; = &amp; 31^2 \bmod 169 &amp; = &amp; 116 \\ 
        a^{84} \bmod 169 &amp; = &amp; 116^2 \bmod 169 &amp; = &amp; 116 \\ 
        a^{168} \bmod 169 &amp; = &amp; 116^2 \bmod 169 &amp; = &amp; 40
        \end{matrix}$$</div>
    Получилась последовательность: 31, 116, 105, 40.</li><li><span class="mathjax">$a = 19$</span>
        <div class="mathjax" style="text-align: center;">$$\begin{matrix}
        a^{21} \bmod 169 &amp; = &amp; 19^{21} \bmod 169 &amp; = &amp; 70 \\ 
        a^{42} \bmod 169 &amp; = &amp; 70^2 \bmod 169 &amp; = &amp; -1 \\ 
        a^{84} \bmod 169 &amp; = &amp; -1^2 \bmod 169 &amp; = &amp; 1 \\ 
        a^{168} \bmod 169 &amp; = &amp; 1^2 \bmod 169 &amp; = &amp; 1
        \end{matrix}$$</div>
    Получилась последовательность: 70, -1, 1, 1.</li><li><span class="mathjax">$a = 22$</span>
        <div class="mathjax" style="text-align: center;">$$\begin{matrix}
        a^{21} \bmod 169 &amp; = &amp; 22^{21} \bmod 169 &amp; = &amp; 1 \\ 
        a^{42} \bmod 169 &amp; = &amp; 1^2 \bmod 169 &amp; = &amp; 1 \\ 
        a^{84} \bmod 169 &amp; = &amp; 1^2 \bmod 169 &amp; = &amp; 1 \\ 
        a^{168} \bmod 169 &amp; = &amp; 1^2 \bmod 169 &amp; = &amp; 1
        \end{matrix}$$</div>
    Получилась последовательность: 1, 1, 1, 1.</li><li><span class="mathjax">$a = 23$</span>
        <div class="mathjax" style="text-align: center;">$$\begin{matrix}
        a^{21} \bmod 169 &amp; = &amp; 23^{21} \bmod 169 &amp; = &amp; -1 \\ 
        a^{42} \bmod 169 &amp; = &amp; -1^2 \bmod 169 &amp; = &amp; 1 \\ 
        a^{84} \bmod 169 &amp; = &amp; 1^2 \bmod 169 &amp; = &amp; 1 \\ 
        a^{168} \bmod 169 &amp; = &amp; 1^2 \bmod 169 &amp; = &amp; 1
        \end{matrix}$$</div>
    Получилась последовательность: -1, 1, 1, 1.</li></ul><p>Согласно определению выше, числа 19, 22 и 23 являются свидетелями простоты числа <span class="mathjax">$n=169$</span> по Миллеру. Если бы мы рассматривали только эти числа в качестве кандидатов в свидетели, то результатом работы алгоритма Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина был бы вывод, что число <span class="mathjax">$n=169$</span> является псевдопростым с вероятностью ошибки <span class="mathjax">$e = 1 / 4^3 = 0{,}015625 \approx 1{,}6$</span>. Однако так как в результате проверки числа <span class="mathjax">$a = 2$</span> было обнаружено, что оно не является свидетелем простоты, то результатом работы алгоритма является вывод, что число <span class="mathjax">$n=169$</span> составное.</p><p>Тест Миллера<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Рабина не основан на гипотезе Римана или других недоказанных утверждениях. Он является доказанным, полиномиальным, но вероятностным тестом простоты. Также он является наиболее используемым тестом простоты на сегодняшний день.</p><h3 data-command-name="subsection" id="16_6_7_Тест_AKS">16.6.7. Тест AKS</h3><p><a name="N117560"><!--тест!AKS--></a>
<em>Первый</em> корректный, детерминированный и полиномиальный алгоритм проверки числа на простоту предложили Агравал, Каял и Саксена (англ. <span lang="en"><i>Manindra Agrawal, Neeraj Kayal, Nitin Saxena</i></span>) в 2002 году<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#aks:2002">[2]</a>. Тест получил название AKS по фамилиям авторов. Сложность алгоритма для проверки <span class="mathjax">$k$</span>-битового числа равна</p><div class="mathjax" style="text-align: center;">$$ O(k^{6}). $$</div><p>К сожалению, несмотря на полиномиальность сложности теста, алгоритм очень медленный и не может быть применён для чисел с большой битовой длиной (в сотни, тысячи бит).</p><p>Основой теста является аналог малой теоремы Ферма<a name="N117596"><!--теорема!Ферма малая--></a> для многочленов. Пусть числа <span class="mathjax">$a$</span> и <span class="mathjax">$p&gt;1$</span> взаимно простые. В этом случае <span class="mathjax">$p$</span> &ndash; простое число тогда и только тогда, когда</p><command name="equation"><argument required="true">equation</argument><content>
    <a name="#eq:AKS1"></a>
    (x - a)^p = x^p - a <command name="mod"></command>p.
</content></command><p>Действительно, если <span class="mathjax">$p$</span> &ndash; простое<a name="N117632"><!--число!простое--></a>, то биномиальные коэффициенты <span class="mathjax">$\binom{p}{i},\ i = 1, \dots, p-1$</span> в разложении левой части делятся на <span class="mathjax">$p$</span>, то есть<span class="nonbreaking-interword-space"> </span><span class="mathjax">$\binom{p}{i} = 0 \mod p$</span>, а для последнего члена разложения <span class="mathjax">$a^p$</span> выполняется <span class="mathjax">$a^p = a \mod p$</span> по малой теореме Ферма<a name="N117654"><!--теорема!Ферма малая--></a>. Следовательно, равенство верно.</p><p>Пусть число <span class="mathjax">$p$</span> составное. Представим его в виде <span class="mathjax">$p = A q^r$</span> с взаимно простыми <span class="mathjax">$A$</span> и <span class="mathjax">$q$</span> для некоторого простого <span class="mathjax">$q$</span>. Тогда коэффициент <span class="mathjax">$\binom{p}{q}$</span> равен</p><div class="mathjax" style="text-align: center;">$$\begin{eqnarray} 
\binom{p}{q}  = \frac{(A q^r) (A q^r - 1)(A q^r - 2) \dots (A q^r - q + 1)}{q (q-1)(q-2) \cdots 1} = \\ 
= \frac{A q^r}{q} \cdot \frac{A q^r - 1}{q-1} \cdot \frac{A q^r - 2}{q-2} \cdot ~\cdots~ \cdot \frac{A q^r - q + 1}{1}. 
\end{eqnarray}$$</div><p>Первый множитель <span class="mathjax">$A q^r$</span> в числителе делится на <span class="mathjax">$q$</span>, далее идут</p><command name="mbox"><argument required="true"><span class="mathjax">$q-1$</span></argument></command><p>последовательно убывающих чисел, которые не делятся на <span class="mathjax">$q$</span>. Значит, <span class="mathjax">$\binom{p}{q}$</span> не делится на <span class="mathjax">$A q^r$</span>,<span class="nonbreaking-interword-space"> </span><span class="mathjax">$\binom{p}{q} \neq 0 \mod p$</span>. Следовательно,</p><div class="mathjax" style="text-align: center;">$$
(x - a)^p \neq x^p - a \mod p.
$$</div><p>Непосредственная проверка равенства</p><command name="eqref"><argument required="true">eq:AKS1</argument></command><p>является трудоёмкой из-за необходимости проверить все коэффициенты. Рассмотрим следующую модификацию теста, которая тоже имеет полиномиальную сложность. Пусть для некоторого числа <span class="mathjax">$r \nmid n$</span> (<span class="mathjax">$r$</span> не делит <span class="mathjax">$n$</span>) выполняется равенство</p><command name="equation"><argument required="true">equation</argument><content>
    <a name="#eq:AKS2"></a>
    (x - a)^p = x^p - a <command name="mod"></command>(x^r-1, p).
</content></command><p>Другими словами, пусть</p><div class="mathjax" style="text-align: center;">$$ (x - a)^p - (x^p - a) = (x^r-1) \cdot f(x) + p \cdot g(x) $$</div><p>для некоторых многочленов <span class="mathjax">$f(x)$</span> и <span class="mathjax">$g(x)$</span>. Тогда, либо <span class="mathjax">$p$</span> &ndash; простое, либо <span class="mathjax">$p^2 = 1 \mod r$</span>.</p><p>Описание теста AKS приведено в алгоритме<span class="nonbreaking-interword-space"> </span><a href="#alg:aks">[alg:aks]</a>.</p><command name="algorithm"><argument required="true">algorithm</argument><argument required="false">!ht</argument><content>
    <command name="caption"><argument required="true">Детерминированный полиномиальный тест AKS<a name="#alg:aks"></a></argument></command>
    <command name="algorithmic"><argument required="true">algorithmic</argument><content>
        <command name="STATE"></command>Вход: число <span class="mathjax">$n&gt;1$</span> для проверки на простоту.
        <command name="STATE"></command>Выход: <span style="font-variant: small-caps;">Составное</span> или <span style="font-variant: small-caps;">Простое</span>.
        <command name="IF"><argument required="true"><span class="nonbreaking-interword-space"> </span><span class="mathjax">$n = a^b, ~a, b \in {\mathbb{N}}, ~ b &gt; 1$</span>, для некоторых <span class="mathjax">$a, b$</span><span class="nonbreaking-interword-space"> </span></argument></command>
           <command name="STATE"></command><b>return</b> <span style="font-variant: small-caps;">Составное</span>.
        <command name="ENDIF"></command>
        <command name="STATE"></command><b>Найти</b> наименьшее <span class="mathjax">$r \in {\mathbb{N}}$</span> с порядком <span class="mathjax">$\ord_n(r) &gt; \log_2^2 n$</span>. Порядок числа <span class="mathjax">$r$</span> по модулю <span class="mathjax">$n$</span> определяется как минимальное число <span class="mathjax">$ord_n(r) \in {\mathbb{N}}$</span>: <line-break></line-break>
            <command name="indent"></command><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span> <span class="mathjax">$r^{\ord_n(r)} = 1 \mod n$</span>.
        <command name="IF"><argument required="true"><span class="nonbreaking-interword-space"> </span><span class="mathjax">$\gcd(a,n) \neq 1$</span> для некоторого <span class="mathjax">$a \in {\mathbb{N}}, ~a &lt; r$</span><span class="nonbreaking-interword-space"> </span></argument></command>
           <command name="STATE"></command><b>return</b> <span style="font-variant: small-caps;">Составное</span>.
        <command name="ENDIF"></command>
        <command name="FOR"><argument required="true"><span class="nonbreaking-interword-space"> </span><span class="mathjax">$a = 1$</span> <span class="nonbreaking-interword-space"> </span><b>to</b><span class="nonbreaking-interword-space"> </span> <span class="mathjax">$2 \sqrt{r} \log_2 n$</span><span class="nonbreaking-interword-space"> </span></argument></command>
            <command name="IF"><argument required="true"><span class="nonbreaking-interword-space"> </span><span class="mathjax">$(x - a)^n ~\neq~ x^n - a \mod (x^r - 1, n)$</span><span class="nonbreaking-interword-space"> </span></argument></command>
                <command name="STATE"></command><b>return</b> <span style="font-variant: small-caps;">Составное</span>.
            <command name="ENDIF"></command>
        <command name="ENDFOR"></command>
        <command name="STATE"></command><b>return</b> <span style="font-variant: small-caps;">Простое</span>
    </content></command>
</content></command><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="16_5_Modulnaja_arifmetika.html">&#129080; 16_5_Modulnaja_arifmetika</a></li><li class="page-item"><a class="page-link" href="16_7_Gruppi_tochek.html">16_7_Gruppi_tochek &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>