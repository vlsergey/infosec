<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="9_1_Криптосистема_RSA">9.1. Криптосистема RSA</h2><p><a name="N91333"><!--криптосистема!RSA|(--></a></p><h3 data-command-name="subsection" id="9_1_1_Шифрование">9.1.1. Шифрование</h3><p><a name="N91349"><!--шифр!RSA|(--></a>В 1978 г. Рональд Рив́ест, Ади Шамир и Леонард Адлеман (англ. <span lang="en"><i>Ronald Linn Rivest, Adi Shamir, Leonard Max Adleman</i></span>, <a href="Literatura.html#RSA:1978">[89]</a>) предложили алгоритм, обладающий рядом интересных для криптографии свойств. На его основе была построена первая система шифрования с открытым ключом, получившая название по первым буквам фамилий авторов &ndash; система RSA.</p><p>Рассмотрим принцип построения криптосистемы шифрования RSA с открытым ключом.</p><ol><li><b>Создание пары из закрытого и открытого ключей</b>
        <ol><li>Случайно выбрать большие простые<a name="N91383"><!--число!простое--></a> различные числа <span class="mathjax">$p$</span> и <span class="mathjax">$q$</span>, для которых <span class="mathjax">$\log_2 p \simeq \log_2 q &gt; 1024$</span> бита<command name="footnote"><argument required="true">Случайный выбор больших простых чисел не является простой задачей. См. раздел<span class="nonbreaking-interword-space"> </span><a href="#section-pseudo-primes-generation">16.6.2</a> в приложении.</argument></command>.</li><li>Вычислить произведение <span class="mathjax">$n = pq$</span>.</li><li>Вычислить функцию Эйлера<a name="N91418"><!--функция!Эйлера--></a><command name="footnote"><argument required="true">См. раздел<span class="nonbreaking-interword-space"> </span><a href="#section-group-multiplicative">16.3.3</a> в приложении.</argument></command> <span class="mathjax">$\varphi(n) = (p-1)(q-1)$</span>.</li><li>Выбрать случайное целое число <span class="mathjax">$e \in [3, \varphi(n)-1]$</span>, взаимно простое с <span class="mathjax">$\varphi(n)$</span>: <span class="mathjax">$~ \gcd(e, \varphi(n)) = 1$</span>.</li><li>Вычислить число <span class="mathjax">$d$</span> такое, что <span class="mathjax">$d \cdot e = 1 \mod \varphi(n)$</span>.</li><li>Закрытым ключом будем называть пару чисел <span class="mathjax">$n$</span> и <span class="mathjax">$d$</span>, открытым ключом<command name="footnote"><argument required="true">Некоторые авторы считают некорректным включать число <span class="mathjax">$n$</span> в состав закрытого ключа, так как оно уже входит в открытый. Авторы настоящего пособия включают число <span class="mathjax">$n$</span> в состав закрытого ключа, что в результате позволяет в дальнейшем использовать для расшифрования и создания электронной подписи данные <em>только</em> из закрытого ключа, не прибегая к &laquo;помощи&raquo; данных из открытого ключа.</argument></command> &ndash; пару чисел <span class="mathjax">$n$</span> и <span class="mathjax">$e$</span>.</li></ol></li><li><b>Шифрование с использованием открытого ключа.</b>
        <ol><li>Сообщение представляют целым числом <span class="mathjax">$m \in [1, n-1]$</span>.</li><li>Шифртекст вычисляется как
                <div class="mathjax" style="text-align: center;">$$ c = m^e \mod n. $$</div>
                Шифртекст &ndash; также целое число из диапазона <span class="mathjax">$[1, n-1]$</span>.</li></ol></li><li><b>Расшифрование с использованием закрытого ключа.</b>

        Владелец закрытого ключа вычисляет
                <div class="mathjax" style="text-align: center;">$$ m = c^d \mod n. $$</div></li></ol><p>Покажем корректность схемы шифрования RSA. В результате расшифрования шифртекста <span class="mathjax">$c$</span> (полученного путём шифрования открытого текста <span class="mathjax">$m$</span>) легальный пользователь имеет:</p><div class="mathjax" style="text-align: center;">$$\begin{array}{ll}
    c^{d} &amp; = m^{ed} \mod p = \\
          &amp; = m^{ 1 + \alpha_1 \cdot \varphi(n)} \mod p = \\
          &amp; = m^{ 1 + \alpha_1 \cdot ( p - 1 ) ( q - 1 )} \mod p = \\
          &amp; = m^{ 1 + \alpha_2 \cdot ( p - 1 )} \mod p = \\
          &amp; = m \cdot m^{\alpha_2 \cdot ( p - 1 )} \mod p. \\
\end{array}$$</div><p>Если <span class="mathjax">$m$</span> и <span class="mathjax">$p$</span> являются взаимно простыми, то из малой теоремы Ферма<a name="N91536"><!--теорема!Ферма малая--></a> следует, что:</p><div class="mathjax" style="text-align: center;">$$m^{\left( p - 1 \right)} = 1 \mod p,$$</div><div class="mathjax" style="text-align: center;">$$\begin{array}{ll}
	c^{d} &amp; = m \cdot m^{\alpha_2 \cdot \left( p - 1 \right)} = \\
	      &amp; = m \cdot \left( m^{\left(p - 1\right)} \right)^{\alpha_2} = \\
	      &amp; = m \cdot 1^{\alpha_2} = \\
	      &amp; = m \mod p.
\end{array}$$</div><p>Если же <span class="mathjax">$m$</span> и <span class="mathjax">$p$</span> не являются взаимно простыми, то есть <span class="mathjax">$p$</span> является делителем <span class="mathjax">$m$</span> (помним, что <span class="mathjax">$p$</span> &ndash; простое число), то <span class="mathjax">$m = 0 \mod p$</span> и <span class="mathjax">$c^{d} = 0 \mod p$</span>.</p><p>В результате, для любых <span class="mathjax">$m$</span> верно, что <span class="mathjax">$c^{d} = m \mod p$</span>. Аналогично доказывается, что <span class="mathjax">$c^{d} = m \mod q$</span>. Из китайской теоремы об остатках<a name="N91578"><!--теорема!китайская об остатках--></a> (см. раздел<span class="nonbreaking-interword-space"> </span><a href="#section-chinese-remainder-theorem">16.5.6</a> в приложении) следует:</p><div class="mathjax" style="text-align: center;">$$\begin{cases}
	n = p \cdot q, \\
	c^{d} = m \mod p, \\
	c^{d} = m \mod q.
\end{cases} \Rightarrow\quad c^{d} = m \mod n.$$</div><p><span style="font-variant: small-caps;"><b>Пример.</b></span> Создание ключей, шифрование и расшифрование в криптосистеме RSA.</p><ol><li>Генерирование параметров.
        <ol><li>Выберем числа <span class="mathjax">$p=13, q=11, n = 143$</span>.</li><li>Вычислим <span class="mathjax">$\varphi(n) = (p-1)(q-1) = 12 \cdot 10 = 120$</span>.</li><li>Выберем <span class="mathjax">$e=23: ~ \gcd(e, \varphi(n))=1, ~ e \in [3, 119]$</span>.</li><li>Найдём <span class="mathjax">$d = e^{-1} \bmod \varphi(n) = 23^{-1} \bmod 120 = 47$</span>.</li><li>Открытый и закрытый ключи:
                <div class="mathjax" style="text-align: center;">$$ {\textrm{PK}}= (e:23, n:143), ~ {\textrm{SK}}= (d:47, n:143). $$</div></li></ol></li><li>Шифрование.
        <ol><li>Пусть сообщение <span class="mathjax">$m = 22 \in [1, n-1]$</span>.</li><li>Вычислим шифртекст:
                <div class="mathjax" style="text-align: center;">$$ c = m^e \bmod n = 22^{23} \bmod 143 = 55 \bmod 143. $$</div></li></ol></li><li>Расшифрование.
        <ol><li>Полученный шифртекст <span class="mathjax">$c = 55$</span>.</li><li>Вычислим открытый текст:
                <div class="mathjax" style="text-align: center;">$$ m = c^d \bmod n = 55^{47} \bmod 143 = 22 \bmod 143. $$</div></li></ol></li></ol><p><a name="N91657"><!--шифр!RSA|)--></a></p><h3 data-command-name="subsection" id="9_1_2_Электронная_подпись">9.1.2. Электронная подпись</h3><p><a name="N91673"><!--электронная подпись!RSA|(--></a>Предположим, что пользователь <span class="mathjax">$A$</span> не шифрует свои сообщения, но хочет посылать их в виде открытых текстов с подписью. Для этого надо создать электронную подпись (ЭП). Это можно сделать, используя систему RSA. При этом должны быть выполнены следующие требования:</p><ul><li>вычисление подписи от сообщения является вычислительно лёгкой задачей;</li><li>фальсификация подписи при неизвестном закрытом ключе &ndash; вычислительно трудная задача;</li><li>подпись должна быть проверяемой открытым ключом.</li></ul><p>Создание параметров ЭП RSA производится так же, как и для схемы шифрования RSA. Пусть <span class="mathjax">$A$</span> имеет закрытый ключ <span class="mathjax">${\textrm{SK}}= (n, d)$</span>, а получатель (проверяющий) <span class="mathjax">$B$</span> &ndash; открытый ключ <span class="mathjax">${\textrm{PK}}= (e,n)$</span> пользователя <span class="mathjax">$A$</span>.</p><ol><li><span class="mathjax">$A$</span> вычисляет подпись сообщения <span class="mathjax">$m \in [1,n-1]$</span> как
        <div class="mathjax" style="text-align: center;">$$ s = m^{d} \mod n $$</div>
        на своём закрытом ключе <span class="mathjax">${\textrm{SK}}$</span>.</li><li><span class="mathjax">$A$</span> посылает <span class="mathjax">$B$</span> сообщение в виде <span class="mathjax">$(m, s)$</span>, где <span class="mathjax">$m$</span> &ndash; открытый текст, <span class="mathjax">$s$</span> &ndash; подпись.</li><li><span class="mathjax">$B$</span> принимает сообщение <span class="mathjax">$(m, s)$</span>, возводит <span class="mathjax">$s$</span> в степень <span class="mathjax">$e$</span> по модулю <span class="mathjax">$n$</span> (<span class="mathjax">$e, n$</span> &ndash; часть открытого ключа). В результате вычислений <span class="mathjax">$B$</span> получает открытый текст:
        <div class="mathjax" style="text-align: center;">$$ s^{e} \mod n = \left( m^{d} \mod n \right)^{e} \mod n = m. $$</div></li><li><span class="mathjax">$B$</span> cравнивает полученное значение с первой частью сообщения. При полном совпадении подпись принимается.</li></ol><p>Недостаток данной системы создания ЭП состоит в том, что подпись <span class="mathjax">$m^{d} \mod n$</span> имеет большую длину, равную длине открытого сообщения <span class="mathjax">$m$</span>.</p><p>Для уменьшения длины подписи применяется другой вариант процедуры: вместо сообщения <span class="mathjax">$m$</span> отправитель подписывает <span class="mathjax">$h(m)$</span>, где <span class="mathjax">$h(x)$</span> &ndash; известная криптографическая хеш-функция. Модифицированная процедура состоит в следующем.</p><ol><li><span class="mathjax">$A$</span> посылает <span class="mathjax">$B$</span> сообщение в виде <span class="mathjax">$(m, s)$</span>, где <span class="mathjax">$m$</span> &ndash; открытый текст,
        <div class="mathjax" style="text-align: center;">$$ s = h(m)^d \mod n $$</div>
        &ndash; подпись.</li><li><span class="mathjax">$B$</span> принимает сообщение <span class="mathjax">$(m, s)$</span>, вычисляет хеш <span class="mathjax">$h(m)$</span> и возводит подпись в степень:
        <div class="mathjax" style="text-align: center;">$$ h_1 = s^e \mod n. $$</div></li><li><span class="mathjax">$B$</span> сравнивает значения <span class="mathjax">$h(m)$</span> и <span class="mathjax">$h_1$</span>. При равенстве
        <div class="mathjax" style="text-align: center;">$$ h(m) = h_1 $$</div>
        подпись считается подлинной, при неравенстве &ndash; фальсифицированной.</li></ol><p><span style="font-variant: small-caps;"><b>Пример.</b></span> Создание и проверка электронной подписи в криптосистеме RSA.</p><ol><li>Генерирование параметров.
        <ol><li>Выберем <span class="mathjax">$p=13, q=17, n = 221$</span>.</li><li>Вычислим <span class="mathjax">$\varphi(n) = (p-1)(q-1) = 12 \cdot 16 = 192$</span>.</li><li>Выберем <span class="mathjax">$e=25: ~ \gcd(e = 25, \varphi(n) = 192) = 1, \\
                e \in [3, \varphi(n) - 1 = 191]$</span>.</li><li>Найдём <span class="mathjax">$d = e^{-1} \mod \varphi(n) = 25^{-1} \mod 192 = 169$</span>.</li><li>Открытый и закрытый ключи:
                <div class="mathjax" style="text-align: center;">$$ {\textrm{PK}}= (e:25, n:221), ~ {\textrm{SK}}= (d:169, n:221). $$</div></li></ol></li><li>Подписание.
        <ol><li>Пусть хеш сообщения <span class="mathjax">$h(m) = 12 \in [1, n-1]$</span>.</li><li>Вычислим ЭП:
                <div class="mathjax" style="text-align: center;">$$ s = h^d = 12^{169} = 90 \mod 221. $$</div></li></ol></li><li>Проверка подписи.
        <ol><li>Пусть хеш полученного сообщения <span class="mathjax">$h(m) = 12$</span>, полученная подпись <span class="mathjax">$s = 90$</span>.</li><li>Выполним проверку:
                <div class="mathjax" style="text-align: center;">$$ h_1 = s^e = 90^{25} = 12 \mod 221, ~~ h_1 = h. $$</div>
                Подпись верна.</li></ol></li></ol><p><a name="N91889"><!--электронная подпись!RSA|)--></a></p><h3 data-command-name="subsection" id="9_1_3_Семантическая_безопасность_шифров">9.1.3. Семантическая безопасность шифров</h3><p><em>Семантически безопасной</em><a name="N91911"><!--криптосистема!семантически-безопасная--></a> называется криптосистема, для которой вычислительно невозможно извлечь любую информацию из шифртекстов, кроме длины шифртекста. Алгоритм RSA не является семантически безопасным. Одинаковые сообщения шифруются одинаково, и, следовательно, применима атака на различение сообщений.</p><p>Кроме того, сообщения длиной менее <span class="mathjax">$\frac{k}{3}$</span> бит, зашифрованные на малой экспоненте <span class="mathjax">$e=3$</span>, <em>дешифруются</em> нелегальным пользователем извлечением обычного кубического корня.</p><p>В приложениях RSA используется только в сочетании с рандомизацией<a name="N91929"><!--рандомизация шифрования--></a>. В стандарте PKCS#1 RSA Laboratories описана схема рандомизации перед шифрованием OAEP-RSA (англ. <span lang="en"><i>Optimal Asymmetric Encryption Padding</i></span>). Примерная схема:</p><ol><li>Выбирается случайное <span class="mathjax">$r$</span>.</li><li>Для открытого текста <span class="mathjax">$m$</span> вычисляется
        <div class="mathjax" style="text-align: center;">$$ x = m \oplus H_1(r), ~ y = r \oplus H_2(x), $$</div>
        где <span class="mathjax">$H_1$</span> и <span class="mathjax">$H_2$</span> &ndash; криптографические хеш-функции.</li><li>Сообщение <span class="mathjax">$M = x ~\|~ y$</span> далее шифруется RSA.</li></ol><p>Восстановление <span class="mathjax">$m$</span> из <span class="mathjax">$M$</span> при расшифровании:</p><div class="mathjax" style="text-align: center;">$$ r = y \oplus H_2(x), ~ m = x \oplus H_1(r). $$</div><p>В модификации OAEP+ <span class="mathjax">$x$</span> вычисляется как</p><div class="mathjax" style="text-align: center;">$$ x = \left( m \oplus H_1 \left( r \right) \right) \Vert \left. H_3 \left( m \Vert r \right) \right. .$$</div><p>В описанной выше схеме ЭП под <span class="mathjax">$m$</span> понимается хеш открытого текста, вместо шифрования выполняется подписание, вместо расшифрования &ndash; проверка подписи.</p><h3 data-command-name="subsection" id="9_1_4_Выбор_параметров_и_оптимизация">9.1.4. Выбор параметров и оптимизация</h3><h4 data-command-name="subsubsection" id="Выбор_экспоненты_e">Выбор экспоненты <span class="mathjax">$e$</span></h4><p>В случайно выбранной экспоненте <span class="mathjax">$e$</span> c битовой длиной <span class="mathjax">$k = \lceil \log_2 e \rceil$</span> одна половина битов в среднем равна 0, другая &ndash; 1. При возведении в степень <span class="mathjax">$m^e \mod n$</span> по методу &laquo;возводи в квадрат и перемножай&raquo; получится <span class="mathjax">$k-1$</span> возведений в квадрат и в среднем
 <span class="mathjax">$\frac{1}{2}(k-1)$</span> умножений.</p><p>Если выбрать <span class="mathjax">$e$</span>, содержащую малое число единиц в двоичной записи, то число умножений уменьшится до числа единиц в <span class="mathjax">$e$</span>.</p><p>Часто экспонента <span class="mathjax">$e$</span> выбирается <em>малым</em> <em>простым</em> числом и/или содержащим малое число единиц в битовой записи для ускорения шифрования или проверки подписи, например:</p><div class="mathjax" style="text-align: center;">$$
    \begin{array}{l}
        3 = [11]_2, \\
        17 = 2^4+1 = [10001]_2, \\
        257 = 2^8+1 = [100000001]_2, \\
        65537 = 2^{16}+1 = [10000000000000001]_2.
    \end{array}
$$</div><!--%Время шифрования или проверки подписи для малых экспонент становится $O(k^2)$ вместо $O(k^3)$, то есть в сотни раз быстрее для 1000-битовых чисел.--><h4 data-command-name="subsubsection" id="Ускорение_шифрования_по_китайской_теореме_об_остатках">Ускорение<span class="nonbreaking-interword-space"> </span>шифрования по<span class="nonbreaking-interword-space"> </span>китайской<span class="nonbreaking-interword-space"> </span>теореме об<span class="nonbreaking-interword-space"> </span>остатках</h4><p>Возводя <span class="mathjax">$m$</span> в степень <span class="mathjax">$e$</span> отдельно по <span class="mathjax">${\operatorname{mod}}p$</span> и <span class="mathjax">${\operatorname{mod}}q$</span> и применяя китайскую теорему об остатках<a name="N92080"><!--теорема!китайская об остатках--></a> (англ. <span lang="en"><i>Chinese remainder theorem, CRT</i></span>), можно быстрее выполнить шифрование.</p><p>Однако ускорение шифрования в криптосистеме RSA через CRT может породить уязвимости в отдельных реализациях, например в реализациях для смарт-карт.</p><p><span style="font-variant: small-caps;"><b>Пример.</b></span> 
Пусть <span class="mathjax">$c = m^e \mod n$</span> передаётся на расшифрование на смарт-карту, где вычисляется</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{c}
    m_p = c^d \mod p, \\
    m_q = c^d \mod q, \\
    m = m_p q (q^{-1} \bmod p) + m_q p (p^{-1} \bmod q) \mod n. \\
\end{array} $$</div><p>Криптоаналитик внешним воздействием может вызвать сбой во время вычисления <span class="mathjax">$m_p$</span> (или <span class="mathjax">$m_q$</span>), в результате получится <span class="mathjax">$m_p'$</span> и <span class="mathjax">$m'$</span> вместо <span class="mathjax">$m$</span>. Зная <span class="mathjax">$m_p'$</span> и <span class="mathjax">$m'$</span>, криптоаналитик находит разложение числа <span class="mathjax">$n$</span> на множители <span class="mathjax">$p,q$</span>:</p><div class="mathjax" style="text-align: center;">$$ \gcd(m' - m, ~ n) = \gcd( (m_p' - m) q (q^{-1} \bmod p), ~ pq) = q. $$</div><h4 data-command-name="subsubsection" id="Длина_ключей">Длина ключей</h4><p>В 2005 году было разложено 663-битовое число вида RSA. Время разложения в эквиваленте составило 75 лет вычислений одного ПК. Самые быстрые алгоритмы факторизации &ndash; субэкспоненциальные<a name="N92152"><!--задача!факторизации--></a>. Минимальная рекомендуемая длина модуля <span class="mathjax">$n$</span> = 1024 бита, но лучше использовать 2048 или 4096 бит.</p><p>В июле 2012 года NIST опубликовала отчёт<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#NIST:SP800:57">[88]</a>, который включал в себя таблицу сравнения надёжности ключей разных длин для криптосистем, относящихся к разным классам. Таблица была составлена согласно как известным на тот момент атакам на классы криптосистем, так и на конкретные шифры (см. таблицу<span class="nonbreaking-interword-space"> </span><a href="#table:aesrsakeycompare">[table:aesrsakeycompare]</a>).</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><table style="border-collapse: collapse;"><colgroup><col style="border-left: solid thin;border-right: solid thin;"><col style="border-left: solid thin;border-right: solid thin;"><col style="border-left: solid thin;border-right: solid thin;"><col style="border-left: solid thin;border-right: solid thin;"></colgroup><tr style="border-bottom: solid thin;border-top: solid thin;"><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">бит безопасности</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">пример симметричного шифра</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;"><span class="mathjax">$\log_2 n$</span> для RSA<command name="tablefootnote"><argument required="true">Сравнимая по предоставляемой безопасности битовая длина произведения <span class="mathjax">$n$</span> простых чисел <span class="mathjax">$p$</span> и <span class="mathjax">$q$</span> для криптосистем, основанных на сложности задачи разложения числа <span class="mathjax">$n$</span> на простые множители <span class="mathjax">$p$</span> и <span class="mathjax">$q$</span>, в том числе RSA.</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;"><span class="mathjax">$\log_2 \| {\mathbb{G}} \|$</span> для эллиптических кривых<command name="tablefootnote"><argument required="true">Сравнимая по предоставляемой безопасности битовая длина количества элементов <span class="mathjax">$\|{\mathbb{G}}\|$</span> в выбранной циклической подгруппе <span class="mathjax">${\mathbb{G}}$</span> группы точек <span class="mathjax">${\mathbb{E}}$</span> эллиптической кривой для криптосистем, основанных на сложности дискретного логарифма в группах точек эллиптических кривых над конечными полями (см.<span class="nonbreaking-interword-space"> </span><a href="#section-elliptic-curve-cryptosystems">9.3</a>).</argument></command></td></tr><tr style="border-top: solid thin;"><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">80</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">2TDEA</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">1024</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">160--223</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">112</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">3TDEA</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">2048</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">224--255</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">128</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">AES-128</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">3072</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">256--383</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">192</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">AES-192</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">7680</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">384--511</td></tr><tr style="border-bottom: solid thin;"><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">256</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">AES-256</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">15360</td><td style="padding-left: 6pt;padding-right: 6pt;white-space: nowrap;">512+</td></tr></table><figcaption style="flex-basis: 100%; text-align: center;">Таблица 9.1 &mdash; Сравнимые длины ключей блочных симметричных шифров и ключевых параметров асимметричных шифров<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#NIST:SP800:57">[88]</a></figcaption></figure><p>В приложении<span class="nonbreaking-interword-space"> </span><a href="#section-modular-arithmetic">16.5</a> показано, что битовая сложность (количество битовых операций) вычисления произвольной степени <span class="mathjax">$a^b \mod n$</span> является кубической <span class="mathjax">$O(k^3)$</span>, а возведения в квадрат <span class="mathjax">$a^2 \mod n$</span> и умножения <span class="mathjax">$a b \mod n$</span> &ndash; квадратичной <span class="mathjax">$O(k^2)$</span>, где <span class="mathjax">$k$</span> &ndash; битовая длина чисел <span class="mathjax">$a,b,n$</span>.</p><!--%Увеличение длины модуля $n$ в 2 раза увеличивает время возведения в степень в $2^3$ раз для большой экспоненты $e$, а для маленькой экспоненты - - в $2^2$ раза.--><p><a name="N92358"><!--криптосистема!RSA|)--></a></p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="Glava_9_Asimmetrichnie_kriptosistemi.html">&#129080; Glava_9_Asimmetrichnie_kriptosistemi</a></li><li class="page-item"><a class="page-link" href="9_2_Kriptosistema_El_Gamalja.html">9_2_Kriptosistema_El_Gamalja &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>