<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h1 data-command-name="chapter" id="Глава_8_Криптографические_хеш_функции" lang="ru">Глава 8. Криптографические хеш-функции</h1><p>Хеш-функции возникли как один из вариантов решения задачи &laquo;поиска по словарю&raquo;. Задача состояла в поиске в памяти компьютера (оперативной или постоянной) информации по известному ключу. Возможным способом решения было хранение, например, всего массива ключей (и указателей на содержимое) в отсортированном в некотором порядке списке или в виде бинарного дерева. Однако наиболее производительным с точки зрения времени доступа (при этом обладая допустимой производительностью по времени модификации) стал метод хранения в виде хеш-таблиц. Этот метод ведёт своё происхождение из стен компании IBM (как и многое другое в программировании).</p><p>Метод хеш-таблиц подробно разобран в любой современной литературе по программированию<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Knuth:2001:3">[125]</a>. Напомним лишь, что его идея состоит в разделении множества ключей по корзинам (англ. <span lang="en"><i>bins</i></span>) в зависимости от значения некоторой функции, вычисляемой по значению ключа. Причём функция подбирается таким образом, чтобы в разных корзинах оказалось одинаковое число (в идеале &ndash; не более одного) ключей. При этом сама функция должна быть быстро вычисляемой, а её значение должно легко конвертироваться в натуральное число, которое не превышает число корзин.</p><p><em>Хеш-функцией</em> (англ. <span lang="en"><i>hash function</i></span>) называется отображение, переводящее аргумент произвольной длины в значение фиксированной длины.</p><p><em>Коллизией</em> хеш-функции называется пара значений аргумента, дающая одинаковый выход хеш-функции. Коллизии есть у любых хеш-функций, если количество различных значений аргумента превышает возможное количество значений результата функции (принцип Дирихле). А если не превышает, то и нет смысла использовать хеш-функцию.</p><p>В программировании к свойствам хорошей хеш-функции относят:</p><ul><li>быструю скорость работы;</li><li>минимальное число коллизий.</li></ul><p>Можно назвать и другие свойства, которые были бы полезны для хеш-функции в программировании. К ним можно отнести, например, отсутствие необходимости в дополнительной памяти (неиспользование &laquo;кучи&raquo;), простоту реализации, стабильность работы алгоритма (возврат одного и того же результата после перезапуска программы), соответствие результатов работы хеш-функции результатам работы других функций, например, функций сравнения (см. например, описания функций <tt>hashcode()</tt>, <tt>equals()</tt> и <tt>compare()</tt> в языке программирования Java).</p><p><em>Однонаправленной функцией</em><a name="N88004"><!--функция!однонаправленная--></a> <span class="mathjax">$f(x)$</span> называется функция, обладающая следующими свойствами:</p><ul><li>вычисление значения функции <span class="mathjax">$f(x)$</span> для всех значений аргумента <span class="mathjax">$x$</span> является <em>вычислительно лёгкой</em> задачей;</li><li>нахождение аргумента <span class="mathjax">$x$</span>, соответствующего значению функции <span class="mathjax">$f(x)$</span>, является <em>вычислительно трудной</em> задачей.</li></ul><p>Свойство однонаправленности, в частности, означает, что если в аргументе <span class="mathjax">$x$</span> меняется хотя бы один символ, то для любого <span class="mathjax">$x$</span> значение функции <span class="mathjax">$H(x)$</span> меняется непредсказуемо.</p><p><em>Криптографически стойкой хеш-функцией</em> <span class="mathjax">$H(x)$</span> называется хеш-функция, имеющая следующие свойства:</p><ul><li>однонаправленность: <em>вычислительно невозможно</em> по значению функции найти прообраз;</li><li><em>слабая устойчивость к коллизиям</em><a name="N88076"><!--устойчивость к коллизиям--></a> (слабо бесконфликтная функция): для заданного аргумента <span class="mathjax">$x$</span> <em>вычислительно невозможно</em> найти другой аргумент <span class="mathjax">$y \neq x: ~ H(x) = H(y)$</span>;</li><li><em>сильная устойчивость к коллизиям</em> (сильно бесконфликтная функция): <em>вычислительно невозможно</em> найти пару разных аргументов <span class="mathjax">$x \neq y: ~ H(x) = H(y)$</span>.</li></ul><p>Из требования на устойчивость к коллизиям, в частности, следует свойство (близости к) равномерности распределения результата криптографической хеш-функции по области значений. В целом надёжную криптографическую хеш-функ<wbr></wbr>цию можно считать реализацией <em>класса псевдослучайных функций</em> (PRF), то есть <em>случайным оракулом</em><a name="N88124"><!--оракул!случайный--></a>.</p><p>При произвольной длине последовательности <span class="mathjax">$X$</span> длина хеш-функции <span class="mathjax">$H(X)$</span> в российском стандарте ГОСТ Р 34.11-94 равна 256 символам, в американском стандарте SHA несколько различных значений длин: 160, 192, 256, 512 символов.</p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="7_1_Shifr_RC4.html">&#129080; 7_1_Shifr_RC4</a></li><li class="page-item"><a class="page-link" href="8_1_Struktura_Merkla.html">8_1_Struktura_Merkla &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>