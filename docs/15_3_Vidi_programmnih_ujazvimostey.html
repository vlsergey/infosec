<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="15_3_Виды_программных_уязвимостей">15.3. Виды программных уязвимостей</h2><p><em>Вирусом</em> называется самовоспроизводящаяся часть кода (подпрограмма)<a name="N111161"><!--вирус--></a>, которая встраивается в носители (другие программы) для своего исполнения и распространения. Вирус не может исполняться и передаваться без своего носителя.</p><p><em>Червём</em> называется самовоспроизводящаяся отдельная (под-)про<wbr></wbr>грам<wbr></wbr>ма<a name="N111177"><!--червь--></a>, которая может исполняться и распространяться самостоятельно, не используя программу-носитель.</p><p>Первой вехой в изучении компьютерных вирусов можно назвать 1949 год, когда Джон фон Нейман прочёл курс лекций в Университете Иллинойса под названием &laquo;Теория самовоспроизводящихся машин&raquo; (изданы в 1966<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Neumann:1966">[80]</a>, переведены на русский язык издательством &laquo;Мир&raquo; в 1971 году<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Neumann:1971">[129]</a>), в котором ввёл понятие самовоспроизводящихся механических машин. Первым сетевым вирусом считается вирус Creeper 1971 г., распространявшийся в сети ARPANET, предшественнице Интернета. Для его уничтожения был создан первый антивирус Reaper, который находил и уничтожал Creeper.</p><p>Первый червь для Интернета, червь Морриса, 1988 г., уже использовал <em>смешанные</em> атаки<a name="N111199"><!--атака!смешанная--></a> для заражения UNIX машин<span class="nonbreaking-interword-space"> </span>[<a href="Literatura.html#EichinRochlis:1988">34</a>, <a href="Literatura.html#Spafford:1989">99</a>]. Сначала программа получала доступ к удалённому запуску команд, эксплуатируя уязвимости в сервисах <tt>sendmail</tt>, <tt>finger</tt> (с использованием атаки на переполнение буфера) или <tt>rsh</tt>. Далее, с помощью механизма подбора паролей червь получал доступ к локальным аккаунтам пользователей:</p><ul><li>получение доступа к учётным записям с простыми паролями:
		<ul><li>без пароля вообще;</li><li>имя аккаунта в качестве пароля;</li><li>имя аккаунта в качестве пароля, повторённое дважды;</li><li>использование &laquo;ника&raquo; (англ. <span lang="en"><i>nickname</i></span>);</li><li>фамилия (англ. <span lang="en"><i>last name, family name</i></span>);</li><li>фамилия, записанная задом наперёд;</li></ul></li><li>перебор паролей на основе встроенного словаря из 432 слов;</li><li>перебор на основе системного словаря <tt>/usr/dict/words</tt>.</li></ul><p><em>Программной уязвимостью</em><a name="N111288"><!--программная уязвимость--></a> называется свойство программы, позволяющее нарушить её работу. Программные уязвимости могут приводить к отказу в обслуживании (Denial of Service, DoS-атака)<a name="N111294"><!--атака!отказ в обслуживании--></a>, утечке и изменению данных, появлению и распространению вирусов и червей.</p><p>Одной из распространённых атак для заражения персональных компьютеров является переполнение буфера в стеке. В интернет-сервисах наиболее распространённой программной уязвимостью в настоящее время является межсайтовый скриптинг (Cross-Site Scripting, XSS-атака)<a name="N111300"><!--атака!XSS--></a>.</p><p>Наиболее распространённые программные уязвимости можно разделить на классы:</p><ol><li>Переполнение буфера &ndash; копирование в буфер данных большего размера, чем длина выделенного буфера. Буфером может быть контейнер текстовой строки, массив, динамически выделяемая память и<span class="nonbreaking-interword-space"> </span>т.&nbsp;д. Переполнение становится возможным вследствие либо отсутствия контроля над длиной копируемых данных, либо из-за ошибок в коде. Типичная ошибка &ndash; разница в 1 байт между размерами буфера и данных при сравнении.</li><li>Некорректная обработка (парсинг) данных, введённых пользователем, является причиной большинства программных уязвимостей в веб-приложениях. Под обработкой понимаются:
        <ol><li>проверка на допустимые значения и тип (числовые поля не должны содержать строки и<span class="nonbreaking-interword-space"> </span>т.&nbsp;д.);</li><li>фильтрация и экранирование специальных символов, имеющих значения в скриптовых языках или применяющихся для перекодирования из одной текстовой кодировки в другую. Примеры символов: <tt><command name="textbackslash"></command></tt>, <tt></tt>, <tt></tt>, <tt></tt>, <tt>"</tt>, <tt>'</tt>;</li><li>фильтрация ключевых слов языков разметки и скриптов. Примеры: <tt>script</tt>, <tt>JavaScript</tt>;</li><li>перекодирование различными кодировками при парсинге. Распространённый способ обхода системы контроля парсинга данных состоит в однократном или множественном последовательном кодировании текстовых данных в шестнадцатеричные кодировки <tt></tt>NN ASCII и UTF-8. Например, браузер или веб-приложения производят <span class="mathjax">$n$</span>-кратное перекодирование, в то время как система контроля делает <span class="mathjax">$k$</span>-кратное перекодирование, <span class="mathjax">$0 \leq k &lt; n$</span>, и, следовательно, пропускает закодированные запрещённые символы и слова.</li></ol></li><li>Некорректное использование функций. Например, <tt>printf(s)</tt> может привести к уязвимости записи в память по указанному адресу. Если злоумышленник вместо обычной текстовой строки введёт в качестве <tt></tt>s "текст некоторой длиныn", то функция <tt>printf</tt>, ожидающая первым аргументом строку формата <tt>fmt</tt>, обнаружив <tt></tt>n, возьмёт значение из ячеек памяти, находящихся перед ячейками с указателем на текстовую строку (устройство стека описано далее), и запишет в память по адресу, равному считанному значению, количество выведенных символов на печать функцией <tt>printf</tt>.</li></ol><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="15_2_Kontrol_dostupa_v_OS.html">&#129080; 15_2_Kontrol_dostupa_v_OS</a></li><li class="page-item"><a class="page-link" href="15_4_Perepolnenie_bufera_v_steke.html">15_4_Perepolnenie_bufera_v_steke &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>