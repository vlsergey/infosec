<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h1 data-command-name="chapter" id="Глава_5_Блочные_шифры" lang="ru">Глава 5. Блочные шифры</h1><p><a name="N81702"><!--шифр!блочный|(--></a></p><h2 data-command-name="section" id="5_1_Введение_и_классификация">5.1. Введение и классификация</h2><p>Блочные шифры являются основой современной криптографии. Многие криптографические примитивы &ndash; криптографически стойкие генераторы псевдослучайной последовательности (см. главу<span class="nonbreaking-interword-space"> </span><a href="#section-crypto-random">6.3</a>), криптографические функции хеширования (см. главу<span class="nonbreaking-interword-space"> </span><a href="#chapter-hash-functions">8</a>) &ndash; так или иначе основаны на блочных шифрах. А использование медленной криптографии с открытым ключом было бы невозможно по практическим соображениям без быстрых блочных шифров.</p><p>Блочные шифры можно рассматривать как функцию преобразования строки фиксированной длины в строку аналогичной длины</p><command name="footnote"><argument required="true">В случае использования недетерминированных алгоритмов, дающих новый результат при каждом шифровании, длина выхода будет больше. Меньше длина выхода быть не может, так как будет невозможно однозначно восстановить произвольное сообщение.</argument></command><p>с использованием некоторого ключа, а также соответствующую ей функцию расшифрования:</p><div class="mathjax" style="text-align: center;">$$\begin{array}{l}
	C = E_K\left( M \right), \\
	M'= D_K\left( C \right).
\end{array}$$</div><p>Данные функции необходимо дополнить требованиями корректности, производительности и надёжности. Во-первых, функция расшифрования должна однозначно восстанавливать произвольное исходное сообщение:</p><div class="mathjax" style="text-align: center;">$$ \forall k \in {\mathbb{K}}, m \in {\mathbb{M}} \hookrightarrow D_k \left( E_k\left( m \right) \right) = m. $$</div><p>Во-вторых, функции шифрования и расшифрования должны быть вычислительно простыми для легальных пользователей (знающих ключ). В-третьих, должно быть невозможно найти открытый текст сообщения по шифртексту без знания ключа, кроме как полным перебором всех возможных ключей расшифрования. Также, что менее очевидно, надёжная функция блочного шифра не должна давать возможность найти ключ шифрования (расшифрования), даже если злоумышленнику известны пары открытого текста и шифртекста. Последнее свойство защищает от атак на основе известного открытого текста<a name="N81750"><!--атака!с известным открытым текстом--></a> и на основе известного шифртекста<a name="N81756"><!--атака!с известным шифртекстом--></a>, а также активно используется при построении криптографических функций хеширования в конструкции Миагучи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Пренеля<a name="N81766"><!--конструкция!Миагучи—Пренеля--></a>. То есть:</p><ul><li><span class="mathjax">$C = f \left( M, K \right)$</span> и <span class="mathjax">$M = f \left( C, K \right)$</span> должны вычисляться быстро (легальные операции);</li><li><span class="mathjax">$M = f \left( C \right)$</span> и <span class="mathjax">$C = f \left( M \right)$</span> должны вычисляться не быстрее, чем <span class="mathjax">$\left| {\mathbb{K}} \right|$</span> операций расшифрования (шифрования) при условии, что злоумышленник может отличить корректное сообщение (см. выводы к разделу<span class="nonbreaking-interword-space"> </span><a href="#section_unicity_distance">4.4</a>);</li><li><span class="mathjax">$K = f \left( M, C \right)$</span> должно вычисляться не быстрее, чем <span class="mathjax">$\left| {\mathbb{K}} \right|$</span> операций шифрования.</li></ul><p>Если размер ключа достаточно большой (от 128 бит и выше), то функцию блочного шифрования, удовлетворяющую указанным выше условиям, можно называть надёжной.</p><p>Блочные шифры делят на два больших класса по методу построения.</p><ul><li>Шифры, построенные на SP-сетях (англ. <span lang="en"><i>Substitution-Per<wbr></wbr>mu<wbr></wbr>ta<wbr></wbr>tion network, SP network</i></span>, подстановочно-перестановочная сеть). Такие шифры основаны на <em>обратимых</em> преобразованиях с открытым текстом. При их разработке криптограф должен следить за тем, чтобы каждая из производимых операций была и криптографически надёжна, и обратима при знании ключа.</li><li>Шифры, в той или иной степени построенные на ячейке Фейстеля<a name="N81839"><!--ячейка Фейстеля--></a>. В данных шифрах используется конструкция под названием &laquo;ячейка Фейстеля&raquo;, которая по методу построения уже обеспечивает обратимость операции шифрования легальным пользователем при знании ключа. Криптографу при разработке функции шифрования остаётся сосредоточиться на надёжности конструкции.</li></ul><p>Все современные блочные шифры являются <em>раундовыми</em> (см. рис.<span class="nonbreaking-interword-space"> </span><a href="Glava_5_Blochnie_shifri.html#fig:block-cipher">5.1</a>). То есть блок текста проходит через несколько одинаковых (или похожих) преобразований, называемых <em>раундами шифрования</em>. У<span class="nonbreaking-interword-space"> </span>функции шифрования также могут существовать начальный и завершающий раунды, отличающиеся от остальных (обычно &ndash; отсутствием некоторых преобразований, которые не имеют смысла для &laquo;крайних&raquo; раундов).</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:block-cipher" style="vertical-align: top; align-self: start;"></a><img src="images/B1B8148428D0D967EE7DE470A18FE3E6.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.1 &mdash; Общая структура раундового блочного шифра. С помощью функции ключевого расписания из ключа <span class="mathjax">$K$</span> получается набор раундовых ключей <span class="mathjax">$K1, K2, \dots$</span>. Открытый текст <span class="mathjax">$M$</span> разбивается на блоки <span class="mathjax">$M1, M2, \dots$</span>, каждый из которых проходит несколько раундов шифрования, используя соответствующие раундовые ключи. Результаты последних раундов шифрования каждого из блоков объединяются в шифртекст <span class="mathjax">$C$</span> с помощью одного из режимов сцепления блоков</figcaption></figure><p>Аргументами каждого раунда являются результаты предыдущего раунда (для первого &ndash; часть открытого текста) и <em>раундовый ключ</em><a name="N81916"><!--ключ!раундовый--></a>. Раундовые ключи получаются из оригинального ключа шифрования с помощью процедуры, получившей название алгоритма <em>ключевого расписания</em><a name="N81927"><!--ключевое расписание--></a> (также встречаются названия &laquo;расписание ключей&raquo;, &laquo;процедура расширения ключа&raquo; и<span class="nonbreaking-interword-space"> </span>др.; англ. <span lang="en"><i>key schedule</i></span>). Функция ключевого расписания является важной частью блочного шифра. На потенциальной слабости этой функции основаны такие криптографические атаки, как атака на основе связанных ключей<a name="N81948"><!--атака!на связанных ключах--></a> и атака скольжения<a name="N81954"><!--атака!скольжения--></a>.</p><p>После прохождения всех раундов шифрования блоки <span class="mathjax">$C1$</span>, <span class="mathjax">$C2$</span>,<span class="nonbreaking-interword-space"> </span><span class="mathjax">$\dots$</span> объединяются в шифртекст <span class="mathjax">$C$</span> с помощью одного из режимов сцепления блоков (см. раздел<span class="nonbreaking-interword-space"> </span><a href="#section-block-chaining">5.8</a>). Простейшим примером режима сцепления блоков является режим электронной кодовой книги<a name="N81980"><!--режим!электронной кодовой книги--></a>, когда блоки <span class="mathjax">$C1$</span>, <span class="mathjax">$C2$</span>,<span class="nonbreaking-interword-space"> </span><span class="mathjax">$\dots$</span> просто конкатенируются в шифртекст <span class="mathjax">$C$</span> без дополнительной обработки.</p><p>К числовым характеристикам блочного шифра относят:</p><ul><li>размер входного и выходного блоков,</li><li>размер ключа шифрования,</li><li>количество раундов.</li></ul><p>Также надёжные блочные шифры обладают <em>лавинным эффектом</em><a name="N82012"><!--лавинный эффект--></a> (англ. <span lang="en"><i>avalanche effect</i></span>): изменение одного бита в блоке открытого текста или ключа приводит к полному изменению соответствующего блока шифртекста.</p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="4_4_Rasstojanie_edinstvennosti.html">&#129080; 4_4_Rasstojanie_edinstvennosti</a></li><li class="page-item"><a class="page-link" href="5_2_SP_seti_Proekt_Ljutsifer_.html">5_2_SP_seti_Proekt_Ljutsifer_ &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>