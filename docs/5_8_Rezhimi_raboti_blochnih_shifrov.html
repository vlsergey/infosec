<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="5_8_Режимы_работы_блочных_шифров">5.8. Режимы работы блочных шифров</h2><p>Перед шифрованием открытый текст <span class="mathjax">$M$</span> разбивают на части <span class="mathjax">$M_1, M_2, \dots, M_n$</span>, называемые <em>блоками шифрования</em><a name="N84047"><!--блок!шифрования--></a>. Размер блока зависит от используемого блочного шифра, и, как упоминалось ранее, для шифра &laquo;Магма&raquo;<a name="N84053"><!--шифр!Магма--></a> он составляет 64 бита, для AES<a name="N84059"><!--шифр!AES--></a> и шифра &laquo;Кузнечик&raquo;<a name="N84065"><!--шифр!Кузнечик--></a> &ndash; 128 бит.</p><div class="mathjax" style="text-align: center;">$$ M = M_1 || M_2 || \dots || M_i. $$</div><p>Размер открытого текста может быть не кратен размеру блока шифрования. В этом случае для последнего блока применяют процедуру дополнения (удлинения) до стандартного размера. Процедура должна быть обратимой: после расшифрования последнего блока пакета лишние байты необходимо обнаружить и удалить. Некоторые способы дополнения:</p><ul><li>добавить один байт со значением <span class="mathjax">$128$</span>, а остальные байты принять за нулевые;</li><li>определить, сколько байтов надо добавить к последнему блоку, например <span class="mathjax">$b$</span>, и добавить <span class="mathjax">$b$</span> байтов со значением <span class="mathjax">$b$</span> в каждом.</li></ul><p>После шифрования всех блоков открытого текста (блоков шифрования) получается набор блоков шифртекста <span class="mathjax">$C_1, C_2, C_3, \dots, C_n$</span>. Обычно размер этих блоков равен размеру блока шифрования (точно не может быть меньше блока шифрования). Процедура, по которой этот из этого набора блоков получается итоговый шифртекст, называется режимом работы блочного шифра. Некоторые режимы работы могут оперировать не только блоками шифртекста, но и исходными блоками шифрования, номерами блоков и специальными векторами инициализации.</p><p>Существует несколько режимов работы блочных шифров: режим электронной кодовой книги, режим шифрования зацепленных блоков, режим обратной связи, режим шифрованной обратной связи, режим счётчика. Рассмотрим особенности каждого из этих режимов.</p><h3 data-command-name="subsection" id="5_8_1_Электронная_кодовая_книга">5.8.1. Электронная кодовая книга</h3><p>В стандарте ГОСТ 28147-89 данный режим называется <em>режимом простой замены</em>.<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#GOST-89">[131]</a>В режиме электронной кодовой книги (англ. <span lang="en"><i>Electronic Code Book, ECB</i></span>, рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:ECB">5.12</a>) открытый текст в пакете разделён на блоки</p><div class="mathjax" style="text-align: center;">$$ \left[ M_1, M_2, \dots, M_{n-1}, M_n \right]. $$</div><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:ECB" style="vertical-align: top; align-self: start;"></a><img src="images/0347B8C6A580A26B387A0E4A219EEAB1.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.12 &mdash; Режим электронной кодовой книги</figcaption></figure><p>В процессе шифрования каждому блоку <span class="mathjax">$M_j$</span> ставится в соответствие шифртекст <span class="mathjax">$C_j$</span>, определяемый с помощью ключа <span class="mathjax">$K$</span>:</p><div class="mathjax" style="text-align: center;">$$ C_j = E_K(M_j), ~ j = 1, 2, \dots, n. $$</div><p>Если в открытом тексте есть одинаковые блоки, то в шифрованном тексте им также соответствуют одинаковые блоки. Это даёт дополнительную информацию для криптоаналитика, что является недостатком этого режима. Другой недостаток состоит в том, что криптоаналитик может подслушивать, перехватывать, переставлять, воспроизводить ранее записанные блоки, нарушая конфиденциальность<a name="N84186"><!--конфиденциальность--></a> и целостность<a name="N84192"><!--целостность--></a> информации. Поэтому при работе в режиме электронной кодовой книги нужно вводить аутентификацию сообщений.</p><p>Шифрование в режиме электронной кодовой книги не использует сцепление блоков и синхропосылку<a name="N84198"><!--синхропосылка--></a> (вектор инициализации)<a name="N84204"><!--вектор инициализации--></a>. Поэтому для данного режима применима атака на различение сообщений, так как два одинаковых блока или два одинаковых открытых текста шифруются идентично.</p><p>На рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:ecb-demo">5.13</a> приведён пример шифрования графического файла морской звезды в формате BMP, 24 бита цветности на пиксель (рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:starfish">5.13a</a>), блочным шифром AES с длиной ключа 128 бит в режиме электронной кодовой книги (рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:starfish-aes-128-ecb">5.13b</a>). В начале зашифрованного файла был восстановлен стандартный заголовок формата BMP. Как видно, в зашифрованном файле изображение всё равно различимо.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:ecb-demo" style="vertical-align: top; align-self: start;"></a><figure style="margin-left: 0; margin-right: 0; width: 45%;"><a name="fig:starfish" style="vertical-align: top; align-self: start;"></a><img src="images/A7EDB004BF9331D9DEAE25987E2D4E0E.png" style="width: 100%"><figcaption>(a) Исходный рисунок</figcaption></figure><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><figure style="margin-left: 0; margin-right: 0; width: 45%;"><a name="fig:starfish-aes-128-ecb" style="vertical-align: top; align-self: start;"></a><img src="images/69D612A0C4DCAE8A103934C89864FF0F.png" style="width: 100%"><figcaption>(b) Зашифрованный AES рисунок</figcaption></figure><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.13 &mdash; Шифрование в режиме электронной кодовой книги</figcaption></figure><p>BMP файл в данном случае содержит в самом начале стандартный заголовок (ширина, высота, количество цветов), и далее идёт массив 24-битовых значений цвета пикселей, взятых построчно сверху вниз. В массиве много последовательностей нулевых байтов, так как пиксели белого фона кодируются 3 нулевыми байтами. В AES размер блока равен 16 байтам, и, значит, каждые <span class="mathjax">$\frac{16}{3}$</span> подряд идущих пикселей белого фона шифруются одинаково, позволяя различить изображение в зашифрованном файле.</p><!--%На рис.~\ref{fig:ecb-demo} приведён пример шифрования графического файла логотипа Википедии в формате BMP, 24 бита цветности на пиксель (рис.~\ref{fig:wikilogo}), блочным шифром AES с длиной ключа 128 бит в режиме электронной кодовой книги (рис.~\ref{fig:wikilogo-aes-128-ecb}). В начале зашифрованного файла был восстановлен стандартный заголовок BMP формата. Как видно, на зашифрованном рисунке возможно даже прочитать надпись.--><!--%\begin{figure}[!ht]--><!--%    \centering--><!--%    \subfloat[Исходный рисунок]{\label{fig:wikilogo}\includegraphics[width=0.45\textwidth]{pic/wikilogo}}--><!--%    ~~~--><!--%    \subfloat[Рисунок, зашифрованный AES-128]{\label{fig:wikilogo-aes-128-ecb}\includegraphics[width=0.45\textwidth]{pic/wikilogo-aes-128-ecb}}--><!--%    \caption{Шифрование в режиме электронной кодовой книги.}--><!--%    \label{fig:ecb-demo}--><!--%\end{figure}--><!--%Возможно воссоздание структуры информации - - например, пингвин на рис.~\ref{fig:tux-ecbmode}. Картинка с пингвином записана в формате BMP и зашифрована DES в режиме электронной кодовой книги.--><!--%\begin{figure}[!ht]--><!--%    \centering--><!--%    \includegraphics[width=0.3\textwidth]{pic/tux-ecb}--><!--%    \caption{Картинка с пингвином, зашифрованная в режиме электронной кодовой книги.}--><!--%    \label{fig:tux-ecbmode}--><!--%\end{figure}--><p>Преимущества:</p><ul><li>самый простой в реализации режим работы шифра (&laquo;наивный&raquo;);</li><li>возможность параллельного шифрования любого количества блоков открытого текста.</li></ul><p>Недостатки:</p><ul><li>необходимость дополнения открытого текста до размера, кратного размеру блоку шифрования;</li><li>сохранение статистических особенностей открытого текста на уровне блоков шифртекста;</li><li>ошибка передачи одного бита приводит к ошибке расшифровки целого блока открытого текста;</li><li>не обеспечивает целостность.</li></ul><p>Основным минусом режима является сохранение статистических особенностей открытого текста на уровне шифртекста (одинаковые блоки шифруются одинаково). Причём это поведение сохраняется и между сессиями, что позволяет злоумышленнику, используя информацию из сторонних каналов (например, зная о предпринятых действиях получателя сообщения), составить словарь между переданными блоками шифртекста и предполагаемыми &ndash; открытого текста. То есть злоумышленник может попытаться восстановить соответствующую <em>кодовую книгу</em> для данного ключа шифрования и потом восстанавливать сообщения по этой книге без знания ключа шифрования<a name="N84333"><!--ключ!шифрования--></a>.</p><p>Когда говорят про восстановление после ошибок передачи, то рассматривают ситуацию, в которой один или несколько бит одного блока шифртекста поменяли</p><command name="footnote"><argument required="true">В отдельных продвинутых режимах работы блочных шифров рассматривают также варианты потери бит или вставки новых ошибочных, что приводит к изменению размеров переданных блоков и требует дополнительной работы по синхронизации</argument></command><p>своё значение в процессе передачи по каналу связи между отправителем (тем, кто шифрует) и получателем (тем, кто расшифровывает). В режиме ECB изменение даже одного бита переданного блока шифртекста приведёт к тому, что весь блок открытого текста будет расшифрован неверно.</p><command name="footnote"><argument required="true">См.<span class="nonbreaking-interword-space"> </span><command name="autoref"><argument required="true">section:avalanche_effect</argument></command></argument></command><p>То есть вместо блока открытого текста получится 64 или 128 бит мусора (случайных бит). Однако все последующие блоки шифртекста, если они будут переданы без ошибок, будут корректно расшифрованы, так как ошибки при передаче одного блока в режиме ECB не влияют на остальные блоки. В других режимах это поведение может отличаться.</p><p>Данный режим (как и большая часть остальных рассмотренных режимов) обеспечивает только конфиденциальность<a name="N84357"><!--конфиденциальность--></a> передачи данных, но не целостность<a name="N84363"><!--целостность--></a>. В модели активного злоумышленника, если он предполагает о содержимом блоков открытого текста для части шифртекста, он может, например, манипулировать передаваемыми блоками, вставляя, удаляя или меняя блоки местами. Это приведёт к соответствующим изменениям в открытом тексте (и не приведёт к &laquo;мусору&raquo; после расшифровки). Такие изменения могут не быть замечены получателем и привести к таким действиям, которые ожидает злоумышленник, а не легальный отправитель.</p><h3 data-command-name="subsection" id="5_8_2_Сцепление_блоков_шифртекста">5.8.2. Сцепление блоков шифртекста</h3><p>Режим сцепления блоков шифртекста (англ. <span lang="en"><i>Cipher Block Chaining, CBC</i></span>, рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:CBC">5.14</a>) был описан в патенте компании IBM 1976 года.<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Ehrsam:Meyer:Smith:Tuchman:1976">[73]</a> В этом режиме перед шифрованием текущего блока открытого текста предварительно производится его побитовое суммирование по модулю <span class="mathjax">$2$</span> с предыдущим блоком зашифрованного текста, что и осуществляет &laquo;сцепление&raquo; блоков. Процедура шифрования имеет вид:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    C_j = E_K(M_j \oplus C_{j-1}), ~ j = 1, 2, \dots, n,
\end{array} $$</div><p>где <span class="mathjax">$C_0 = \textrm{IV}$</span> (сокр. от англ. <span lang="en"><i>Initialization Vector</i></span>) &ndash; блок, называемый вектором инициализации<a name="N84433"><!--вектор!инициализации--></a>. Другое название &ndash; синхропосылка<a name="N84439"><!--синхропосылка--></a>.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:CBC" style="vertical-align: top; align-self: start;"></a><img src="images/6AD25BFA778F6B2D9EF767DF0A823FB4.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.14 &mdash; Режим сцепления блоков шифртекста</figcaption></figure><p>Благодаря сцеплению, <em>одинаковым</em> блокам открытого текста соответствуют <em>различные</em> шифрованные блоки. Это затрудняет криптоаналитику статистический анализ потока шифрованных блоков.</p><p>На приёмной стороне расшифрование осуществляется по правилу:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    D_K(C_j) = M_j \oplus C_{j-1}, ~ j=1, 2, \dots, n,\\
    M_{j} = D_K(C_j) \oplus C_{j-1}.
\end{array} $$</div><p>Блок <span class="mathjax">$C_0 = \textrm{IV}$</span> должен быть известен легальному получателю шифрованных сообщений. Обычно криптограф выбирает его случайно и вставляет на первое место в поток шифрованных блоков. Сначала передают блок <span class="mathjax">$C_0$</span>, а затем шифрованные блоки <span class="mathjax">$C_1, C_2, \ldots, C_n$</span>.</p><p>В разных пакетах блоки <span class="mathjax">$C_0$</span> должны выбираться независимо. Если их выбрать одинаковыми, то возникают проблемы, аналогичные проблемам в режиме ECB. Например, часто первые нешифрованные блоки <span class="mathjax">$M_1$</span> в разных пакетах бывают одинаковыми. Тогда одинаковыми будут и первые шифрованные блоки.</p><p>Однако случайный выбор векторов инициализации также имеет свои недостатки. Для выбора такого вектора необходим хороший генератор случайных чисел. Кроме того, каждый пакет удлиняется на один блок.</p><p>Для каждого сеанса передачи пакета нужны такие процедуры выбора <span class="mathjax">$C_0$</span>, которые известны криптографу и легальному пользователю. Одним из решений является использование так называемых <em>одноразовых меток</em>. Каждому сеансу присваивается уникальное число. Его уникальность состоит в том, что оно используется только один раз и никогда не должно повторяться в других пакетах. В англоязычной научной литературе оно обозначается как <em>Nonce</em>, то есть сокращение от &laquo;Number used once&raquo;<a name="N84519"><!--одноразовая метка--></a>.</p><p>Обычно одноразовая метка состоит из номера сеанса и дополнительных данных, обеспечивающих уникальность. Например, при двустороннем обмене шифрованными сообщениями одноразовая метка может состоять из номера сеанса и индикатора направления передачи. Размер одноразовой метки должен быть равен размеру шифруемого блока. После определения одноразовой метки <span class="mathjax">$\textrm{Nonce}$</span> вектор инициализации вычисляется в виде:</p><div class="mathjax" style="text-align: center;">$$ C_0 = \textrm{IV} = E_K(\textrm{Nonce}). $$</div><p>Этот вектор используется в данном сеансе для шифрования открытого текста в режиме CBC. Заметим, что блок <span class="mathjax">$C_0$</span> передавать в сеансе необязательно, если приёмная сторона знает заранее дополнительные данные для одноразовой метки. Вместо этого достаточно вначале передать только номер сеанса в открытом виде. Принимающая сторона добавляет к нему дополнительные данные и вычисляет блок <span class="mathjax">$C_0$</span>, необходимый для расшифрования в режиме CBC. Это позволяет сократить издержки, связанные с удлинением пакета. Например, для шифра AES длина блока <span class="mathjax">$C_0$</span> равна <span class="mathjax">$16$</span> байтов. Если число сеансов ограничить величиной <span class="mathjax">$2^{32}$</span> (вполне приемлемой для большинства приложений), то для передачи номера пакета понадобится только <span class="mathjax">$4$</span> байта.</p><p>Преимущества:</p><ul><li>отсутствие статистической зависимости блоков открытого текста и шифртекста;</li></ul><p>Недостатки:</p><ul><li>необходимость дополнения открытого текста до размера, кратного размеру блоку шифрования;</li><li>невозможность параллельного шифрования (для следующего блока необходимо знать результат обработки предыдущего);</li><li>ошибка передачи бита блока шифртекста приводит к ошибке расшифровки блока открытого текста целиком и к ошибке в одном бите следующего блока;</li><li>не обеспечивает целостность.</li></ul><p>Говоря о возможности восстановления после ошибок передачи, в режиме CBC при изменении одного бита блока шифртекста будет полностью некорректно расшифрован соответствующий блок отрытого текста, а также единственный бит <em>следующего</em> блока открытого текста. Однако последующие блоки затронуты не будут. Поэтому данный режим относят к <em>самовосстанавливающимся</em>.</p><p>Данный режим (как и большая часть остальных рассмотренных режимов) обеспечивает только конфиденциальность<a name="N84575"><!--конфиденциальность--></a> передачи данных, но не целостность<a name="N84581"><!--целостность--></a>. В модели активного злоумышленника, если последний предполагает о возможном содержимом первого блока открытого текста, а вектор инициализации передаётся в открытом виде по каналу связи, злоумышленник может подменить данные в векторе инициализации таким образом, чтобы сформировать нужное содержимое первого блока открытого текста. Такое изменение в режиме CBC не повлечёт других изменений и не приведёт к &laquo;мусору&raquo; в остальных блоках &ndash; будет затронут только первый блок открытого текста. Изменение может не быть замечено получателем и привести к таким действиям получателя, которые ожидает злоумышленник, а не легальный отправитель.</p><h3 data-command-name="subsection" id="5_8_3_Обратная_связь_по_выходу">5.8.3. Обратная связь по выходу</h3><p>В предыдущих режимах входными блоками для функции шифрования были непосредственно блоки открытого текста. В режиме обратной связи по выходу (англ. <span lang="en"><i>Output Feedback, OFB</i></span>, рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:OFB">5.15</a>) блоки открытого текста непосредственно на вход функции шифрования не поступают. Вместо этого функция шифрования генерирует псевдослучайный поток байтов (<em>гамму</em>), который суммируется побитово по модулю <span class="mathjax">$2$</span> с открытым текстом для получения шифртекста. Шифрование осуществляют по правилу:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    X_1 = \textrm{IV}, \\
    Y_j = E_K(X_j), \\
    C_j = Y_j \oplus M_j, \\
    X_{j + 1} = Y_j, ~ j = 1, \dots, n - 1.
\end{array} $$</div><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:OFB" style="vertical-align: top; align-self: start;"></a><img src="images/9F6D63F0B2BF7B04BBE5312BC8561F71.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.15 &mdash; Режим обратной связи по выходу. Пунктирной рамкой выделена область формирования <em>гаммы</em>, независящей от открытого текста.</figcaption></figure><p>Здесь входной блок <span class="mathjax">$X_j$</span> есть результат шифрования предыдущего блока <span class="mathjax">$X_{j-1}$</span>. Начальное значение <span class="mathjax">$X_1 = \textrm{IV}$</span> известно отправителю и легальному получателю. На приёмной стороне расшифрование выполняют по правилу:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    X_1 = \textrm{IV}, \\
	Y_j = E_K(X_j), \\
	M_j = Y_j \oplus C_j, \\
	X_{j + 1} = Y_j, ~ j = 1, \dots, n - 1.
\end{array} $$</div><p>Как и в режиме CBC, вектор инициализации <span class="mathjax">$\textrm{IV}$</span> может быть выбран случайно и передан вместе с шифрованным текстом, либо вычислен на основе одноразовых меток. Здесь особенно важна уникальность вектора инициализации.</p><p>Преимущества:</p><ul><li>относительно простая реализация &ndash; операции шифрования и расшифрования совпадают;</li><li>нет необходимости дополнять открытый текст до размера, кратного размеру блоку шифрования;</li><li>возможность частичной параллелизации шифрования (можно сгенерировать гамму до получения открытого текста);</li><li>ошибка передачи одного бита приводит к ошибке в единственном бите открытого текста.</li></ul><p>Недостатки:</p><ul><li>непредсказуемый период (размер &laquo;гаммы&raquo;);</li><li>не обеспечивает целостность.</li></ul><p>Если рассматривать шифрование в режиме OFB как генератор псевдослучайной последовательности (&laquo;гаммы&raquo;), то очевидно, что максимальный период генератора равен <span class="mathjax">$2^n$</span> блоков, где <span class="mathjax">$n$</span> &ndash; размер блока в битах. То есть максимальный период в битах равен <span class="mathjax">$2^n \times n$</span>. Однако нет никаких гарантий, что период будет максимален. Используя формулу из задачи о парадоксе дней рождения (см<span class="nonbreaking-interword-space"> </span></p><command name="autoref"><argument required="true">section:birthday-paradox</argument></command><p>), находим, что математическое ожидание числа блоков, по достижению которого вероятность &laquo;зациклиться&raquo; более <span class="mathjax">$1/2$</span>, равно:</p><div class="mathjax" style="text-align: center;">$$
b_{1/2} \geq \sqrt{2 \ln 2 \cdot N} \gtrapprox {1,18} \sqrt{N},
$$</div><p>где <span class="mathjax">$N$</span> &ndash; количество разных блоков. Так как <span class="mathjax">$N = 2^n$</span>, то</p><div class="mathjax" style="text-align: center;">$$
b_{1/2} \gtrapprox \{1,18\} \sqrt{2^n} \gtrapprox {1,18} \cdot 2^{n/2}.
$$</div><p>Для шифров &laquo;Кузнечик&raquo; и AES <span class="mathjax">$b_{1/2} \approx {1,18} \cdot 2^{64}$</span>.</p><p>Данная оценка показывает математическое ожидание числа блоков. Но в реальности зацикливание может произойти даже на первом блоке, если в результате шифрования вектора инициализации <span class="mathjax">$\textrm{IV}$</span> снова получится значение <span class="mathjax">$\textrm{IV}$</span>. Что фактически может привести к очень небезопасному шифрованию на гамме (&laquo;гаммирование&raquo;) с длиной периода всего в <span class="mathjax">$n$</span> бит, где <span class="mathjax">$n$</span> &ndash; размер блока шифрования.</p><p>Хорошим размером гаммы считается такой, который больше размера шифруемого сообщения. То есть гамма не должна повторяться в рамках одной передачи. Теоретически можно ввести процесс отслеживания повтора гаммы (что на выходе функции шифрования получилось значение, равное <span class="mathjax">$\textrm{IV}$</span>) и перезапускать процесс передачи с другим значением вектора. Но это потребует усложнения режима шифрования, а также может привести к серьёзным проблемам, если при передаче нового значения <span class="mathjax">$\textrm{IV}$</span> возникнет ошибка.</p><p>Данный режим (как и большая часть остальных рассмотренных режимов) обеспечивает только конфиденциальность<a name="N84754"><!--конфиденциальность--></a> передачи данных, но не целостность<a name="N84760"><!--целостность--></a>. В модели активного злоумышленника, если последний может предположить о содержимом любой части открытого текста, злоумышленник может поменять отдельные биты шифртекста, что приведёт к предсказуемым (с точки зрения криптоаналитика) изменениям в расшифрованном тексте.</p><h3 data-command-name="subsection" id="5_8_4_Обратная_связь_по_шифртексту">5.8.4. Обратная связь по шифртексту</h3><p>В режиме обратной связи по шифртексту (англ. <span lang="en"><i>Cipher FeedBack, CFB</i></span>, рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:CFB">5.16</a>) ключ <span class="mathjax">$K_j$</span> получается с помощью процедуры шифрования предыдущего шифрованного блока <span class="mathjax">$C_{j-1}$</span>. Может быть использован не весь блок <span class="mathjax">$C_{j-1}$</span>, а только его часть. Как и в предыдущем случае, начальное значение ключа <span class="mathjax">$K_0$</span> известно криптографу и легальному пользователю:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    K_0 = \textrm{IV}, \\
    K_j = E_K(C_{j-1}), ~ j = 1, 2, \dots, n,\\
    C_j = K_j \oplus M_j.
\end{array} $$</div><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:CFB" style="vertical-align: top; align-self: start;"></a><img src="images/34062461F807E92642DC0E6CC4711094.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.16 &mdash; Режим обратной связи по шифртексту</figcaption></figure><p>У этого режима нет особых преимуществ по сравнению с другими режимами.</p><h3 data-command-name="subsection" id="5_8_5_Режим_счётчика">5.8.5. Режим счётчика</h3><p>Режим счётчика (англ. <span lang="en"><i>Counter, CTR</i></span>, рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:CTR">5.17</a>) был описан Диффи и Хеллманом в 1979 году.<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Diffie:Hellman:1979">[31]</a> Правило шифрования имеет вид, похожий на режим обратной связи по выходу (OFB), но позволяющий вести независимое (параллельное) шифрование и расшифрование блоков:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    K_j = E_K(\textrm{Nonce} ~\|~ j - 1), ~ j = 1, 2, \dots, n, \\
    C_j = M_j \oplus K_j,
\end{array} $$</div><p>где <span class="mathjax">$\textrm{Nonce} ~\|~ j - 1$</span> &ndash; конкатенация битовой строки одноразовой метки <span class="mathjax">$\textrm{Nonce}$</span> и номера блока, уменьшенного на единицу.</p><!--%Для стандарта AES значение $\textrm{Nonce}$ занимает 16 бит, номер блока - - 48 бит. С одним ключом выполняется шифрование $2^{48}$ блоков.--><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:CTR" style="vertical-align: top; align-self: start;"></a><img src="images/7CA5EBE7D13DA6F75813E0D516F47819.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.17 &mdash; Режим счётчика. Пунктирной рамкой выделена область формирования <em>гаммы</em>, независящей от открытого текста.</figcaption></figure><p>Правило расшифрования идентичное:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    M_j = C_j \oplus K_j. \\
\end{array} $$</div><p>Преимущества:</p><ul><li>относительно простая реализация &ndash; операции шифрования и расшифрования совпадают;</li><li>нет необходимости дополнять открытый текст до размера, кратного размеру блоку шифрования;</li><li>возможность полной параллелизации шифрования (можно приступать к шифрованию любого блока в любой момент);</li><li>ошибка передачи одного бита приводит к ошибке в единственном бите открытого текста.</li></ul><p>Недостатки:</p><ul><li>не обеспечивает целостность.</li></ul><p>В отличии от режима OFB период генерируемой &laquo;гаммы&raquo; всегда одинаков и зависит только от количества бит в <em>nonce</em>. Так как после достижения максимального значения счётчика значение <em>nonce</em> <em>не</em> увеличивается на единицу, период &laquo;гаммы&raquo; равен:</p><div class="mathjax" style="text-align: center;">$$
   \textrm{period} = \textrm{size}_\textrm{block} \times 2^{ \textrm{size}_\textrm{block} - \textrm{size}_\textrm{nonce} }.
$$</div><p>Данный режим (как и большая часть остальных рассмотренных режимов) обеспечивает только конфиденциальность<a name="N84973"><!--конфиденциальность--></a> передачи данных, но не целостность<a name="N84979"><!--целостность--></a>. В модели активного злоумышленника, если последний может предположить о содержимом любой части открытого текста, злоумышленник может поменять отдельные биты шифртекста, что приведёт к предсказуемым (с точки зрения криптоаналитика) изменениям в расшифрованном тексте.</p><h3 data-command-name="subsection" id="5_8_6_Режим_имитовставки">5.8.6. Режим имитовставки</h3><p><a name="N85001"><!--имитовствка!(--></a>
Режим выработки имитовставки (рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:GOST_MAC">5.18</a>, <a href="Literatura.html#GOST-89">[131]</a>) принципиально отличается от рассмотренных ранее режимов тем, что призван обеспечивать не конфиденциальность, а целостность. Результатом является блок данных фиксированного размера (в ГОСТ 28147-89 &ndash; до 32 бит), длина которого не зависит от длины исходного сообщения.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:GOST_MAC" style="vertical-align: top; align-self: start;"></a><img src="images/CB0F8846A2D422FCF6B13FA48CFAE7B4.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.18 &mdash; Режим выработки имитовставки</figcaption></figure><p>Входное сообщение как и ранее разбивается на блоки равной длины <span class="mathjax">$M_1, M_2, \dots, M_n$</span>. Последний блок, при необходимости, дополняется (ГОСТ 28147-89 &ndash; нулями). Формула выработки имитовставки выглядит следующим образом:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
	X_1 = M_1; \\
	Y_j = E_K ( X_j ), ~ j = 1, 2, \dots, n; \\
	X_j = Y_{j-1} \oplus M_j, ~ j = 2, \dots, n; \\
	\textbf{MAC} = Y_n.
\end{array} $$</div><p>В ГОСТ 28147-89 для режима выработки имитовставки функция шифрования использует 16 раундов вместо 32.</p><p>Как уже было сказано, данный режим обеспечивает только целостность информации. Причём саму информацию необходимо передавать, и, возможно, шифровать отдельно. Режим не обеспечивает возможности параллельных вычислений для разных блоков открытого текста.</p><p>Принципиальным недостатком является необходимость использовать секретный ключ<a name="N85053"><!--ключ!секретный--></a> как для выработки имитовставки, так и для её валидации (путём повторной выработки на принимающей стороне и сравнения с результатом). Позже мы рассмотрим функциональных электронных цифровых подписей, которые по своему назначению схожи с имитовставкой, но обеспечивают вариант более гибкого использования &ndash; без необходимости раскрытия ключа, используемого для генерации ЭЦП.</p><p><a name="N85059"><!--имитовствка!)--></a></p><h3 data-command-name="subsection" id="5_8_7_Счётчик_с_аутентификацией_Галуа">5.8.7. Счётчик с аутентификацией Галуа</h3><p>Режим счётчика с аутентификацией Галуа был предложен Девидом МакГрю и Джоном Виега в 2004 году (англ. <span lang="en"><i>Galois/Counter Mode, GCM</i></span>, рис.<span class="nonbreaking-interword-space"> </span><a href="5_8_Rezhimi_raboti_blochnih_shifrov.html#fig:GCM">5.19</a>, <a href="Literatura.html#McGrew:Viega:2004">[70]</a>). Данный режим обеспечивает одновременно конфиденциальность и целостность, при условии правильного использования.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 100%;"><a name="fig:GCM" style="vertical-align: top; align-self: start;"></a><img src="images/8B427D3EEE6AD7ED691BA5A61961725B.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 5.19 &mdash; Режим счётчика с аутентификацией Галуа. Пунктирной рамкой выделена область формирования <em>гаммы</em>, независящей от открытого текста.</figcaption></figure><p>Результатом работы режима, кроме набора шифроблоков, является тег аутентификации, который должен быть использован принимающей стороной для проверки целостности сообщения. Как и в режиме выработки имитовставки, генерация данного тега возможна только легальным пользователем &ndash; знающим секретный ключ, который был использован для шифрования данных.</p><p>&laquo;Верхняя&raquo; часть режима является режимом работы счётчика. В качестве первого значения берётся дополнение нулями вектора инициализации до размера обрабатываемого блока. Потом, как и в режиме CTR, правая часть увеличивается на 1 для каждого следующего блока. Значения счётчика шифруются на секретном ключе <span class="mathjax">$K$</span> для получения блоков гаммы. Самый первый блок полученной гаммы используется не для шифрования открытого текста, а для формирования тега аутентификации.</p><p>Сам тег аутентификации вырабатывается следующим образом. На вход &laquo;подрежима&raquo; генерации тега сначала (опционально) подаются дополнительные данные (англ. <span lang="en"><i>additional authenticated data, AAD</i></span>), которые не нужно шифровать в режиме GCM, но которым нужно обеспечить целостность. Например, это может быть заголовок передаваемого пакета данных. После того, как эти данные закончатся, на вход начнут подаваться блоки шифротекста <span class="mathjax">$C_1, C_2, \dots, C_n$</span>. Использование блоков шифротекста, а не открытого текста, позволяет получателю проверить целостность передаваемых данных до того, как приступит к расшифровке. В качестве последнего блока выступает конкатенация длин дополнительных данных и открытого текста.</p><p>Формирование тега происходит через побитовое сложение результата предыдущего блока с новым блоком AAD или <span class="mathjax">$C_j$</span> и умножение результата на константу <span class="mathjax">$H$</span>, которая в двоичном виде равна результату шифрования нулевого вектора (блока, заполненного нулями) на ключе <span class="mathjax">$K$</span>:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
	H = E_K ( 0^{\{n\}} ) \\
\end{array} $$</div><p>Умножение на константу <span class="mathjax">$H$</span> происходит в поле Галуа <span class="mathjax">${{\mathbb{GF}}(2^{n})}$</span>. Рекомендуемый порождающий многочлен поля для шифра AES (с размером блока 128 бит):</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
	f(x) = x^{128} + x^7 + x^2 + x + 1.
\end{array} $$</div><p>Результат умножения самого последнего блока побитово складывается с первым блоком сформированной гаммы.</p><p>Данный режим обеспечивает и конфиденциальность, и целостность. Шифровать отдельные блоки можно параллельно, а вычисление тега аутентификации делается намного быстрее, чем шифрование. Однако любая ошибка передачи приведёт к вычислению некорректного тега аутентификации, а отличить изменение текста в результате ошибки передачи от вмешательства злоумышленника принципиально невозможно.</p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="5_7_Shifr_Kuznechik_.html">&#129080; 5_7_Shifr_Kuznechik_</a></li><li class="page-item"><a class="page-link" href="5_9_Nekotorie_svoystva_blochnih_shifrov.html">5_9_Nekotorie_svoystva_blochnih_shifrov &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>