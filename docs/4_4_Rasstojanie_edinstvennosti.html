<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="4_4_Расстояние_единственности">4.4. Расстояние единственности</h2><p><a name="N81058"><!--расстояние единственности--></a><a name="N81064"><!--расстояние единственности--></a>Использование ключей с длиной, сопоставимой с размером текста, имеет смысл только в очень редких случаях, когда есть возможность предварительно обменяться ключевой информацией, объём которой много больше планируемого объёма передаваемой информации. Но в большинстве случаев использование абсолютно надёжных систем оказывается неэффективным как с экономической, так и с практической точек зрения. Если двум сторонам нужно постоянно обмениваться большим объёмом информации, и они смогли найти надёжный канал для передачи ключа, то ничто не мешает воспользоваться этим же каналом для передачи самой информации сопоставимого объёма.</p><p>В подавляющем большинстве криптосистем размер ключа много меньше размера открытого текста, который нужно передать. Попробуем оценить теоретическую надёжность подобных систем, исходя из статистических теоретико-информационных соображений.</p><p>Если длина ключа может быть много меньше длины открытого текста, то это означает, что энтропия ключа<a name="N81070"><!--энтропия!ключа--></a> может быть много меньше энтропии открытого текста<a name="N81076"><!--энтропия!открытого текста--></a>: <span class="mathjax">$H(K) \ll H(M)$</span>. Для таких ситуаций важным понятием является <em>расстояние единственности</em><a name="N81090"><!--расстояние единственности--></a>, впервые предложенном в работах Клода Шеннона<span class="nonbreaking-interword-space"> </span>[<a href="Literatura.html#Golomb:2002">24</a>, <a href="Literatura.html#Schneier:2011">91</a>].</p><command name="definition"><argument required="true">definition</argument><content><a name="#definition:unicity_distance"></a>
<em>Расстоянием единственности</em><a name="N81121"><!--расстояние единственности--></a> называется количество символов шифртекста, которое необходимо для однозначного восстановления открытого текста.
</content></command><p>Пусть зашифрованное сообщение (шифртекст) <span class="mathjax">$C$</span> состоит из <span class="mathjax">$N$</span> символов <span class="mathjax">$L$</span>-буквенного алфавита:</p><div class="mathjax" style="text-align: center;">$$C = (C_1, C_2, \dots, C_N).$$</div><p>Определим функцию <span class="mathjax">$h(n)$</span> как условную энтропию<a name="N81143"><!--энтропия!условная--></a> ключа при перехвате криптоаналитиком <span class="mathjax">$n$</span> символов шифртекста:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
    h ( 0 ) = H(K), \\
    h ( 1 ) = H(K | C_1), \\
    h ( 2 ) = H(K | C_1 C_2), \\
    \dots \\
    h ( n ) = H(K | C_1 C_2 \dots C_n), \\
    \dots
\end{array} $$</div><p>Функция <span class="mathjax">$h(n)$</span> называется <em>функцией неопределённости ключа</em><a name="N81163"><!--функция!неопределённости ключа--></a>. Она является невозрастающей функцией числа перехваченных символов <span class="mathjax">$n$</span>. Если для некоторого значения <span class="mathjax">$n_u$</span> окажется, что <span class="mathjax">$h ( n_u ) = 0$</span>, то это будет означать, что ключ <span class="mathjax">$K$</span> является детерминированной функцией первых <span class="mathjax">$n_u$</span> символов шифртекста <span class="mathjax">$C_1, C_2, \dots, C_{n_u}$</span>, и при неограниченных вычислительных возможностях используемый ключ <span class="mathjax">$K$</span> может быть определён. Число <span class="mathjax">$n_u$</span> и будет являться <em>расстоянием единственности</em>. Полученное <span class="mathjax">$n_u$</span> соответствует определению<span class="nonbreaking-interword-space"> </span><a href="#definition:unicity_distance">[definition:unicity_distance]</a>, так как для корректной криптосистемы определение ключа единственным образом также означает и возможность получить открытый текст только одним способом.</p><p>Найдём типичное поведение функции <span class="mathjax">$h(n)$</span> и значение расстояния единственности <span class="mathjax">$n_u$</span>. Используем следующие предположения.</p><ul><li>Криптограф всегда стремится спроектировать систему таким образом, чтобы символы шифрованного текста имели равномерное распределение, и следовательно энтропия шифртекста<a name="N81218"><!--энтропия!шифртекста--></a> имела максимальное значение:
            <div class="mathjax" style="text-align: center;">$$ H(C_1 C_2 \dots C_n) \approx n \log_2 L, ~ n = 1, 2, \dots, N. $$</div></li><li>Имеет место соотношение:
            <div class="mathjax" style="text-align: center;">$$ H(C | K) = H(C_1 C_2 \dots C_N | K)  =  H(M), $$</div>
        которое следует из цепочки равенств:
            <div class="mathjax" style="text-align: center;">$$ H(MCK) = H(M) + H(K | M) + H(C | MK) = H(M) + H(K), $$</div>
        так как
            <div class="mathjax" style="text-align: center;">$$ H(K | M) = H(K), ~~ H(C | MK) = 0, $$</div>
            <div class="mathjax" style="text-align: center;">$$H(MCK) = H(K) + H(C | K) + H(M | CK) = H(K) + H(C | K), $$</div>
        поскольку
            <div class="mathjax" style="text-align: center;">$$ H(M | CK) = 0. $$</div></li><li>Предполагается, что для любого <span class="mathjax">$n \leq N$</span> приближённо выполняются соотношения:
        <div class="mathjax" style="text-align: center;">$$ H(C_n | K) \approx \frac{1}{N} H(M), $$</div>
        <div class="mathjax" style="text-align: center;">$$ H(C_1 C_2\dots C_n | K) \approx \frac{n}{N} H(M). $$</div></li></ul><p>Вычислим энтропию <span class="mathjax">$H(C_1 C_2 \dots C_n ; K)$</span> двумя способами:</p><div class="mathjax" style="text-align: center;">$$ H( C_1 C_2 \dots C_n ; K ) = H(C_1 C_2 \dots C_n) + H(K | C_1 C_2 \dots C_n) \approx $$</div><div class="mathjax" style="text-align: center;">$$ \approx n \log_2 L + h(n), $$</div><div class="mathjax" style="text-align: center;">$$ H( C_1 C_2 \dots C_n ; K ) = H(K) + H(C_1 C_2 \dots C_n | K) \approx $$</div><div class="mathjax" style="text-align: center;">$$ \approx H(K) + \frac{n}{N} H(M). $$</div><p>Отсюда следует, что</p><div class="mathjax" style="text-align: center;">$$ h(n) \approx H(K) + n \left( \frac{H(M)}{N} - \log_2 L \right) $$</div><p>и</p><div class="mathjax" style="text-align: center;">$$ n_u = \frac{H(K)}{ \left( 1 - \frac{H(M)}{N \log_2 L} \right) \log_2 L} = \frac{H(K)}{\rho \log_2 L}. $$</div><p>Здесь</p><div class="mathjax" style="text-align: center;">$$ \rho = 1 - \frac{H(M)}{N \log_2 L} $$</div><p>означает избыточность источника открытых текстов<a name="N81277"><!--избыточность!открытого текста--></a>.</p><p>Если избыточность источника измеряется в битах на символ, а ключ шифрования выбирается случайным образом из всего множества ключей <span class="mathjax">$\{0, 1\}^{l_K}$</span>, где <span class="mathjax">$l_K$</span> &ndash; длина ключа в битах, то расстояние единственности <span class="mathjax">$n$</span> также выражается в битах, и формула значительно упрощается:</p><command name="equation"><argument required="true">equation</argument><content><a name="#eq:unicity_distance_simple_frac"></a>
n_u <command name="approx"></command><command name="frac"><argument required="true">l_K</argument><argument required="true"><command name="rho"></command></argument></command>.
</content></command><p>Взяв нижнюю границу <span class="mathjax">$H(M)$</span> энтропии<a name="N81321"><!--энтропия!открытого текста--></a> одного символа английского текста как <span class="mathjax">$1{,}3$</span> бит/символ<span class="nonbreaking-interword-space"> </span>[<a href="Literatura.html#Shannon:1951">98</a>, <a href="Literatura.html#Schneier:2002">135</a>], получим:</p><div class="mathjax" style="text-align: center;">$$ \rho _{en} \approx 1 - \frac{ 1{,}3 }{ \log _2 {26} } \approx 0{,}72.$$</div><p>Для русского текста с энтропией <span class="mathjax">$H(M)$</span>, примерно равной <span class="mathjax">$3{,}01$</span> бит/символ<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Lebedev:1958">[128]</a></p><command name="footnote"><argument required="true">Следует отметить, что для английского текста значение энтропии, равное <span class="mathjax">$1{,}3$</span> бит/символ, представляет собой суммарную оценку для всего текста, в то время как оценка <span class="mathjax">$3{,}01$</span> бит/символ энтропии для русского текста получена Лебедевым и Гармашем из анализа <em>частот трёхбуквенных сочетаний</em> в отрывке текста Л.&nbsp;Н.&nbsp;Толстого &laquo;Война и мир&raquo; длиной в 30 тыс. символов. Соответствующая оценка для английского текста, также приведённая в работе Шеннона, примерно равна <span class="mathjax">$3{,}0$</span> бит/символ.</argument></command><p>, получаем:</p><div class="mathjax" style="text-align: center;">$$ \rho _{ru} \approx 1 - \frac{ 3{,}0 }{ \log _2 {32} } \approx 0{,}40.$$</div><p>Однако если предположить, что текст передаётся в формате простого текстового файла (англ. <span lang="en"><i>plain text</i></span>) в стандартной кодировке UTF-8 (один байт на английский символ и два байта на символ кириллицы), то значения избыточности становятся равными приблизительно <span class="mathjax">$0{,}83$</span> для английского и <span class="mathjax">$0{,}81$</span> для русского языков:</p><command name="gather*"><argument required="true">gather*</argument><content>
<command name="rho"></command>_en, <command name="text"><argument required="true"><i>UTF-8</i></argument></command> <command name="approx"></command>1 - <command name="frac"><argument required="true"> 1,3 </argument><argument required="true"> <command name="log"></command>_2 2^8 </argument></command> <command name="approx"></command>0,83,<line-break></line-break>
<command name="rho"></command>_ru, <command name="text"><argument required="true"><i>UTF-8</i></argument></command> <command name="approx"></command>1 - <command name="frac"><argument required="true"> 3,0 </argument><argument required="true"> <command name="log"></command>_2 2^16 </argument></command> <command name="approx"></command>0,81.
</content></command><p>Подставим полученные значения в выражение<span class="nonbreaking-interword-space"> </span><a href="#eq:unicity_distance_simple_frac">[eq:unicity_distance_simple_frac]</a> для шифров DES<a name="N81476"><!--шифр!DES--></a> и AES<a name="N81482"><!--шифр!AES--></a>. Запишем результаты в таблицу<span class="nonbreaking-interword-space"> </span><a href="#table:unicity_distances">[table:unicity_distances]</a>.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><table style="border-collapse: collapse;"><colgroup><col style="border-left: double;border-right: solid thin;"><col style="border-left: solid thin;border-right: solid thin;"><col style="border-left: solid thin;border-right: double;"></colgroup><tr style="border-bottom: double;border-top: double;"><td style="padding-left: 6pt;padding-right: 6pt;text-align: left;white-space: nowrap;"><command name="text"><argument required="true">Блочный шифр</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true">Английский текст</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true">Русский текст</argument></command></td></tr><tr style="border-top: double;"><td style="padding-left: 6pt;padding-right: 6pt;text-align: left;white-space: nowrap;"><command name="text"><argument required="true">Шифр DES<a name="N81555"><!--шифр!DES--></a>,</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true"> <span class="mathjax">$\approx~67$</span> бит;</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true"><span class="mathjax">$\approx~69$</span> бит;</argument></command></td></tr><tr style="border-bottom: solid thin;"><td style="padding-left: 6pt;padding-right: 6pt;text-align: left;white-space: nowrap;"><command name="text"><argument required="true">ключ 56 бит</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true"> 2 блока данных</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true">2 блока данных</argument></command></td></tr><tr style="border-top: solid thin;"><td style="padding-left: 6pt;padding-right: 6pt;text-align: left;white-space: nowrap;"><command name="text"><argument required="true">Шифр AES<a name="N81606"><!--шифр!AES--></a>,</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true"> <span class="mathjax">$\approx~153$</span> бит;</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true"><span class="mathjax">$\approx~158$</span> бит;</argument></command></td></tr><tr style="border-bottom: double;"><td style="padding-left: 6pt;padding-right: 6pt;text-align: left;white-space: nowrap;"><command name="text"><argument required="true">ключ 128 бит</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true"> 3 блока данных</argument></command></td><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="text"><argument required="true">3 блока данных</argument></command></td></tr></table><figcaption style="flex-basis: 100%; text-align: center;">Таблица 4.1 &mdash; Расстояния единственности для шифров DES<a name="N81655"><!--шифр!DES--></a> и AES<a name="N81661"><!--шифр!AES--></a> для английского и русского текстов в формате простого текстового файла и кодировке UTF-8</figcaption></figure><p>Полученные данные, с теоретической точки зрения, означают, что когда криптоаналитик будет подбирать ключ к зашифрованным данным, трёх блоков данных ему будет достаточно, чтобы сделать вывод о правильности выбора ключа расшифрования и корректности дешифровки, если известно, что в качестве открытого текста выступает простой текстовый файл. Если открытым текстом является случайный набор данных, то криптоаналитик не сможет отличить правильно расшифрованный набор данных от неправильного, и расстояние единственности, в соответствии с выводами выше (для нулевой избыточности источника), оказывается равным бесконечности.</p><p>Улучшить ситуацию для легального пользователя помогает предварительное сжатие открытого текста с помощью алгоритмов архивации, что уменьшает его избыточность<a name="N81676"><!--избыточность!открытого текста--></a> (а также уменьшает размер и ускоряет процесс шифрования в целом). Однако расстояние единственности не становится бесконечным, так как в результате работы алгоритмов архивации присутствуют различные константные сигнатуры, а для многих текстов можно заранее предсказать примерные словари сжатия, которые будут записаны как часть открытого текста. Более того, используемые на практике программы безопасной передачи данных вынуждены встраивать механизмы хотя бы частичной быстрой проверки правильности ключа расшифрования (например, добавлением известной сигнатуры в начало открытого текста). Делается это для того, чтобы сообщить легальному получателю об ошибке ввода ключа, если такая ошибка случится.</p><p>Соображения выше показывают, что для одного ключа расшифрования процедура проверки его корректности является быстрой. Чтобы значительно усложнить работу криптоаналитику, множество ключей, которые требуется перебрать, должно быть большой величиной (например, от <span class="mathjax">$2^{80}$</span>). Этого можно достичь, во-первых, увеличением битовой длины ключа, во-вторых, аккуратной разработкой алгоритма шифрования, чтобы криптоаналитик не смог &laquo;отбросить&raquo; часть ключей без их полной проверки.</p><p>Несмотря на то, что теоретический вывод о совершенной криптостойкости для практики неприемлем, так как требует большого объёма ключа, сравнимого с объёмом открытого текста, разработанные идеи находят успешное применение в современных криптосистемах. Вытекающий из идей Шеннона принцип выравнивания апостериорного распределения символов в шифртекстах используется в современных криптосистемах с помощью многократных итераций (раундов), включающих замены и перестановки.</p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="4_3_Kriptosistema_Vernama.html">&#129080; 4_3_Kriptosistema_Vernama</a></li><li class="page-item"><a class="page-link" href="Glava_5_Blochnie_shifri.html">Glava_5_Blochnie_shifri &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>