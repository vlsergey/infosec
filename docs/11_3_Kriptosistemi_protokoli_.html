<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="11_3_Криптосистемы_протоколы_">11.3. &laquo;Криптосистемы-протоколы&raquo;</h2><p>Как и создатели трёхпроходных протоколов из раздела<span class="nonbreaking-interword-space"> </span><a href="#section-three-pass-protocols">11.2</a>, авторы следующих алгоритмов считали их не просто математическими конструкциями, обеспечивающие некоторую элементарную операцию (например, шифрование с открытым ключом), но пытались вокруг одной-двух математических конструкций построить законченную систему распространения ключей. Некоторые из этих конструкций, преобразовавшись, используются до настоящего времени (например, протокол Диффи-Хеллмана), некоторые &ndash; остались только в истории криптографии и защиты информации.</p><p>Позже в 1990-х годах будут разделены математические асимметричные примитивы (шифрование и электронная подпись) и протоколы, эти примитивы использующие, что будет продемонстрировано в разделе<span class="nonbreaking-interword-space"> </span><a href="#section-protocols-asymmetric">11.5</a>.</p><h3 data-command-name="subsection" id="11_3_1_Протокол_Диффи_Хеллмана">11.3.1. Протокол Диффи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Хеллмана</h3><p><a name="N100563"><!--протокол!Диффи—Хеллмана|(--></a><a name="N100572"><!--схема!Диффи—Хеллмана|(--></a>
Первый алгоритм с открытым ключом был предложен Диффи и Хеллманом в работе 1976 года &laquo;Новые направления в криптографии&raquo; (англ. <span lang="en"><i>Bailey Whitfield Diffie, Martin Edward Hellman, ``New directions in cryptography''</i></span>,<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Diffie:Hellman:1976">[30]</a>). Данный протокол, который также можно назвать <em>схемой Диффи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Хеллмана</em>, стал первым, позволивший уменьшить требования к каналу связи для установления защищённого соединения без предварительного обмена ключами.</p><p>Протокол позволяет двум сторонам создать общий сеансовый ключ используя такой канал связи, который может прослушивать злоумышленник, но в предположении, что последний не может менять содержимое сообщений.</p><p>Пусть <span class="mathjax">$p$</span> &ndash; большое простое число<a name="N100613"><!--число!простое--></a>, <span class="mathjax">$g$</span> &ndash; примитивный элемент группы <span class="mathjax">${{\mathbb{Z}}}_p^*$</span>, <span class="nonbreaking-interword-space"> </span> <span class="mathjax">$y = g^x \bmod p$</span>, причём <span class="mathjax">$p, y, g$</span> известны заранее. Функцию <span class="mathjax">$y=g^{x} \bmod p$</span> считаем однонаправленной, то есть вычисление функции при известном значении аргумента является лёгкой задачей, а её обращение (нахождение аргумента) при известном значении функции &ndash; трудной.</p><command name="footnote"><argument required="true">Обратную функцию <span class="mathjax">$x = \log_g y \bmod p$</span> называют функцией дискретного логарифма. В настоящий момент не существует быстрых способов вычисления такой функции для больших простых <span class="mathjax">$p$</span>.</argument></command><p>Протокол обмена состоит из следующих действий.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-diffie-hellman" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A = g ^ a \bmod p $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ B = g ^ b \bmod p $</span></argument><argument required="true">Alice</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.14 &mdash; Протокол Диффи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Хеллмана</figcaption></figure><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Алиса выбирает случайное <span class="mathjax">$2 \leq a \leq p - 1$</span></li><li><span class="mathjax">$Alice \to \left\{ A = g ^ a \bmod p \right\} \to Bob$</span></li><li>Боб выбирает случайное <span class="mathjax">$2 \leq b \leq p-1$</span></li><li>Боб вычисляет сеансовый ключ <span class="mathjax">$K = A ^ b \bmod p$</span></li><li><span class="mathjax">$Bob \to \left\{ B = g ^ b \bmod p \right\} \to Alice$</span></li><li>Алиса вычисляет <span class="mathjax">$K = B ^ a \bmod p$</span></li></ul></content></command><p>Таким способом создан общий секретный сеансовый ключ <span class="mathjax">$K$</span>. За счёт случайного выбора значений <span class="mathjax">$a$</span> и <span class="mathjax">$b$</span> в каждом новом сеансе будет получен новой сеансовый ключ.</p><p>Протокол обеспечивает только генерацию сеансового ключа. Выбор нового &laquo;мастер&raquo;-ключа любой из сторон гарантирует (с вероятностью <span class="mathjax">$1 - 1/p$</span>) для неё формирование нового сеансового ключа  (цель G10). В отсутствие третей доверенной стороны протокол не обеспечивает аутентификацию сторон (цель G1), а из-за отсутствия проходов с подтверждением владения ключом отсутствует аутентификация ключа (цель G8). Так как протокол не использует длительные &laquo;мастер&raquo;-ключи, можно говорить о том, что он обладает свойством совершенной прямой секретности (цель G9).</p><p>Протокол можно использовать только с такими каналами связи, в которые не может вмешаться активный криптоаналитик. В противном случае протокол становится уязвим к простой атаке &laquo;человек посередине&raquo;<a name="N100785"><!--атака!«человек посередине»--></a>.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-diffie-hellman-mitm" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Mellory</argument><argument required="true">Mellory</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A = g ^ a \bmod p $</span></argument><argument required="true">Mellory</argument></command>
		<command name="prelevel"></command>
		<command name="mess"><argument required="true">Mellory</argument><argument required="true"><span class="mathjax">$ M = g ^ m \bmod p $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ B = g ^ b \bmod p $</span></argument><argument required="true">Mellory</argument></command>
		<command name="prelevel"></command>
		<command name="mess"><argument required="true">Mellory</argument><argument required="true"><span class="mathjax">$ M = g ^ m \bmod p $</span></argument><argument required="true">Alice</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.15 &mdash; Атака &laquo;человек посередине&raquo; на протокол Диффи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Хеллмана</figcaption></figure><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Алиса выбирает случайное <span class="mathjax">$2 \leq a \leq p - 1$</span></li><li><span class="mathjax">$Alice \to \left\{ A = g ^ a \bmod p \right\} \to Mellory~(Bob)$</span></li><li>Меллори выбирает случайное <span class="mathjax">$2 \leq m \leq p-1$</span></li><li>Меллори вычисляет сеансовый ключ для канала с Алисой
        <div class="mathjax" style="text-align: center;">$$K_{AM} = A ^ m \bmod p = g ^ {am} \bmod p$$</div></li><li><span class="mathjax">$Mellory~(Alice) \to \left\{ M = g ^ m \bmod p \right\} \to Bob$</span></li><li><span class="mathjax">$Mellory~(Bob) \to \left\{ M = g ^ m \bmod p \right\} \to Alice$</span></li><li>Алиса вычисляет сеансовый ключ для канала с Меллори (думая, что Меллори это Боб)
        <div class="mathjax" style="text-align: center;">$$K_{AM} = M ^ a \bmod p = g ^ { am } \bmod p$$</div></li><li>Боб выбирает случайное <span class="mathjax">$2 \leq b \leq p-1$</span></li><li>Боб вычисляет сеансовый ключ для канала с Меллори (думая, что Меллори это Алиса)
        <div class="mathjax" style="text-align: center;">$$K_{BM} = M ^ b \bmod p = g ^ { bm } \bmod p$$</div></li><li><span class="mathjax">$Bob \to \left\{ B = g ^ b \bmod p \right\} \to Mellory~(Alice)$</span></li><li>Меллори вычисляет сеансовый ключ для канала с Бобом
        <div class="mathjax" style="text-align: center;">$$K_{BM} = B ^ m \bmod p = g ^ { bm } \bmod p$$</div></li></ul></content></command><p>В результате Алиса и Боб получили новые сеансовые ключи, но &laquo;защищённый&raquo; канал связи установили не с друг с другом, а со злоумышленником, который теперь имеет возможность ретранслировать или изменять все передаваемые сообщения между Алисой и Бобом.</p><p>Протокол Диффи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Хеллмана отличается от большей части протоколов распространения ключей из-за того, что не использует другие криптографические примитивы (функции шифрования, электронно-цифровой подписи или хеширования), но сам по себе является в некотором смысле криптографическим примитивом для построения более сложных протоколов. Он обеспечивает генерацию случайного числа в распределённой системе без доверенного центра. Причём ни одна из сторон не может заставить другую сторону использовать старый сессионный ключ, в отличие от, например, протокола Yahalom<a name="N100982"><!--протокол!Yahalom--></a> из раздела<span class="nonbreaking-interword-space"> </span><a href="#section-protocols-yahalom">11.1.2</a>.</p><p>Протокол можно изменить таким образом, чтобы вместо мультипликативной группы простого умножения использовать аддитивную группу сложения точек эллиптической кривой (см. раздел<span class="nonbreaking-interword-space"> </span><a href="#section-math-ec-groups">16.7</a>). В этом случае стороны по прежнему будут выбирать некоторые случайные целые числа, но не возводить генератор-число в степень, а умножать генератор-точку на загаданное число.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Стороны договорились о группе точек эллиптической кривой <span class="mathjax">${\mathbb{E}}$</span>, её циклической подгруппе <span class="mathjax">${\mathbb{G}}$</span> мощности <span class="mathjax">$n = \| {\mathbb{G}} \|$</span> и генераторе <span class="mathjax">$G$</span> группы <span class="mathjax">${\mathbb{G}}$</span> (или хотя бы достаточно большой подгруппы группы <span class="mathjax">${\mathbb{G}}$</span>).</li><li>Алиса выбирает случайное <span class="mathjax">$2 \leq a \leq n - 1$</span></li><li><span class="mathjax">$Alice \to \left\{ A = a \times G \right\} \to Bob$</span></li><li>Боб выбирает случайное <span class="mathjax">$2 \leq b \leq n - 1$</span></li><li>Боб вычисляет точку <span class="mathjax">$K = b \times A$</span></li><li><span class="mathjax">$Bob \to \left\{ B = g \times G \right\} \to Alice$</span></li><li>Алиса вычисляет точку <span class="mathjax">$K = a \times B$</span></li></ul></content></command><p>В качестве нового сессионного ключа стороны могут выбрать, например, первую координату найденной точки <span class="mathjax">$K$</span>.</p><p><a name="N101069"><!--протокол!Диффи—Хеллмана|)--></a><a name="N101078"><!--схема!Диффи—Хеллмана|)--></a></p><h3 data-command-name="subsection" id="11_3_2_Протокол_Эль_Гамаля">11.3.2. Протокол Эль-Гамаля</h3><p><a name="N101103"><!--протокол!Эль-Гамаля|(--></a></p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-el-gamal" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>

		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ g^x \bmod p $</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.16 &mdash; Протокол Эль-Гамаля</figcaption></figure><p>Протокол Эль-Гамаля (рис.<span class="nonbreaking-interword-space"> </span><a href="11_3_Kriptosistemi_protokoli_.html#fig:key_distribution-el-gamal">11.16</a>, [<a href="Literatura.html#ElGamal:1984">35</a>, <a href="Literatura.html#ElGamal:1985">36</a>]) за счёт предварительного распространения открытого ключа одной из сторон обеспечивает аутентификацию ключа для этой стороны. Можно гарантировать, что только владелец соответствующего закрытого ключа сможет вычислить сеансовый ключ. Однако подтверждение факта получение ключа (выполнение целей G1 и G8) не является частью протокола.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Алиса и Боб выбирают общие параметры <span class="mathjax">$p$</span> и <span class="mathjax">$g$</span>, где <span class="mathjax">$p$</span> &ndash; большое простое число, а <span class="mathjax">$g$</span> &ndash; примитивный элемент поля <span class="mathjax">${{\mathbb{Z}}}_p^*$</span>.</li><li>Боб создаёт пару из закрытого и открытого ключей <span class="mathjax">$b$</span> и <span class="mathjax">$K_B$</span>:
        <div class="mathjax" style="text-align: center;">$$\begin{array}{l}
            b: 2 \leq b \leq p - 1, \\
            K_B = g^b \bmod p.
        \end{array}$$</div></li><li>Открытый ключ <span class="mathjax">$K_B$</span> находится в общем открытом доступе для всех сторон. Криптоаналитик не может подменить его &ndash; подмена будет заметна.</li><li>Алиса выбирает секрет <span class="mathjax">$x$</span> и вычисляет сеансовый ключ <span class="mathjax">$K$</span>
        <div class="mathjax" style="text-align: center;">$$ K = K_B^{x} = g^{bx} \bmod p. $$</div>
        <div class="mathjax" style="text-align: center;">$$ Alice \to \left\{ g^x \bmod p \right\} \to Bob$$</div></li><li>Боб вычисляет сеансовый ключ
        <div class="mathjax" style="text-align: center;">$$ K = (g^x)^{b} = g^{bx} \bmod p. $$</div></li></ul></content></command><p>Протокол не обеспечивает гарантию выбора нового сессионного ключа в каждом сеансе протокола (G10), а использование &laquo;мастер&raquo;-ключа <span class="mathjax">$K_B$</span> для передачи сеансового ключа позволяет злоумышленнику вычислить все сессионные ключи из прошлых сеансов при компрометации закрытого ключа <span class="mathjax">$b$</span> (цель G9).</p><p><a name="N101263"><!--протокол!Эль-Гамаля|)--></a></p><h3 data-command-name="subsection" id="11_3_3_Протокол_MTI_A_0_">11.3.3. Протокол MTI/A(0)</h3><p><a name="N101285"><!--протокол!MTI/A(0)|(--></a>
В 1986 году Ц.<span class="nonbreaking-interword-space"> </span>Мацумото (англ. <span lang="en"><i>Tsutomu Matsumoto</i></span>), И.<span class="nonbreaking-interword-space"> </span>Такашима (англ. <span lang="en"><i>Youichi Takashima</i></span>) и Х.<span class="nonbreaking-interword-space"> </span>Имаи (англ. <span lang="en"><i>Hideki Imai</i></span>) предложили несколько алгоритмов, позже названных семейством протоколов MTI (<a href="Literatura.html#Matsumoto:Tsutomu:Imai:1986">[68]</a>). За счёт предварительного распространения открытых ключей обоих сторон они обеспечивали неявную аутентификацию ключа (цель G7). То есть сессионный ключ гарантированно мог получить только владельцы соответствующих открытых ключей. Мы рассмотрим одного из представителей данного семейства &ndash; протокол MTI/A(0) (рис.<span class="nonbreaking-interword-space"> </span><a href="11_3_Kriptosistemi_protokoli_.html#fig:key_distribution-mti">11.17</a>).</p><p>Предварительно стороны договорились об общих параметрах системы <span class="mathjax">$p$</span> и <span class="mathjax">$g$</span>, где <span class="mathjax">$p$</span> &ndash; большое простое число, а <span class="mathjax">$g$</span> &ndash; примитивный элемент поля <span class="mathjax">${{\mathbb{Z}}}_p^*$</span>.</p><p>Каждая из сторон (Алиса и Боб) сгенерировала пару из закрытого и открытого ключей:</p><div class="mathjax" style="text-align: center;">$$\begin{array}{ll}
    Alice: &amp; ~ a, ~~ K_A = g^a \bmod p, \\
    Bob: &amp; ~ b, ~~ K_B = g^b \bmod p. \\
\end{array}$$</div><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-mti" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>

		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ g^{R_A} \bmod p $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ g^{R_B} \bmod p $</span></argument><argument required="true">Alice</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.17 &mdash; Протокол MTI/A(0)</figcaption></figure><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Алиса сгенерировала случайное число <span class="mathjax">$R_A: ~ 2\leq R_A\leq p-1$</span></li><li><span class="mathjax">$ Alice \to \left\{ g^{R_A} \bmod p \right\} \to Bob$</span></li><li>Боб сгенерировал случайное число <span class="mathjax">$R_B: ~ 2\leq R_B\leq p-1$</span></li><li>Боб вычислил сеансовый ключ <span class="mathjax">$K = (g^{R_A})^b \cdot K_A^{R_B} \bmod p$</span></li><li><span class="mathjax">$ Bob \to \left\{ g^{R_B} \bmod p \right\} \to Alice$</span></li><li>Алиса вычислила сеансовый ключ <span class="mathjax">$K = (g^{R_B})^a \cdot K_B^{R_A} \bmod p$</span></li></ul></content></command><p>Если открытые ключи <span class="mathjax">$K_A$</span> и <span class="mathjax">$K_B$</span> соответствуют своим закрытым ключам <span class="mathjax">$a$</span> и <span class="mathjax">$b$</span>, то вычисленные участниками сессионные ключи совпадают:</p><div class="mathjax" style="text-align: center;">$$\begin{array}{lll}
    (g^{R_A})^b \cdot K_A^{R_B} \bmod p &amp; = &amp; g^{b R_A + a R_B} \bmod p, \\
    (g^{R_B})^a \cdot K_B^{R_A} \bmod p &amp; = &amp; g^{a R_B + b R_A} \bmod p.
\end{array}$$</div><p>Из-за сложности задачи дискретного логарифмирования злоумышленник не сможет получить <span class="mathjax">$a, R_A$</span> или <span class="mathjax">$b, R_B$</span> из передаваемых сообщений, а предварительная публикация открытых ключей гарантирует, что сессионный ключ получат только легальные пользователи. Случайный выбор <span class="mathjax">$R_A$</span> и <span class="mathjax">$R_B$</span> гарантирует, что обе стороны могут быть уверены в создании нового сессионного ключа в каждом сеансе протокола.</p><p>Как и другие представители криптосистем-протоколов, MTI не разрабатывался с учётом возможности компрометации закрытых &laquo;мастер&raquo;-ключей <span class="mathjax">$a$</span> и <span class="mathjax">$b$</span> (цель G9).</p><p><a name="N101519"><!--протокол!MTI/A(0)|)--></a></p><h3 data-command-name="subsection" id="11_3_4_Протокол_Station_to_Station">11.3.4. Протокол Station-to-Station</h3><p><a name="N101541"><!--протокол!Station-to-Station|(--></a>
Протокол STS (англ. <span lang="en"><i>Station-to-Station</i></span>,<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Diffie:Oorschot:Wiener:1992">[32]</a>)<a name="N101565"><!--протокол!Station-to-Station--></a> предназначен для систем мобильной связи. Он использует идеи протокола Диффи<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Хеллмана<a name="N101575"><!--протокол!Диффи—Хеллмана--></a> и криптосистемы RSA<a name="N101585"><!--криптосистема!RSA--></a>. Особенностью протокола является использование механизма электронной подписи<a name="N101591"><!--электронная подпись--></a> для взаимной аутентификации сторон<a name="N101597"><!--аутентификация!взаимная--></a>.</p><p>Предварительно стороны договорились об общих параметрах системы <span class="mathjax">$p$</span> и <span class="mathjax">$g$</span>, где <span class="mathjax">$p$</span> &ndash; большое простое число, а <span class="mathjax">$g$</span> &ndash; примитивный элемент поля <span class="mathjax">${{\mathbb{Z}}}_p^*$</span>.</p><p>Каждая из сторон <span class="mathjax">$A$</span> и <span class="mathjax">$B$</span> обладает долговременной парой ключей: закрытым ключом для расшифрования и создания электронной подписи <span class="mathjax">$K_{\text{private}}$</span> и открытым ключом для шифрования и проверки подписи <span class="mathjax">$K_{\text{public}}$</span>.</p><div class="mathjax" style="text-align: center;">$$\begin{array}{ll}
    A: K_{A,\text{private}}, K_{A,\text{public}}: \forall M : &amp; \text{Verify}_A ( M, S_A( M ) ) = true, \\
                                                &amp; D_A ( E_A( M ) ) = M, \\
    B: K_{B,\text{private}}, K_{B,\text{public}}: \forall M : &amp; \text{Verify}_B ( M, S_B( M ) ) = true, \\
                                                &amp; D_B ( E_B( M ) ) = M. \\
\end{array}$$</div><p>Где <span class="mathjax">$\text{Verify}_A(\dots)$</span> это функция проверки электронной подписи на открытом ключе <span class="mathjax">$K_{A, \text{public}}$</span>, а <span class="mathjax">$D_A$</span> &ndash; функция расшифрования с использованием закрытого ключа <span class="mathjax">$K_{A, \text{private}}$</span>.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-sts" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A, m_A = g^{R_A} \bmod p $</span></argument><argument required="true">Bob</argument></command>
		<command name="postlevel"></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><command name="shortstack"><argument required="true"> <span class="mathjax">$  B, A, m_B = g^{R_B} \bmod p$</span>, <line-break></line-break> <span class="mathjax">$E_K( S_B ( m_A, m_B )) $</span> </argument></command></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A, B, E_K( S_A ( m_A, m_B ) ) $</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.18 &mdash; Протокол STS</figcaption></figure><p>Протокол состоит из четырёх проходов, три из которых включают передачу сообщений (рис.<span class="nonbreaking-interword-space"> </span><a href="11_3_Kriptosistemi_protokoli_.html#fig:key_distribution-sts">11.18</a>, <a href="Literatura.html#Cheremushkin:2009">[133]</a>).</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Алиса выбирает случайное число <span class="mathjax">$R_A: 2 \leq R_A \leq p-1$</span>.</li><li><span class="mathjax">$Alice \to \left\{ A, m_A = g^{R_A} \bmod p \right\} \to Bob$</span></li><li>Боб выбирает случайное число <span class="mathjax">$R_B: 2 \leq R_B \leq p-1$</span>.</li><li>Боб вычисляет сессионный ключ <span class="mathjax">$K = m_A^{R_B} \bmod p$</span>.</li><li><span class="mathjax">$Bob \to \left\{ B, A, m_B = g^{R_B} \bmod p, E_K( S_B ( m_A, m_B )) \right\} \to Alice$</span></li><li>Алиса вычисляет сессионный ключ <span class="mathjax">$K = m_B^{R_A} \bmod p$</span>.</li><li>Алиса проверяет подпись в сообщении <span class="mathjax">$E_K( S_B ( m_A, m_B ))$</span>.</li><li><span class="mathjax">$Alice \to \left\{ A, B, E_K( S_A ( m_A, m_B ) ) \right\} \to Bob$</span></li><li>Боб проверяет подпись в сообщении <span class="mathjax">$E_K( S_A ( m_A, m_B ))$</span>.</li></ul></content></command><p>Протокол обеспечивает гарантию формирования новых ключей (G10), но не совершенную прямую секретность (G9).</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-sts-attack" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.75</argument><argument required="true">Mellory</argument><argument required="true">Mellory</argument></command>
		<command name="newinst"><argument required="false">2.75</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A, m_A = g^{R_A} \bmod p $</span></argument><argument required="true">Mellory</argument></command>
		<command name="mess"><argument required="true">Mellory</argument><argument required="true"><span class="mathjax">$ M, m_A $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ B, M, m_B, E_K( S_B ( m_A, m_B )) $</span></argument><argument required="true">Mellory</argument></command>
		<command name="mess"><argument required="true">Mellory</argument><argument required="true"><span class="mathjax">$ B, A, m_B, E_K( S_B ( m_A, m_B )) $</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A, B, E_K( S_A ( m_A, m_B ) ) $</span></argument><argument required="true">Mellory</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.19 &mdash; Атака Лоу на протокол STS</figcaption></figure><p>Как показала атака Лоу 1996 года (<a href="Literatura.html#Lowe:1996">[64]</a>, рис.<span class="nonbreaking-interword-space"> </span><a href="11_3_Kriptosistemi_protokoli_.html#fig:key_distribution-sts-attack">11.19</a>), протокол не может гарантировать аутентификацию субъектов (цель G1), ключей (G7) и подтверждение владения сессионным ключом (G8). Хотя злоумышленник не может получить доступ к новому сессионному ключу, если протокол использовать только для аутентификации субъектов, Алиса может принять злоумышленника за Боба.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Алиса выбирает случайное число <span class="mathjax">$R_A: 2 \leq R_A \leq p-1$</span>.</li><li><span class="mathjax">$Alice \to \left\{ A, m_A = g^{R_A} \bmod p \right\} \to Mellory~(Bob)$</span></li><li><span class="mathjax">$Mellory~(Alice) \to \left\{ M, m_A \right\} \to Bob$</span></li><li>Боб выбирает случайное число <span class="mathjax">$R_B: 2 \leq R_B \leq p-1$</span> и вычисляет <span class="mathjax">$m_B = g^{R_B} \bmod p$</span>, а также сессионный ключ <span class="mathjax">$K = m_A^{R_B} \bmod p$</span>.</li><li><span class="mathjax">$Bob \to \left\{ B, M, m_B, E_K( S_B ( m_A, m_B )) \right\} \to Mellory$</span></li><li><span class="mathjax">$Mellory~(Bob) \to \left\{ B, A, m_B, E_K( S_B ( m_A, m_B )) \right\} \to Alice$</span></li><li>Алиса вычисляет сессионный ключ <span class="mathjax">$K = m_B^{R_A} \bmod p$</span>.</li><li>Алиса проверяет подпись в сообщении <span class="mathjax">$E_K( S_B ( m_A, m_B ))$</span>.</li><li><span class="mathjax">$Alice \to \left\{ A, B, E_K( S_A ( m_A, m_B ) ) \right\} \to Mellory~(Bob)$</span></li></ul></content></command><p>После успешного завершения протокола Алиса уверена, что общается с Бобом.</p><p>Как и все остальные &laquo;криптосистемы-протоколы&raquo;, протокол Station-to-Station основывается на некотором внешнем источнике информации об открытых ключах участников, не подвергая сомнению корректность и надёжность этого источника. Что, в общем случае, неверно. Если информацию о ключах участников нужно получать извне при каждом сеансе протокола (например, если участников много, и запомнить ключи всех возможности нет), то канал получения открытых ключей будет основной целью активного криптоаналитика для рассмотренных протоколов. Как от этого защититься с использованием примитивов асимметричной криптографии &ndash; в разделе<span class="nonbreaking-interword-space"> </span><a href="#section-protocols-asymmetric">11.5</a>.</p><p><a name="N102030"><!--протокол!Station-to-Station|)--></a></p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="11_2_Trehprohodnie_protokoli.html">&#129080; 11_2_Trehprohodnie_protokoli</a></li><li class="page-item"><a class="page-link" href="11_4_Shemi_s_doverennim_tsentrom.html">11_4_Shemi_s_doverennim_tsentrom &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>