<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="15_6_SQL_инъекции">15.6. SQL-инъекции</h2><p>Второй классической уязвимостью веб-приложений являются SQL-инъекции (англ. <span lang="en"><i>SQL injection</i></span>), когда пользователь имеет возможность поменять смысл запроса к базе данных веб-сервера. Запрос делается в виде текстовой строки на скриптовом языке SQL. Например, выражение</p><pre>"SELECT * FROM Users WHERE Name = '" + username + "';"</pre><p>предназначено для получения информации о пользователе, имя (логин) которого задан переменной <tt>username</tt>. Однако если пользователь вместо имени введёт строку вида</p><div style="display: flex; align-items: center; justify-content: center;"> <pre>john';  DELETE * FROM Users;  SELECT * FROM Users WHERE
  Name = 'john,</pre> </div><p>то выражение превратится в три SQL-операции:</p><pre>-- запрос о пользователе john
SELECT * FROM Users WHERE Name = 'john';
-- удаление всех пользователей
DELETE FROM Users;
-- запрос о пользователе john
SELECT * FROM Users WHERE Name = 'john';</pre><p>При выполнении этого SQL-запроса к базе данных все записи пользователей будут удалены.</p><p>Уязвимости в SQL-выражениях являются частными случаями уязвимостей, связанных с использованием сложных систем с разными языками управления данными и, следовательно, с разными системами экранирования специальных символов и контроля над типом данных. Когда веб-сервер принимает от клиента данные, закодированные обычно с помощью &laquo;application/x-www-form-urlencoded&raquo;<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#html4:1999">[87]</a>, специальные символы (пробелы, неалфавитные символы и<span class="nonbreaking-interword-space"> </span>т.&nbsp;д.) корректно экранируются браузером и восстанавливаются непосредственно веб-сервером или стандартными программными библиотеками. Аналогично, когда SQL-сервер передаёт данные клиентской библиотеке или принимает их от неё, внутренним протоколом общения с SQL-сервером происходит кодировка текста, который является частью пользовательских данных. Однако на стыке контекстов &ndash; в тот момент, когда программа, выполняющаяся на веб-сервере, уже приняла данные от пользователя по HTTP-протоколу<a name="N112322"><!--протокол!HTTP--></a> и собирается передать их SQL-серверу в качестве составной части SQL-команды &ndash; перед программистом стоит сложная задача учёта в худшем случае трёх контекстов и кодировок: входного контекста протокола общения с клиентом (HTTP), контекста языка программирования (с соответствующим оформлением и экранированием специальных символов в текстовых константах) и контекста языка управления данными SQL-сервера.</p><p>Ситуация усложняется тем, что программист может являться специалистом в языке программирования, но может быть не знаком с особенностями языка SQL или, что чаще, конкретным диалектом языка SQL, используемым СУБД.</p><p>Метод защиты заключается в <em>разделении</em> кода и данных. Для защиты от приведённых атак на базу данных следует использовать параметрические запросы к базе данных с <em>фиксированным</em> SQL-выражением. Например, в JDBC<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#jdbc:2006">[4]</a>:</p><pre>PreparedStatement p = conn.prepareStatement(
    "SELECT * FROM Users WHERE Name=?");
p.setString(1, username);</pre><p>Таким образом, задача корректного оформления текстовых данных для передачи на SQL-сервер перекладывается на драйвер общения с СУБД, в котором эта задача обычно решена корректно авторами драйвера, хорошо знающими особенности протокола и языка управления данными сервера.</p><!--%\chapter{Послесловие}--><!--%Это должно быть что-то в виде заключения, объяснения, почему именно эти темы выбраны, насколько актуален материал с теоретической и практической точки зрения.--><command name="appendix"></command><command name="renewcommand"><argument required="true"><command name="thechapter"></command></argument><argument required="true"><command name="Asbuk"><argument required="true">chapter</argument></command></argument></command><!--% использование русских букв для нумерации приложений--><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="15_5_Mezhsaytoviy_skripting.html">&#129080; 15_5_Mezhsaytoviy_skripting</a></li><li class="page-item"><a class="page-link" href="Glava_16_Matematicheskoe_prilozhenie.html">Glava_16_Matematicheskoe_prilozhenie &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>