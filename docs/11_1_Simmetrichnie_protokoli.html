<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="11_1_Симметричные_протоколы">11.1. Симметричные протоколы</h2><p>Как отмечено ранее в разделе<span class="nonbreaking-interword-space"> </span><a href="#section-protocols-classification">10.4</a> про классификацию протоколов, к симметричным будем относить те протоколы, которые используют примитивы только классической криптографии на секретных ключах. К ним относятся уже известные блочные шифры, криптографически стойкие генераторы псевдослучайных чисел (КСГПСЧ) и хеш-функции.</p><h3 data-command-name="subsection" id="11_1_1_Протокол_Wide_Mouth_Frog">11.1.1. Протокол Wide-Mouth Frog</h3><p><a name="N97831"><!--протокол!Wide-Mouth Frog|(--></a></p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-wide-mouth_frog" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A, E_A \left( T_A, B, K \right)$</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$E_B \left( T_T, A, K \right)$</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.2 &mdash; Протокол Wide-Mouth Frog</figcaption></figure><p>Протокол Wide-Mouth Frog является, возможно, самым простым протоколом с доверенным центром. Его автором считается Майкл Бэрроуз (1989 год, англ. <span lang="en"><i>Michael Burrows</i></span>, <a href="Literatura.html#Burrows:Abadi:Needham:1990">[21]</a>, <a href="11_1_Simmetrichnie_protokoli.html#fig:key_distribution-wide-mouth_frog">11.2</a>). Протокол состоит из следующих проходов.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li>Алиса генерирует новый сеансовый ключ <span class="mathjax">$K$</span></li><li><span class="mathjax">$Alice \to \{ A, E_A \left( T_A, B, K \right) \} \to Trent$</span></li><li><span class="mathjax">$Trent \to \{ E_B \left( T_T, A, K \right) \} \to Bob$</span></li></ul></content></command><p>По окончании протокола у Алисы и Боба есть общий сеансовый ключ <span class="mathjax">$K$</span>.</p><p>У данного протокола множество недостатков.</p><ul><li>Генератором ключа является инициирующий абонент. Если предположить, что Боб &ndash; это сервер, предоставляющий некоторый сервис, а Алиса &ndash; это тонкий клиент, запрашивающий данный сервис, получается, что задача генерации надёжного сессионного ключа взваливается на плечи абонента с наименьшими мощностями.</li><li>В протоколе общение с вызываемым абонентом происходит через доверенный центр. Как следствие, второй абонент может стать мишенью для DDOS-атаки с отражением (англ. <span lang="en"><i>distributed denial-of-service attack</i></span>), когда злоумышленник будет посылать пакеты на доверенный центр, а тот формировать новые пакеты и посылать их абоненту. Если абонент подключён к нескольким сетям (с несколькими доверенными центрами), это позволит злоумышленнику вывести абонента из строя. Хотя защититься от подобной атаки достаточно просто, настроив соответствующим образом доверенный центр.</li></ul><p>Однако самой серьёзной проблемой протокола является возможность применения следующих атак.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-wide-mouth_frog-Anderson-Needham-attack" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Eva</argument><argument required="true">Eva</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$  A, E_A \left( T_A, B, K \right) $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_B \left( T_T, A, K \right) $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Eva</argument><argument required="true"><span class="mathjax">$ B, E_B \left( T_T, A, K \right) $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_A \left( T'_T, B, K \right) $</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Eva</argument><argument required="true"><span class="mathjax">$ A, E_A \left( T'_T, B, K \right) $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_B \left( T''_T, A, K \right) $</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.3 &mdash; Атака Роса Андерсона и Роджера Нидхема на протокол &laquo;Wide-Mouth Frog&raquo;</figcaption></figure><p>В 1995 году Рос Андерсон и Роджер Нидхем (англ. <span lang="en"><i>Ross Anderson, Roger Needham</i></span>, <a href="Literatura.html#Anderson:Needham:1995">[5]</a>, рис<span class="nonbreaking-interword-space"> </span><a href="11_1_Simmetrichnie_protokoli.html#fig:key_distribution-wide-mouth_frog-Anderson-Needham-attack">11.3</a>) предложили вариант атаки на протокол, при котором злоумышленник (Ева) может бесконечно продлевать срок действия конкретного сеансового ключа. Идея атаки в том, что после окончания протокола злоумышленник будет посылать доверенному центру назад его же пакеты (перехваченные ранее), дополняя их идентификаторами якобы инициирующего абонента.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$Alice \to \{ A, E_A \left( T_A, B, K \right) \} \to Trent$</span></li><li><span class="mathjax">$Trent \to \{ E_B \left( T_T, A, K \right) \} \to Bob$</span></li><li><span class="mathjax">$Eva \to \{ B, E_B \left( T_T, A, K \right) \} \to Trent$</span></li><li><span class="mathjax">$Trent \to \{ E_A \left( T'_T, B, K \right) \} \to Alice$</span></li><li><span class="mathjax">$Eva \to \{ A, E_A \left( T'_T, B, K \right) \} \to Trent$</span></li><li><span class="mathjax">$Trent \to \{ E_B \left( T''_T, A, K \right) \} \to Bob$</span></li><li>Повторять проходы 3 и 5, пока не пройдёт время, нужное для получения <span class="mathjax">$K$</span>.</li></ul></content></command><p>С точки зрения доверенного центра, шаги 1, 3 и 5 являются корректными пакетами, инициирующими общение абонентов между собой. Метки времени в них корректны (если Ева будет успевать вовремя эти пакеты посылать). С точки зрения легальных абонентов каждый из пакетов является приглашением другого абонента начать общение. В результате произойдёт две вещи:</p><ul><li>Каждый из абонентов будет уверен, что закончился протокол создания нового сеансового ключа, что второй абонент успешно аутентифицировал себя перед доверенным центром. И что для установления следующего сеанса связи будет использоваться новый (на самом деле &ndash; старый) ключ <span class="mathjax">$K$</span>.</li><li>После того, как пройдёт время, нужное злоумышленнику Еве для взлома сеансового ключа <span class="mathjax">$K$</span>, Ева сможет и читать всю переписку, проходящую между абонентами, и успешно выдавать себя за обоих из абонентов.</li></ul><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-wide-mouth_frog-lowe-attack" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Eva</argument><argument required="true">Eva</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A, E_A \left( T_A, B, K \right) $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_B \left( T_T, A, K \right) $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Eva</argument><argument required="true"><span class="mathjax">$ E_B \left( T_T, A, K \right) $</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.4 &mdash; Атака Лоу на протокол &laquo;Wide-Mouth Frog&raquo;</figcaption></figure><p>Вторая атака 1997 года Гэвина Лоу (англ. <span lang="en"><i>Gavin Lowe</i></span>, <a href="Literatura.html#Lowe:1997">[63]</a>, рис.<span class="nonbreaking-interword-space"> </span><a href="11_1_Simmetrichnie_protokoli.html#fig:key_distribution-wide-mouth_frog-lowe-attack">11.4</a>) проще в реализации. В результате этой атаки Боб уверен, что Алиса аутентифицировала себя перед доверенным центром и хочет начать второй сеанс общения. Что, конечно, не является правдой, так как второй сеанс инициирован злоумышленником.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$Alice \to \{ A, E_A \left( T_A, B, K \right) \} \to Trent$</span></li><li><span class="mathjax">$Trent \to \{ E_B \left( T_T, A, K \right) \} \to Bob$</span></li><li><span class="mathjax">$Eva \to \{ E_B \left( T_T, A, K \right) \} \to Bob$</span></li></ul></content></command><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-wide-mouth_frog-Lowe-modification" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>

		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$  A, E_A \left( T_A, B, K \right) $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_B \left( T_T, A, K \right) $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ E_K \left( R_B \right) $</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ E_K \left( R_B + 1 \right) $</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.5 &mdash; Модификация Гэвина Лоу протокола &laquo;Wide-Mouth Frog&raquo;</figcaption></figure><p>В той же работе Лоу предложил модификацию протокола, вводящую явную взаимную аутентификацию абонентов с помощью случайной метки <span class="mathjax">$R_B$</span> и проверки, что Алиса может расшифровать пакет с меткой, зашифрованной общим сеансовым ключом абонентов <span class="mathjax">$K$</span> (рис.<span class="nonbreaking-interword-space"> </span><a href="11_1_Simmetrichnie_protokoli.html#fig:key_distribution-wide-mouth_frog-Lowe-modification">11.5</a>). Однако данная модификация приводит к тому, что протокол теряет своё самое главное преимущество перед другими протоколами &ndash; простоту.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$Alice \to \{ A, E_A \left( T_A, B, K \right) \} \to Trent$</span></li><li><span class="mathjax">$Trent \to \{ E_B \left( T_T, A, K \right) \} \to Bob$</span></li><li><span class="mathjax">$Bob \to \{ E_K \left( R_B \right) \} \to Alice$</span></li><li><span class="mathjax">$Alice \to \{ E_K \left( R_B + 1 \right) \} \to Bob$</span></li></ul></content></command><p><a name="N98568"><!--протокол!Wide-Mouth Frog|)--></a></p><h3 data-command-name="subsection" id="11_1_2_Протокол_Yahalom">11.1.2. Протокол Yahalom</h3><p><a name="N98589"><!--протокол!Yahalom|(--></a></p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-yahalom" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$A$</span>, <span class="mathjax">$R_A$</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ B, E_B( A, R_A, R_B ) $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_A( B, K, R_A, R_B )$</span>, <span class="mathjax">$E_B(A, K) $</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$E_B( A, K )$</span>, <span class="mathjax">$E_K( R_B )$</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.6 &mdash; Протокол Yahalom</figcaption></figure><p>Протокол Yahalom можно рассматривать как улучшенную версию протокола Wide-Mouth Frog<a name="N98719"><!--протокол!Wide-Mouth Frog--></a> из раздела<span class="nonbreaking-interword-space"> </span><a href="#section-protocols-wide-moth-frog">11.1.1</a>. Данный протокол &laquo;перекладывает&raquo; генерацию нового сессионного ключа на сторону доверенного центра, а также использует случайные числа для защиты от атак повтором.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$Alice \to \{ A, R_A \} \to Bob$</span></li><li><span class="mathjax">$Bob \to \{ B, E_B( A, R_A, R_B ) \} \to Trent$</span></li><li>Трент генерирует новый сессионный ключ <span class="mathjax">$K$</span></li><li><span class="mathjax">$Trent \to \{ E_A( B, K, R_A, R_B ), E_B(A, K) \} \to Alice$</span></li><li><span class="mathjax">$Alice \to \{ E_B( A, K ), E_K( R_B ) \} \to Bob$</span></li></ul></content></command><p>После того, как Боб провалидирует число <span class="mathjax">$R_B$</span>, присланное Алисой, стороны смогут использовать новый сессионный ключ <span class="mathjax">$K$</span>. Протокол, кроме генерации ключа, обеспечивает взаимную аутентификацию сторон:</p><ul><li>Аутентификация Алисы перед Бобом происходит на 4-м проходе, когда Боб может провалидировать возможность Алисы зашифровать известное только ей (и Тренту) случайное число <span class="mathjax">$R_B$</span> на ключе <span class="mathjax">$K$</span>.</li><li>Аутентификация Боба перед Алисой происходит на 3-м проходе, когда Трент демонстрирует Алисе, что он получил случайное число <span class="mathjax">$R_A$</span> именно от Боба.</li></ul><p>Нужно отметить (<a href="Literatura.html#Zhou:Yu:Pan:Wang:2016">[3]</a>), что в рамках протокола Боб никак не продемонстрировал, что он успешно получил новый сессионный ключ <span class="mathjax">$K$</span> и может им оперировать (не выполнена цель G8). Сообщение от Алисы на 4-м проходе могло быть перехвачено или модифицировано злоумышленником. Но никакого ответа Алиса от Боба уже не ожидает и уверена, что протокол завершился успешно.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-yahalom-attack" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$A$</span>, <span class="mathjax">$R_{A2}$</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ B, E_B( A, R_{A2}, R_{B2} ) $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_A( B, K_2, R_{A2}, R_{B2} )$</span>, <span class="mathjax">$E_B(A, K_2) $</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$E_B( A, K_1 )$</span>, <span class="mathjax">$E_{K_1}( R_{B2} )$</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.7 &mdash; Атака на протокол Yahalom</figcaption></figure><p>Также на 3-м проходе Трент не включает случайное число <span class="mathjax">$R_B$</span> в сообщение <span class="mathjax">$E_B(A, K)$</span>, что позволяет Алисе, действуя не из лучших побуждений, заставить Боба принять старый сессионный ключ (рис.<span class="nonbreaking-interword-space"> </span><a href="11_1_Simmetrichnie_protokoli.html#fig:key_distribution-yahalom-attack">11.7</a>).</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$Alice \to \{ A, R_A \} \to Bob$</span></li><li><span class="mathjax">$Bob \to \{ B, E_B( A, R_A, R_B ) \} \to Trent$</span></li><li>Трент генерирует новый сессионный ключ <span class="mathjax">$K_2$</span></li><li><span class="mathjax">$Trent \to \{ E_A( B, K, R_A, R_B ), E_B(A, K_2) \} \to Alice$</span></li><li>Алиса использует старый сессионный ключ <span class="mathjax">$K_1$</span> и сообщение <span class="mathjax">$E_B( A, K_1 )$</span> из старого сеанса протокола</li><li><span class="mathjax">$Alice \to \{ E_B( A, K_1 ), E_{K_2}( R_B ) \} \to Bob$</span></li></ul></content></command><p>Протокол Yahalom послужил основной большому количеству научных работ, связанных с автоматизированным анализом стойкости криптографических протоколов и имел несколько &laquo;улучшенных&raquo; вариантов. Однако о широком использовании данного протокола в реальных информационных системах неизвестно.</p><p><a name="N98984"><!--протокол!Yahalom|)--></a></p><h3 data-command-name="subsection" id="11_1_3_Протокол_Нидхема_Шрёдера">11.1.3. Протокол Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера</h3><p><a name="N99011"><!--протокол!Нидхема—Шрёдера|(--></a></p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-needham-schroeder" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>
		
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$A, B, R_A$</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_A \left( R_A, B, K, E_B \left( K, A \right) \right) $</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ E_B \left( K, A \right) $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$E_K \left( R_B \right)$</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$E_K \left( R_B - 1 \right)$</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.8 &mdash; Протокол Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера</figcaption></figure><p>Протокол Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера (англ. <span lang="en"><i>Roger Needham, Michael Shroeder</i></span>, 1979,<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Needham:Schroeder:1978">[79]</a>, рис.<span class="nonbreaking-interword-space"> </span><a href="11_1_Simmetrichnie_protokoli.html#fig:key_distribution-needham-schroeder">11.8</a>) похож на модифицированный протокол &laquo;Wide-Mouth Frog&raquo;, но отличается тем, что доверенный центр (Трент) во время работы основной части протокола не общается со вторым абонентом. Первый абонент получает от доверенного центра специальный пакет, который он без всякой модификации отправляет второму абоненту.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$ Alice	\to \{ A, B, R_A \}						\to Trent $</span></li><li><span class="mathjax">$ Trent	\to \{ E_A \left( R_A, B, K, E_B \left( K, A \right) \right) \}	\to Alice $</span></li><li><span class="mathjax">$ Alice	\to \{ E_B \left( K, A \right) \}				\to Bob $</span></li><li><span class="mathjax">$ Bob	\to \{ E_K \left( R_B \right) \}				\to Alice $</span></li><li><span class="mathjax">$ Alice	\to \{ E_K \left( R_B - 1 \right) \}				\to Bob $</span></li></ul></content></command><p>Протокол удобен с точки зрения сетевого взаимодействия. И общение с доверенным центром, и с конечным участником (Бобом) начинается только по инициативе первого участника (Алисы). При возникновении любых проблем передачи пакетов их видит именно то лицо, которое заинтересованно в получении ключей и доступов</p><command name="footnote"><argument required="true">Сравните с протоколом &laquo;Yahalom&raquo;, в котором при возникновении проблемы общения Трента и Алисы на третьем проходе Тренту потребовалось бы уведомить об этом Боба, а Бобу, в свою очередь, Алису.</argument></command><p>. И если бы общение шло с использование протокола TCP/IP, потребовалось бы всего 2 сессии протокола TCP для выработки ключа. Причём последнюю сессию можно не закрывать, а использовать для дальнейшего взаимодействия уже с ключом <span class="mathjax">$K$</span>.</p><p>Протокол обеспечивает и двустороннюю аутентификацию сторон, и, казалось бы, защиту от атак с повторной передачей (англ. <span lang="en"><i>replay attack</i></span>). Последнее делается с помощью введения уже известных по модифицированному протоколу &laquo;Wide-Mouth Frog&raquo; случайных меток <span class="mathjax">$R_A$</span> и <span class="mathjax">$R_B$</span>. Действительно, без знания ключа злоумышленник не сможет выдать себя за Алису перед Бобом (так как не сможет расшифровать пакет с зашифрованной меткой <span class="mathjax">$R_B$</span>).</p><p>Относительно мелкий недостаток протокола в том, что во втором пакете доверенный центр в зашифрованном виде передаёт <span class="mathjax">$E_B \left( K, A \right)$</span>, что потом сразу в следующем, в третьем шаге пересылается по открытому каналу от Алисы к Бобу. Отказ от бессмысленного повторного шифрования чуть уменьшит нагрузку на вычислительные ресурсы доверенного центра.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-needham-schroeder-attack" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Eva</argument><argument required="true">Eva</argument></command>
		<command name="newinst"><argument required="false">1</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>

		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ E_B \left( K, A \right) $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ E_K \left( R_B \right)$</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$E_K \left( R_B - 1 \right)$</span></argument><argument required="true">Bob</argument></command>

		<command name="callself"><argument required="true">callself</argument><argument required="true">Eva</argument><argument required="true">получение ключа K</argument><argument required="true"></argument><content></content></command>
		<command name="mess"><argument required="true">Eva</argument><argument required="true"><span class="mathjax">$ E_B \left( K, A \right) $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ E_K \left( R_B \right) $</span></argument><argument required="true">Eva</argument></command>
		<command name="mess"><argument required="true">Eva</argument><argument required="true"><span class="mathjax">$ E_K \left( R_B - 1 \right) $</span></argument><argument required="true">Bob</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.9 &mdash; Атаки с известным сеансовым ключом на протокол Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера</figcaption></figure><p>Но серьёзный недостаток связан с уязвимостью протокола к атаке с известным сеансовым ключом. Если злоумышленник сумеет в какой-то момент времени получить ранее использованный сессионный ключ <span class="mathjax">$K$</span>, он сможет убедить Боба, что он является Алисой, и что это новый сессионный ключ. Для этого ему понадобится переданный ранее по открытому каналу пакет из пункта 3 протокола (рис.<span class="nonbreaking-interword-space"> </span><a href="11_1_Simmetrichnie_protokoli.html#fig:key_distribution-needham-schroeder-attack">11.9</a>).</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$ Eva \to \{ A, B, R_A \} \to Trent $</span></li><li><span class="mathjax">$ Trent \to \{ E_A \left( R_A, B, K, E_B \left( K, A \right) \right) \}	\to Alice $</span></li><li><span class="mathjax">$ Alice \to \{ E_B \left( K, A \right) \} \to Bob $</span></li><li><span class="mathjax">$ Bob \to \{ E_K \left( R_B \right) \} \to Alice $</span></li><li><span class="mathjax">$ Alice \to \{ E_K \left( R_B - 1 \right) \} \to Bob $</span></li></ul></content></command><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$\dots$</span> по прошествии некоторого времени <span class="mathjax">$\dots$</span></li><li><span class="mathjax">$ Eva~(Alice) \to \{ E_B \left( K, A \right) \} \to Bob $</span></li><li><span class="mathjax">$ Bob \to \{ E_K \left( R_B \right) \} \to Eva~(Alice) $</span></li><li><span class="mathjax">$ Eva (Alice) \to \{ E_K \left( R_B - 1 \right) \} \to Bob $</span></li></ul></content></command><p>Если в протокол Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера добавить метки времени, тем самым ограничив время возможного использования сессионного ключа, а также исправить мелкий недостаток с двойным шифрованием, можно получить протокол, который лежит в основе распространённого средства аутентификации &laquo;Kerberos&raquo; для локальных сетей.</p><p><a name="N99513"><!--протокол!Нидхема—Шрёдера|)--></a></p><h3 data-command-name="subsection" id="11_1_4_Протокол_Kerberos_">11.1.4. Протокол &laquo;Kerberos&raquo;</h3><p><a name="N99540"><!--протокол!Kerberos|(--></a>
В данном разделе будет описан протокол аутентификации сторон с единственным доверенным центром. Сетевой протокол &laquo;Ker<wbr></wbr>be<wbr></wbr>ros&raquo; использует эти идеи при объединении нескольких доверенных центров в единую сеть для обеспечения надёжности и отказоустойчивости. Подробнее о сетевом протоколе &laquo;Kerberos&raquo; смотрите в разделе<span class="nonbreaking-interword-space"> </span><a href="#sec:kerberos">13.1</a>.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "><a name="fig:key_distribution-kerberos" style="vertical-align: top; align-self: start;"></a><command name="sequencediagram"><argument required="true">sequencediagram</argument><content>
		<command name="newinst"><argument required="true">Alice</argument><argument required="true">Alice</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Trent</argument><argument required="true">Trent</argument></command>
		<command name="newinst"><argument required="false">2.5</argument><argument required="true">Bob</argument><argument required="true">Bob</argument></command>

		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ A, B $</span></argument><argument required="true">Trent</argument></command>
		<command name="mess"><argument required="true">Trent</argument><argument required="true"><span class="mathjax">$ E_A \left( T_T, L, K, B \right), E_B \left( T_T, L, K, A \right) $</span></argument><argument required="true">Alice</argument></command>
		<command name="mess"><argument required="true">Alice</argument><argument required="true"><span class="mathjax">$ E_B \left( T_T, L, K, A \right), E_K \left( A, T_A \right) $</span></argument><argument required="true">Bob</argument></command>
		<command name="mess"><argument required="true">Bob</argument><argument required="true"><span class="mathjax">$ E_K \left( T_T + 1 \right) $</span></argument><argument required="true">Alice</argument></command>
	</content></command><figcaption style="flex-basis: 100%; text-align: center;">Рис. 11.10 &mdash; Протокол &laquo;Kerberos&raquo;</figcaption></figure><p>Как и в протоколе Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера, инициирующий абонент (Алиса) общается только с выделенным доверенным центром, получая от него два пакета с зашифрованным сессионным ключом &ndash; один для себя, а второй &ndash; для вызываемого абонента (Боба). Однако в отличие от Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера<a name="N99680"><!--протокол!Нидхема—Шрёдера--></a> в рассматриваемом протоколе зашифрованные пакеты содержат также метку времени <span class="mathjax">$T_T$</span> и срок действия сессионного ключа <span class="mathjax">$L$</span> (от англ. <span lang="en"><i>lifetime</i></span> &ndash; срок жизни). Что позволяет, во-первых, защититься от рассмотренной в предыдущем разделе атаки повтором. А, во-вторых, позволяет доверенному центру в некотором смысле управлять абонентами, заставляя их получать новые сессионные ключи по истечению заранее заданного времени <span class="mathjax">$L$</span>.</p><!--%--><command name="samepage"><argument required="true">samepage</argument><content><!--%--><command name="@beginparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><command name="@endparpenalty"></command>=<command name="@lowpenalty"></command><!--%--><ul><li><span class="mathjax">$ Alice \to \{ A, B \} \to Trent $</span></li><li><span class="mathjax">$ Trent \to \{ E_A \left( T_T, L, K, B \right), E_B \left( T_T, L, K, A \right) \} \to Alice $</span></li><li><span class="mathjax">$ Alice \to \{ E_B \left( T_T, L, K, A \right), E_K \left( A, T_A \right) \} \to Bob $</span></li><li><span class="mathjax">$ Bob \to \{ E_K \left( T_T + 1 \right) \} \to Alice $</span></li></ul></content></command><p>Обратите внимание, что на третьем проходе за счёт использования метки времени от доверенного центра <span class="mathjax">$T_T$</span> вместо случайной метки от Боба <span class="mathjax">$R_B$</span> позволяет сократить количество проходов на один по сравнению с протоколом Нидхема<span class="nonbreaking-interword-space"> </span>&mdash;<span class="nonbreaking-interword-space"> </span>Шрёдера<a name="N99756"><!--протокол!Нидхема—Шрёдера--></a>. Также наличие метки времени делает ненужным и предварительную генерацию случайной метки Алисой и её передачу на первом шаге.</p><p>Метка времени <span class="mathjax">$T_A$</span> в сообщении <span class="mathjax">$E_K \left( A, T_A \right)$</span> позволяет Бобу убедиться, что Алиса владеет текущим сессионным ключом <span class="mathjax">$K$</span>. Если расшифрованная метка <span class="mathjax">$T_A$</span> сильно отличается от текущего времени, значит либо этот пакет из другого сеанса протокола, либо не от Алисы вообще.</p><p>Пакеты <span class="mathjax">$E_A \left( T_T, L, K, B \right)$</span> и <span class="mathjax">$E_B \left( T_T, L, K, A \right)$</span> одинаковы по своему формату. В некотором смысле их можно назвать сертификатами сессионного ключа для Алисы и Боба. Причём все подобные пары пакетов можно сгенерировать заранее (например, в начале дня), выложить на общедоступный ресурс, предоставить в свободное использование и выключить доверенный центр (он своё дело уже сделал &ndash; сгенерировав эти пакеты). И до момента времени <span class="mathjax">$T_T + L$</span> этими &laquo;сертификатами&raquo; можно пользоваться. Но только если вы являетесь одной из допустимых пар абонентов. Конечно, эта идея непрактична &ndash; ведь количество таких пар растёт как квадрат от числа абонентов. Однако интересен тот факт, что подобные пакеты можно сгенерировать заранее. Эта идея нам пригодится при рассмотрении инфраструктуры открытых ключей (англ. <span lang="en"><i>public key infrastructure, PKI</i></span>).</p><p><a name="N99800"><!--протокол!Kerberos|)--></a></p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="Glava_11_Rasprostranenie_kljuchey.html">&#129080; Glava_11_Rasprostranenie_kljuchey</a></li><li class="page-item"><a class="page-link" href="11_2_Trehprohodnie_protokoli.html">11_2_Trehprohodnie_protokoli &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>