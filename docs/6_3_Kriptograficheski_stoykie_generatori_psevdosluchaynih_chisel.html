<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="6_3_Криптографически_стойкие_генераторы_псевдослучайных_чисел">6.3. Криптографически стойкие генераторы псевдослучайных чисел</h2><p><a name="N87116"><!--генератор!криптографически-стойкий--></a>
Итак, просто генератором псевдослучайных чисел мы называем функцию <span class="mathjax">$g$</span> вида</p><div class="mathjax" style="text-align: center;">$$g: \left\{0, 1\right\}^{n} \to \left\{0, 1\right\}^{q\left(n\right)},$$</div><p>вычислимую за полиномиальное время, результатом работы которой является последовательность чисел, обладающая свойствами случайной.</p><p>Были рассмотрены два генератора (линейный конгруэнтный генератор в разделе<span class="nonbreaking-interword-space"> </span><a href="#section-linear-congruential-generator">6.1</a> и генератор на основе РСЛОС в разделе<span class="nonbreaking-interword-space"> </span><a href="#section-lfsr">6.2</a>). Однако они обладают фундаментальными недостатками, которые не дают использовать их в криптографии. Зная определённое число предыдущих значений выхода генератора (и его внутреннее устройство), криптоаналитик имеет возможность предсказать следующие элементы последовательности. Избежать этого можно только увеличением размера внутреннего состояния.</p><p>Пусть <span class="mathjax">$b \left( g \right)$</span> &ndash; число предыдущих бит, которые необходимо знать криптоаналитику для восстановления внутреннего состояния и параметров генератора (и, следовательно, для предсказания дальнейшей последовательности). И для линейного конгруэнтного генератора</p><command name="footnote"><argument required="true">Для получения параметров <tt>a</tt> и <tt>c</tt>.</argument></command><p>, и для генератора на основе РСЛОС функция <span class="mathjax">$b (g)$</span> является линейной функцией от размера внутреннего состояния <span class="mathjax">$size\left( g \right)$</span> в битах:</p><div class="mathjax" style="text-align: center;">$$\begin{array}{l}
	b \left( LCG \right) = 3 \cdot size\left( g \right), \\
	b \left( LFSR \right) = 2 \cdot size\left( g \right). \\
\end{array}$$</div><p>То есть, если мы решим увеличить размер внутреннего состояния для защиты от криптоаналитика, это приведёт не более чем к линейному росту затрат последнего на необходимые вычисления (сравните это с экспоненциальным ростом затрат криптоаналитика при увеличении размера ключа для блочных шифров). Поэтому для использования в криптографии к генераторам псевдослучайных чисел предъявляются дополнительные требования.</p><p><em>Криптографически стойким генератором псевдослучайных чисел</em> будем называть функцию <span class="mathjax">$g$</span> вида</p><div class="mathjax" style="text-align: center;">$$g: \left\{0, 1\right\}^{n} \to \left\{0, 1\right\}^{q\left(n\right)},$$</div><p>вычислимую за полиномиальное время, результатом работы которой является последовательность чисел, удовлетворяющая тесту на следующий бит: не должно существовать полиномиального алгоритма, который по <span class="mathjax">$k$</span> битам последовательности будет предсказывать следующий с вероятностью более <span class="mathjax">$1/2$</span>.</p><p>В 1982 году Эндрю Яо (англ. <span lang="en"><i>Andrew Chi-Chih Yao</i></span>,<span class="nonbreaking-interword-space"> </span><a href="Literatura.html#Yao:1982">[111]</a>) доказал, что любой генератор, проходящий тест на следующий бит, сможет пройти и любые другие статистические полиномиальные тесты на случайность.</p><p>Как и в случае с блочными шифрами, да и с криптографией вообще, под криптографической стойкостью конкретных алгоритмов в 99 случаев стоит понимать не принципиальное отсутствие, а неизвестность конкретных алгоритмов, которые могут предсказать выход генератора за полиномиальное время. Для тех генераторов, которые считались криптографически стойкими 20 лет назад, сегодня могут уже существовать алгоритмы для предсказания следующего элемента последовательности.</p><h3 data-command-name="subsection" id="6_3_1_Генератор_BBS">6.3.1. Генератор BBS</h3><p>Имеются примеры &laquo;хороших&raquo; генераторов, вырабатывающих криптографически стойкие последовательности, например генератор Blum-Blum-Shub (BBS). Алгоритм работы состоит в следующем: выбирают большие (длиной не менее 512 бит) простые числа<a name="N87225"><!--число!простое--></a> <span class="mathjax">$p, q$</span>, которые при делении на <span class="mathjax">$4$</span> дают в остатке <span class="mathjax">$3$</span>. Вычисляют <span class="mathjax">$n = p q$</span>, с помощью генератора случайных чисел вырабатывают число <span class="mathjax">$x_{0}$</span>, где <span class="mathjax">$1 \leq x_0 \leq n-1$</span> и <span class="mathjax">$\gcd(x_0, n) = 1$</span>. Далее проводят следующие вычисления:</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
        x_{1} = x_{0}^{2} \mod n,\\
        x_{2} = x_{1}^{2} \mod n,\\
        \dots,\\
        x_{N} = x_{N-1}^{2} \mod n.
\end{array} $$</div><p>Для каждого вычисленного значения оставляют один младший разряд. Вычисляют двоичную псевдослучайную последовательность <span class="mathjax">$k_1, k_2, k_3, \dots$</span> :</p><div class="mathjax" style="text-align: center;">$$ \begin{array}{l}
        k_{1} = x_{1} \mod 2,\\
        k_{2} = x_{2} \mod 2,\\
        \dots,\\
        k_{N} = x_{N} \mod 2.
\end{array} $$</div><p>Число <span class="mathjax">$a$</span> называется <em>квадратичным вычетом</em> по модулю <span class="mathjax">$n$</span>, если для него существует квадратный корень <span class="mathjax">$b$</span> (или два корня): <span class="mathjax">$a = b^2 \mod n$</span>. Для <span class="mathjax">$p,q ~=~ 3 \mod 4$</span> верно утверждение, что квадратичный вычет имеет единственный корень, и операция <span class="mathjax">$x \rightarrow x^2 \mod n$</span>, применённая к элементам множества всех квадратичных вычетов <span class="mathjax">${\mathbb{QR}}_n$</span> по модулю <span class="mathjax">$n$</span>, является перестановкой множества <span class="mathjax">${\mathbb{QR}}_n$</span>.</p><p>Полученная последовательность <span class="mathjax">$x_1, x_2, x_3, \dots$</span> квадратичных вычетов &ndash; периодическая (<span class="mathjax">$T &lt; |{\mathbb{QR}}_n|$</span>). Чтобы её период для случайного <span class="mathjax">$x_0$</span> с большой вероятностью оказался большим, числа <span class="mathjax">$p,q$</span> выбирают с условием малого <span class="mathjax">$\gcd(\varphi(p-1), \varphi(q-1))$</span>, где <span class="mathjax">$\varphi(n)$</span> &ndash; функция Эйлера.</p><p>Полученная последовательность ключей является криптографически стойкой. Доказано, что для &laquo;взлома&raquo; (то есть определения следующего символа с вероятностью, большей <span class="mathjax">$\frac{1}{2}$</span>) требуется разложить число <span class="mathjax">$n=pq$</span> на множители. Разложение числа на множители считается трудной задачей, все известные алгоритмы не являются полиномиальными по <span class="mathjax">$\log_2 n$</span>.</p><p>Оказывается, что если вместо одного последнего бита <span class="mathjax">$k_i = x_i \mod 2$</span> брать <span class="mathjax">$O(\log_2 \log_2 n)$</span> последних битов рассмотренного выше генератора <span class="mathjax">$x_i$</span>, то полученная последовательность останется криптостойкой.</p><p>Большим недостатком генератора BBS является малая скорость генерирования битов.</p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="6_2_Registr_sdviga_s_lineynoy_obratnoy_svjazju.html">&#129080; 6_2_Registr_sdviga_s_lineynoy_obratnoy_svjazju</a></li><li class="page-item"><a class="page-link" href="6_4_KSGPSCh_na_osnove_RSLOS.html">6_4_KSGPSCh_na_osnove_RSLOS &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>