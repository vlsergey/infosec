<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="8_7_Когда_вредно_хешировать">8.7. Когда вредно хешировать</h2><p>Надёжная криптографическая хеш-функция обеспечивает преобразование открытого текста в текст заданной длины. При этом обеспечивается &laquo;стойкость&raquo;: сложность в восстановлении первого и второго прообразов. Или, говоря простым языком про первое свойство, сложность получения такого текста, значение хеш-функции для которого будет равно заданному.</p><p>Под <em>сложностью</em> восстановления понимается тот факт, что для нахождения первого прообраза надёжной криптографической хеш-функции требуется совершить в среднем не менее <span class="mathjax">$2^{n-1}$</span> операций хеширования, где <span class="mathjax">$n$</span> &ndash; количество бит в выходе криптографической хеш-функции. Взяв современную хеш-функцию с большим размером выхода (начиная от 256 бит) разработчик информационной системы уверен, что восстановить исходные данные по значению хеш-функции нельзя. Чаще всего он прав.</p><p>Но есть важный набор случаев, когда несмотря на надёжность хеш-функции восстановление прообраза или даже исходного текста не представляет проблемы. Это случай, когда использовать хеш-функцию бессмысленно. Это случай, когда <em>количество вариантов исходного текста поддаётся перебору</em>.</p><p>Пример: <em>номер телефона</em>. Разных номеров телефона с префиксом &laquo;+7&raquo; и 10 цифрами составляет <span class="mathjax">$10^{10} \approx 2^{33}$</span>. Современные вычислительные устройства, оптимизированные для перебора значений хеш-функций перебирают миллионы хешей в секунду. Значит подсчёт значений хеш-функций для всех возможных номеров телефонов с префиксом составит не более нескольких секунд.</p><p>Пример: <em>номер кредитной карты</em> (PAN, англ. <span lang="en"><i>payment card number</i></span>). Часто номер карты маскируют, открывая первые 4 (6) и/или последние 4 цифры, а остальные скрывая. Всего цифр на карте 16. Можно ли хешировать номера карт с целью скрыть их от злоумышленника? Нет. Если злоумышленник получил 8 цифр из 16 (первые 4 и последние 4), а также значение хеш-функции от полного номера карты, то восстановить полный номер он сможет менее чем за секунду. Для этого ему потребуется перебрать всего <span class="mathjax">$10^{8} \approx 2^{26}$</span> вариантов номера.</p><p>Интересен пример с <em>адресом электронной почты</em>. Казалось бы, что по значению надёжной хеш-функции невозможно восстановить оригинальный адрес. Количество разных вариантов из 8 латинских букв и 10 цифр уже даёт <span class="mathjax">$36^8 \approx 2^{41}$</span> вариантов названий почтовых ящиков без учёта разных доменов почтовых служб (<tt></tt>mail.ru, <tt></tt>gmail.com, etc.). До 2006 года работал проект "Blue Frog" (&laquo;голубая лягушка&raquo;), который предлагал своим пользователям защиту от спама. Он использовал автоматическое уведомление провайдеров о рассылаемом с их серверов спаме, что заставляло распространителей рекламы отказаться от рассылки спама как минимум на те адреса, которые являлись участниками проекта. Чтобы понять, принадлежит ящик участнику или нет, распространялся файл со списком значений криптографической хеш-функции от каждого адреса почтового ящика участника.</p><p>Предполагалось, что спамеры проверят каждый свой адрес для рассылки рекламы по этому списку и исключат найденные совпадения. Однако наличие файла со значениями хеш-функции позволило злоумышленникам сделать ровно наоборот: идентифицировать именно участников проекта и направить на них усиленные потоки бессмысленных сообщений с целью отказаться от использования проекта "Blue Frog". Через некоторое время после этой атаки (а также других, в том числе DDoS-атак<a name="N90462"><!--атака!«отказ в обсулижвании»!распределённая--></a> на сервера) проект прекратил свою работу.</p><p>Как и прежде, использование любой соли, которая поставляется вместе со значением хеш-функции, не влияет на время перебора (но по прежнему защищает от атаки по словарю<a name="N90468"><!--атака!по словарю--></a>).</p><p>Возможные решения для описанных случаев.</p><ul><li>Хешировать не сами значения, а конкатенацию исходного значения и некоторого секрета, который хранится отдельно. Например, не в таблице базы данных (вместе со значениями хеш-функций), а в конфигурации сервера приложений. С аналогичным успехом вместо хеширования можно использовать функцию блочного шифрования на некотором секретном ключе.</li><li>Использовать такие криптографические хеш-функции, которые являются не только надёжными, но и медленными в вычислении. Как для криптоаналитика, так и для легального пользователя. Примером таких функций являются <span lang="en">PBKDF2, bcrypt, scrypt, Argon2</span>, для которых при вызове функции мы дополнительно указываем количество итераций хеширования. Однако если увеличение длины выхода хеш-функции всего на один бит (из 256 или 512) увеличивает сложность атаки криптоаналитика на двоичный порядок (в два раза), то увеличение количества итераций для хеш-функции PBKDF2 в два раза увеличит сложность атак также только в два раза. То есть получение значения хеш-функции даже легальным пользователем становится затратно с точки зрения вычислительных ресурсов и затраченной энергии.</li></ul><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="8_6_Kollizii_v_hesh_funktsijah.html">&#129080; 8_6_Kollizii_v_hesh_funktsijah</a></li><li class="page-item"><a class="page-link" href="8_8_Blockchain_tsepochka_blokov_.html">8_8_Blockchain_tsepochka_blokov_ &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>