\documentclass[10pt,a4paper]{book}
%\documentclass[12pt,report,russian]{ncc}
%\usepackage{a4wide}
\usepackage{cmap}                       % Поддержка поиска русских слов в PDF (pdflatex)
\usepackage{pscyr}
\usepackage[math]{pscyr} % PSCyr ЗАГРУЖАТЬ ПЕРЕД inputenc и babel!!!
%\usepackage[T1, T2A]{fontenc}
\usepackage[X2,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}                % Красная строка в первом абзаце
%\usepackage{misccorr}
%Может быть установлено 8pt, 9pt, 10pt, 11pt, 12pt, 14pt, 17pt, and 20pt
%\usepackage[12pt]{extsizes}
%\usepackage[mag=1000,a4paper,left=3cm,right=2cm,top=2cm,bottom=2cm,noheadfoot]{geometry}

\usepackage{amsfonts, amsmath, eucal, bm, amssymb, graphicx, color, mathabx}
\usepackage{algorithm, algorithmic}     % 'algorithm' environments
\floatname{algorithm}{Алгоритм}
\usepackage{multirow}                   % multirow cells in tables
\usepackage{arydshln}                   % dash lines in tables
\usepackage{subfig, float, wrapfig}     % sub figures
\usepackage{makeidx, caption}           % index, titles for figures
\usepackage{enumerate}
\usepackage{fancybox}                   % страница в рамке
%\usepackage{fancyhdr}                   % глава и секция вверху страницы
%\usepackage{layout}
\usepackage[left=1.84cm, right=1.5cm, paperwidth=14cm, top=1.8cm, bottom=2cm, height=19.8cm, paperheight=20cm]{geometry}

% поддержка гиперссылок; гиперссылки в pdf, должен быть последним загруженным пакетом
\ifx\pdfoutput\undefined
    \usepackage[unicode,dvips]{hyperref}
\else
    \usepackage[pdftex,colorlinks,unicode,bookmarks]{hyperref}
\fi

%\paperwidth=16.8cm \oddsidemargin=0cm \evensidemargin=0cm \hoffset=-0.33cm \textwidth=13.2cm
%\paperheight=24cm \voffset=-0.4cm \topmargin=0cm \headsep=0cm \headheight=0cm \textheight=19.8cm \footskip=0.9cm

% параметры PDF файла
\hypersetup{
    pdftitle={Защита информации},
    pdfauthor={Э. М. Габидулин, А. С. Кшевецкий, А. И. Колыбельников, С. М. Владимиров},
    pdfsubject=учебное пособие,
    pdfkeywords={защита информации, криптография, МФТИ}
}

% добавить точку после номера секции, раздела и т.д.
\makeatletter
\def\@seccntformat#1{\csname the#1\endcsname.\quad}
\def\numberline#1{\hb@xt@\@tempdima{#1\if&#1&\else.\fi\hfil}}
\makeatother

% перенос слов с тире
%\lccode`\-=`\-
%\defaulthyphenchar=127

% изменить подписи к рисункам, таблицам и т.д.
\captionsetup{labelsep=period}          % заменить : на .
\captionsetup{textformat=period}        % Подписи завершать точкой
%\captionsetup[table]{position=above}    % вертикальные отступы подписи таблицы для случая, когда подпись вверху
%\captionsetup[figure]{position=below}   % вертикальные отступы подписи рисунка для случая, когда подпись внизу

%% стиль главы и секции вверху страницы
%\pagestyle{fancy}
%%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
%\renewcommand{\sectionmark}[1]{\markright{#1}{}}
%
%%\fancyhf{}
%%\fancyfoot[СE,CO]{\thepage}
%%\fancyhead[LE]{\textsc{\nouppercase{\leftmark}}}
%\fancyhead[RO]{\textsc{\nouppercase{\rightmark}}}
%
%\fancypagestyle{plain}{ %
%\fancyhf{}                              % remove everything
%\renewcommand{\headrulewidth}{0pt}      % remove lines as well
%\renewcommand{\footrulewidth}{0pt}}

% запретить выходить за границы страницы
\sloppy

\newtheorem{theorem}{Теорема}[section]
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{definition}[theorem]{Определение}
\newtheorem{property}[theorem]{Утверждение}
\newtheorem{corollary}[theorem]{Следствие}
%\newtheorem{algorithm}[theorem]{Алгоритм}
\newtheorem{remark}[theorem]{Замечание}
\newcommand{\proof}{\noindent\textsc{Доказательство.\ }}

%\newtheorem{example}{\textsc{\textbf{Пример}}}
\newcommand{\example}{\textsc{\textbf{Пример.}} }
\newcommand{\exampleend}

\newcommand{\set}[1]{\mathbb{#1}}
\newcommand{\group}[1]{\mathbb{#1}}
\newcommand{\E}{\group{E}}
\newcommand{\F}{\group{F}}
\newcommand{\GF}[1]{\group{GF}(#1)}
\newcommand{\Gr}{\group{G}}
\newcommand{\R}{\group{R}}
\newcommand{\Z}{\group{Z}}
\newcommand{\MAC}{\textrm{MAC}}
\newcommand{\HMAC}{\textrm{HMAC}}
\newcommand{\PK}{\textrm{PK}}
\newcommand{\SK}{\textrm{SK}}

%Наконец, существует способ дублировать знаки операций, который мы приведем безо всяких пояснений. Включив
%\newcommand*{\hm}[1]{#1\nobreak\discretionary{}{\hbox{\mathsurround=0pt #1}}{}}
%в преамбулу, можно написать $a\hm+b\hm+c\hm+d$, при этом в формуле a\hm+b\hm+c\hm+d при переносе знак + будет продублирован.

% Дублирование символов бинарных операций ("+", "-", "="), набранных в строчных формулах, при переносе на другую строку:
%%begin{latexonly}
%\renewcommand\ne{\mathchar"3236\mathchar"303D\nobreak
%      \discretionary{}{\usefont
%      {OMS}{cmsy}{m}{n}\char"36\usefont
%      {OT1}{cmr}{m}{n}\char"3D}{}}
%\begingroup
%\catcode`\+\active\gdef+{\mathchar8235\nobreak\discretionary{}%
% {\usefont{OT1}{cmr}{m}{n}\char43}{}}
%\catcode`\-\active\gdef-{\mathchar8704\nobreak\discretionary{}%
% {\usefont{OMS}{cmsy}{m}{n}\char0}{}}
%\catcode`\=\active\gdef={\mathchar12349\nobreak\discretionary{}%
% {\usefont{OT1}{cmr}{m}{n}\char61}{}}
%\endgroup
%\def\cdot{\mathchar8705\nobreak\discretionary{}%
% {\usefont{OMS}{cmsy}{m}{n}\char1}{}}
%\def\times{\mathchar8706\nobreak\discretionary{}%
% {\usefont{OMS}{cmsy}{m}{n}\char2}{}}
%\mathcode`\==32768
%\mathcode`\+=32768
%\mathcode`\-=32768
%%end{latexonly}

\makeindex

\begin{document}

%\layout

% рамка границ страницы http://www.ctan.org/tex-archive/macros/latex/contrib/fancybox/fancybox-doc.pdf
% сделать поиск по fancypage, thisfancypage
%\thisfancypage{}{\fbox}
%\thisfancypage{\fbox}{}
%\fancypage{}{\fbox}         % закомментировать
%\fancypage{\fbox}{\fbox}    % закомментировать
%\fancypage{\setlength{\fboxsep}{32pt}\fbox}{}

\title{Защита информации \\ Учебное пособие}
\author{Габидулин Эрнст Мухамедович \\ Кшевецкий Александр Сергеевич \\ Колыбельников Александр Иванович \\ Владимиров Сергей Михайлович}
\date{
 %   \textbf{\textsc{Черновой вариант. Может содержать ошибки.}} \\
%    \today
}
\maketitle
\setcounter{page}{3}

\newpage
%\thispagestyle{empty}
\setcounter{tocdepth}{2}
\tableofcontents
%\thispagestyle{empty}
\newpage

%\lhead[\leftmark]{}
%\rhead[]{\rightmark}

\input{foreword}

\chapter{Основные понятия и определения}

\input{Short_history_of_cryptography}

\input{model_of_the_transmission_system_with_crypto}

\section{Классификация криптосистем}

\input{classification_by_symmetry}

\subsection{Шифры замены и перестановки}

По способу преобразования открытого текста в шифрованный текст шифры разделяются на шифры замены и шифры перестановки.

\input{substitution_ciphers}

\input{permutation_ciphers}

\input{composite_chiphers}

\subsection{Примеры современных криптопримитивов}

Приведем примеры названий некоторых современных криптографических примитивов, из которых строят системы защиты информации:
\begin{itemize}
    \item DES, AES, ГОСТ 28147-89, Blowfish, RC5, RC6 -- блоковые симметричные шифры, скорость обработки десятки мегабайт в секунду,
    \item A5/1, A5/2, A5/3, RC4 -- потоковые симметричные шифры с высокой скоростью, семейство A5 применяется в мобильной связи GSM, RC4 -- в компьютерных сетях для SSL соединения между браузером и вебсервером,
    \item RSA\index{криптосистема!RSA} -- криптосистема с открытым ключом для шифрования,
    \item RSA\index{криптосистема!RSA}, DSA, ГОСТ Р 34.10-2001 -- криптосистемы с открытым ключом для электронной подписи,
    \item MD5, SHA-1, SHA-2, ГОСТ Р 34.11-94 -- криптографические хэш-функции.
\end{itemize}

\input{Cryptanalysis_methods_and_types_of_attacks}

\input{The_minimum_key_lengths}

\chapter{Классические шифры}

В главе приведены наиболее известные \emph{классические} шифры, которыми можно было пользоваться до появления роторных машин. К ним относятся шифр Цезаря, шифр Плейфера--Витстона, шифр Хилла, шифр Виженера. Они очень наглядно демонстрируют различные классы шифров.

\input{monoalphabetic_ciphers}

\input{bigrammnye_substitution_ciphers}

\input{hills_cipher}

% \subsection{Омофонные замены}
%
% Омофонными заменами называют криптопримитивы, в основе которых лежит замена групп символов открытого текста $M$ на группу символов $C$ с использованием ключа $K$. Такой метод шифрования вносит неоднозначность между $M$ и $C$, это позволяет защититься от методов частотного криптоанализа.
%  \subsection{шифрокоды}
%  Шифрокоды - это класс шифров сочетающих в себе свойства кодов и помехозащищенности со свойствами шифра и обеспечения конфиденциальности.

\input{vigeneres_chipher}

\input{polyalphabetic_cipher_cryptanalysis}

\input{perfect_secure_systems}

\chapter{Блоковые шифры}\label{chapter-block-ciphers}

\input{Feistel_cipher}

\input{GOST_28147-89}

\input{AES}

\input{Block_cipher_modes}

\section{Некоторые свойства блоковых шифров}

\input{feistel_network_reversibility}

\input{Feistel_cipher_without_s_blocks}

\input{Avalanche_effect}

\input{double_and_triple_ciphering}

\chapter{Потоковые шифры}\label{chapter-stream-ciphers}

\input{per-char_encryption}

\section{Криптостойкие последовательности} %{Генерирование криптостойких псевдослучайных последовательностей бит}

Генераторы псевдослучайных чисел (ГПСЧ) ставят в соответствие набору символов $z_{1} z_{2} \dots z_{l}$ значение некоторой функции $f(z_{1} z_{2} \dots z_{l}) = f_{1}$. Следующим $l$ символам -- $f(z_{l+1} z_{l+2} \dots z_{2l}) = f_{2}$. Получают набор значений $f_{1} f_{2} \dots f_{N}$ и используют их в качестве случайной последовательности.

Для проверки степени близости к независимости и равномерному распределению символов существует набор тестов. Американский институт стандартизации NIST разработал 16 тестов на псевдослучайность. Подсчитывается число нулей и единиц, число одинаковых соседних пар, число одинаковых подпоследовательностей, автокорреляция, частота следующего символа в зависимости от предыдущих и т.д. Вычисляют вероятность символа 0 (или 1)
\[
    P(f_i = 0 | f_{i-1} f_{i-2} \dots f_{i-k}) = \frac{1}{2} - \epsilon,
\]
Если вычисления осуществляются за полиномиальное время от длины подпоследовательности $k$, то есть с количеством битовых операций $O(k^{\textrm{const}})$, то тест называют \emph{полиномиальным}\index{задача!полиномиальная}.

Псевдослучайная последовательность удовлетворяет \textbf{тесту <<следующего бита>>}, если не существует полиномиального по $k$ теста, позволяющего по предыдущим $k$ битам определить следующий бит с вероятностью, отличной от $\frac{1}{2} - \epsilon$, принимая во внимание погрешность оценки $\epsilon$. Последовательность, удовлетворяющая тесту <<следующего бита>>, также удовлетворяет всем возможным полиномиальным тестам по $k$ на равномерность распределения, и наоборот.

Последовательность называется \emph{криптографически стойкой} или \emph{криптостойкой}, если она удовлетворяет тесту <<следующего бита>>.

\input{bbs_generator}

%\input{micalis_generator}

\input{maximal_period_sequences}

\section[Три способа улучшения последовательностей]{Три способа улучшения \protect\\ последовательностей}

\input{generators_with_multiple_shift_registers}

\input{generators_with_nonlinear_transformations}

\input{majority_generators}

\input{hash-functions}

\input{public-key}

\chapter{Распространение ключей}

Задачей распространения ключей между двумя пользователями является создание секретных псевдослучайных сеансовых ключей шифрования и аутентификация сообщений. Пользователи предварительно создают и обмениваются ключами аутентификации один раз. В дальнейшем для создания защищенной связи пользователи производят взаимную аутентификацию и вырабатывают сеансовые ключи\index{ключ!сеансовый}.

\input{shamirs_three-step_protocol}

\section{Протоколы с симметричными шифрами}

\subsection{Аутентификация и атаки воспроизведения}

Рассмотрим такую ситуацию: обе стороны $A$ и $B$ имеют общий долговременный ключ $K_{AB}$ и симметричную систему шифрования. Нужно выработать сеансовый секретный ключ $K$. Сторона $A$ создает ключ $K$ и желает его передать стороне $B$.

\begin{enumerate}
    \item Для этого сторона $A$ с помощью общего ключа $K_{AB}$ создает и передает $B$ шифрованное сообщение:
            \[ A \rightarrow B: ~ E_{K_{AB}}(K, B, A). \]
        В этом сообщении имеются так называемые поля -- $(B,A)$ -- информация для дополнительного подтверждения.
    \item Сторона $B$, используя общий ключ $K_{AB}$, расшифровывает полученное сообщение:
            \[ D_{K_{AB}}( E_{K_{AB}}( K, B, A)) = (K, B, A). \]
        В результате сторона $B$ получает сеансовый ключ $K$ и дополнительные данные $(B,A)$.
\end{enumerate}

Недостаток этого протокола состоит в том, что криптоаналитик может перехватывать сообщения и через некоторое время переслать их стороне $A$.

Рассмотрим другие варианты решения задачи о передаче сеансового ключа.
Задача остается прежней: обе стороны $A$ и $B$ имеют общий долговременный секретный ключ $K_{AB}$, сторона $A$ должна выработать сеансовый секретный ключ $K$ и доставить стороне $B$.

Протокол включает \textbf{метки времени} -- информацию о моменте $t_A$ отправки сообщения и моменте получения сообщения $t_B$.

\begin{enumerate}
    \item Сторона $A$ вырабатывает $K$ и с помощью долговременного ключа $K_{AB}$ создает шифрованное сообщение с меткой времени $t_A$ и передает его стороне $B$:
            \[ A \rightarrow B: ~ E_{K_{AB}}(K, t_A). \]
    \item Сторона $B$ получает сообщение и расшифровывает его с помощью общего ключа:
            \[ D_{K_{AB}}( E_{K_{AB}}( K, t_A)) = (K, t_A). \]
        В результате $B$ получает $(K, t_A)$, то есть, секретный ключ и метку времени. $B$ измеряет время прихода $t_B$ и интервал запаздывания. Если $|t_B - t_A| \le \delta$, то $B$ аутентифицирует $A$.
\end{enumerate}
Метка времени является одноразовой меткой и защищает от атак воспроизведения ранее записанных сообщений.

Рассмотрим другой способ передачи ключа с дополнительной информацией в виде \textbf{одноразовых случайных меток} (nonce -- number used once) вместо меток времени. Протокол передачи состоит в следующем.

\begin{enumerate}
    \item Сторона $A$ вырабатывает случайное число $r_A$, шифрует сообщение, в котором  $(r_A, A)$ -- реквизиты $A$, и передает его стороне $B$:
            \[ A \rightarrow B: ~ E_{K_{AB}}(r_A, A). \]
    \item Сторона $B$ вырабатывает сеансовый ключ $K$, создает шифрованное сообщение и посылает его $A$:
            \[ A \leftarrow B: ~ E_{K_{AB}}(K, r_A, A). \]
    \item Сторона $A$ расшифровывает полученное сообщение:
            \[ D_{K_{AB}}( E_{K_{AB}}( K, r_A, A)) = (K, r_A, A). \]
        В результате $A$ получает сеансовый ключ и подтверждение своих реквизитов, что является дополнительной аутентификацией.
\end{enumerate}

Предположим, что сторона $B$ тоже желает убедиться, что имеет дело со стороной $A$. Тогда этот протокол следует дополнить передачей реквизитов $B$. По-прежнему считаем, что у $A$ и $B$ -- общая система шифрования с долговременным секретным ключом $K_{AB}$.

\begin{enumerate}
    \item Сторона $A$ вырабатывает случайное число $r_A$, шифрует и передает стороне $B$ сообщение, в котором  $(r_A, A)$ -- реквизиты $A$:
            \[ A \rightarrow B: ~ E_{K_{AB}}(r_A, A). \]
    \item Сторона $B$ вырабатывает случайное число $r_B$ и отправляет стороне $A$ зашифрованное сообщение:
            \[ A \leftarrow B: ~ E_{K_{AB}}(K_B, r_B, r_A, A), \]
        где $K_B$ -- ключ $B$.
     \item Сторона $A$ осуществляет расшифрование
            \[ D_{K_{AB}}(E_{K_{AB}}(K_B, r_B, r_A, A)) = (K_B, r_B, r_A, A) \]
        и получает ключ $K_B$ и реквизиты $r_B, r_A, A$. Для аутентификации себя сторона $A$ создает свой ключ $K_A$ и отправляет стороне $B$ шифрованное сообщение
            \[ A \rightarrow B: ~ E_{K_{AB}}(K_A, r_B, r_A, B). \]
     \item Сторона $B$ осуществляет расшифрование
            \[ D_{K_{AB}}(E_{K_{AB}}(K_A, r_B, r_A, B)) = (K_A, r_B, r_A, B), \]
        которое определяет ключ $K_A$ и аутентифицирует $A$.
\end{enumerate}

Таким образом, обе стороны имеют в своем распоряжении ключи $K_A, K_B$ в качестве сеансовых секретных ключей.


\subsection{Протокол с ключевым кодом аутентификации}

При использовании хэш-функции $K = h(K_{A} \| K_{B})$ происходит усиление секретности. Здесь $(K_{A} \| K_{B})$ -- конкатенация $K_{A} $ и $K_{B}$.

% Достоинства: предположим, $K_{A} ,K_{B} $ - не обладают «хорошими» свойствами случайности (биты распределены неравномерно или зависимы друг от друга), т.е., $P_{K_{A} ,K_{B} } (0)=\frac{1}{2} -\varepsilon $, где $\varepsilon $ - мало, но не 0. Тогда вероятность того, что этот бит в \textit{K }будет равным нулю, $P_{K} (0)=\frac{1}{2} -\varepsilon ',\varepsilon '<\varepsilon $- усиление секретности.

Вычисление хэш-значения, как правило, выполняется быстрее, чем расшифрование. Поэтому были разработаны протоколы, в которых вместо функции шифрования используется имитовставка\index{имитовставка} на основе хэш-функции ($\MAC_K$). Рассмотрим протокол такого рода.
\begin{enumerate}
    \item Сторона $A$ вырабатывает сеансовый ключ $K$, использует одноразовую метку $t_{A}$, создает и пересылает стороне $B$ сообщение:
            \[ A \rightarrow B: ~ t_A, ~ B, ~ K \oplus \MAC_{K_{AB}}( t_A, B), ~ \MAC_{K_{AB}}(K, t_A, B). \]
    \item Сторона $B$ вычисляет
            \[ \MAC_{K_{AB}}(t_A, B) \oplus K \oplus \MAC_{K_{AB}}(t_A, B) = K \]
        и получает сеансовый ключ $K$.
\end{enumerate}

Заметим, что криптоаналитик может добавить в поле случайную последовательность, тогда вместо $K$ получаем <<$K$ плюс помеха>>. Вмешательство криптоаналитика будет выявлено благодаря наличию четвертого поля в сообщении. Используя полученное значение $K$, вычисляют $\MAC_{K_{AB}}(K, t_A, B)$ и сравнивают с четвертым полем. Если совпадает, то вмешательства криптоаналитика не было.

\input{needham-schroeder_protocol}

\section{Протоколы на криптосистемах с открытым ключом}

\subsection{Простой протокол}

Рассмотрим протокол распространения ключей с помощью асимметричных шифров. Введем обозначения: $K_B$ -- открытый ключ стороны $B$, а $K_A$ -- открытый ключ стороны $A$. Протокол включает три сеанса обмена информацией.
\begin{enumerate}
    \item В первом сеансе сторона $A$ посылает стороне $B$ сообщение
            \[ A \rightarrow B: ~ E_{K_B}(K_1, A), \]
        где $K_1$ -- ключ, выработанный стороной $A$.
    \item Сторона $B$ получает $(K_1, A)$ и передает стороне $A$ наряду с другой информацией свой ключ $K_2$ в сообщении, зашифрованном с помощью открытого ключа $K_A$:
            \[ A \leftarrow B: ~ E_{K_A}(K_2, K_1, B). \]
    \item Сторона $A$ получает и расшифровывает сообщение $(K_2, K_1, B)$. Во время третьего сеанса сторона $A$, чтобы подтвердить, что она знает ключ $K_2$, посылает стороне $B$ сообщение
            \[ A \rightarrow B: ~ E_{K_B}(K_2). \]
\end{enumerate}
Общий ключ формируется из двух ключей $K_1, K_2$.

\subsection{Протоколы с цифровыми подписями}

Существуют протоколы обмена, в которых перед началом обмена ключами генерируются подписи сторон $A$ и $B$, соответственно $S_A(m)$ и $S_B(m)$. В этих протоколах можно использовать различные одноразовые метки. Рассмотрим пример.
\begin{enumerate}
    \item Сторона $A$ выбирает ключ $K$ и вырабатывает сообщение
            \[ \left( K, ~ t_A, ~ S_A(K, t_A, B) \right), \]
        где $t_A$ -- метка времени. Зашифрованное сообщение передает стороне $B$:
        \[ A \rightarrow B: ~ E_{K_B}(K, ~ t_A, ~ S_A(K, t_A, B)). \]
    \item Сторона $B$ получает это сообщение, расшифровывает $\left( K, ~ t_A, ~ S_A(K, t_A, B) \right)$ и вырабатывает свою метку времени $t_B$. Проверка считается успешной, если $|t_B - t_A | < \delta $. Сторона $B$ знает свои реквизиты и может осуществлять проверку подписи.
\end{enumerate}

Имеется второй вариант протокола, в котором шифрование и подпись выполняются раздельно.
\begin{enumerate}
    \item Сторона $A$ вырабатывает ключ $K$, использует одноразовую метку (или метку времени) $t_{A}$ и передает стороне $B$ два различных зашифрованных сообщения
            \[ \begin{array}{ll}
                A \rightarrow B: & ~ E_{K_B}(K, t_A), \\
                A \rightarrow B: & ~ S_A(K, t_A, B). \\
            \end{array} \]
    \item Сторона $B$ получает это сообщение, расшифровывает $K, t_A$ и, добавив свои реквизиты $B$, может проверить подпись $S_A(K, t_A, B)$.
\end{enumerate}

В третьем варианте протокола сначала производится шифрование, потом подпись.
\begin{enumerate}
    \item Сторона $A$ вырабатывает ключ $K$, использует одноразовую случайную метку или метку времени $t_A$ и передает стороне $B$ сообщение
        \[ A \rightarrow B: ~ t_A, ~ E_{K_B}(K, A), ~ S_A(t_A, ~ K, ~ E_{K_B}(K, A)). \]
    \item Сторона $B$ получает это сообщение, расшифровывает $\left( t_A, ~ K, ~ A, ~ E_{K_B}(K, A) \right)$ и проверяет подпись $S_A(t_A, ~ K, ~ E_{K_B}(K, A))$.
\end{enumerate}

\input{diffie-hellman}

%\section{Протоколы с аутентификацией}

\subsection{Односторонняя аутентификация}

\input{el-gamal_protocol}

\input{mti}

\input{sts}

\input{girrault}

В этом разделе были рассмотрены протоколы, в которых ключи вырабатываются в процессе обмена информацией.
%Существует и другой подход, который будет рассмотрен в следующих разделах.

\chapter{Разделение секрета}

\section{Пороговые схемы}

Идея \textbf{пороговой} $(n, N)$-схемы\index{разделение секрета!пороговое} разделения общего секрета среди $N$ пользователей состоит в следующем.
%описывается так:
Доверенная сторона хочет распределить некий секрет $K_0$ между $N$ пользователями таким образом, что:
%. Поставлены следующие условия:
\begin{itemize}
    \item любые $m, ~ n \le m \le N$, легальных пользователей могут получить секрет (или доступ к секрету), если предъявят свои секретные ключи;
    \item любые $m, ~ m < n$ легальных пользователей не могут получить секрет и не могут определить (вычислить) этот секрет, пытаясь решить трудную в вычислительном смысле задачу.
\end{itemize}

Далее рассмотрены два случая: $(n, N)$-схема Шамира и простая $(N,N)$-схема.

\input{shamirs_secret_sharing}

\input{xor_secret_sharing}

\section[Распределение секрета по коалициям]{Распределение секрета по \protect\\ коалициям}

\subsection[Схема для нескольких коалиций]{Распределение секрета по нескольким \protect\\ коалициям}

Предположим, что имеется $N$ легальных пользователей
    \[ \{ U_1, U_2, \dots, U_N \}, \]
которым нужно сообщить (открыть, получить доступ к) общий секрет $K$.

Секрет может быть доступен только определенным коалициям\index{распределение секрета!по коалициям}, например
\[ \begin{array}{l}
    C_1 = \{ U_1, U_2 \}, \\
    C_2 = \{ U_1, U_3, U_4 \}, \\
    C_3 = \{ U_2, U_3 \}, \\
    \dots
\end{array} \]
При этом ни одна из коалиций $C_i, ~ i = 1, 2, \dots$ не должна быть подмножеством другой коалиции.


\subsubsection{Пример 1}

Имеется 4 участника
    \[ \{ U_1, U_2, U_3, U_4 \}, \]
которые образуют 3 коалиции
\[ \begin{array}{l}
    C_1 = \{ U_1, U_2 \}, \\
    C_2 = \{ U_1, U_3 \}, \\
    C_3 = \{ U_2, U_3, U_4 \}. \\
\end{array} \]
Распределение частичных секретов между ними представлено в виде табл. \ref{tab:secret-share-coalition-1}, в которой введены следующие обозначения: $a_1, b_1, c_2, c_3$ -- случайные числа из кольца $\Z_M$. В строках таблицы содержатся частичные секреты каждого из пользователей, в столбцах таблицы показаны частичные секреты, соответствующие каждой из коалиций.

\begin{table}[!ht]
    \centering
    \caption{Распределение секрета по определенным коалициям\label{tab:secret-share-coalition-1}}
    \begin{tabular}{|c||c|c|c|}
        \hline
              & $C_1 = \{ U_1, U_2 \}$ & $C_2 = \{U_1, U_3 \}$ & $C_3 = \{ U_2, U_3, U_4 \}$ \\
        \hline \hline
        $U_1$ & $a_1$     & $b_1$     & -- \\
        $U_2$ & $K - a_1$ & --        & $c_2$ \\
        $U_3$ & --        & $K - b_1$ & $c_3$  \\
        $U_4$ & --        & --        & $K - c_2 - c_3$ \\
        \hline
    \end{tabular}
\end{table}

Как видно из приведенных данных, суммирование по модулю $M$ чисел, приведенных в каждом из столбцов таблицы, открывает секрет $K$.


\subsubsection{Пример 2}

%\section{Схема разделения секрета на монотонных булевых функциях}
%\example
В системе распределения секрета доверенный
%с использованием монотонных булевых функций
центр использует кольцо $\Z_m$ целых чисел по модулю $m$. Требуется разделить секрет $K$ между $5$ пользователями
    \[ \{ U_1, U_2, U_3, U_4, U_5 \} \]
так, чтобы восстановить секрет могли только коалиции
\[ \begin{array}{lll}
    C_1 = \{ U_1, U_2 \},      & & C_2 = \{ U_1, U_3 \}, \\
    C_3 = \{ U_2, U_3, U_4 \}, & & C_4 = \{ U_2, U_3, U_5 \}, \\
    C_5 = \{ U_3, U_4, U_5 \}, & & C_6 = \{ U_1, U_2, U_3 \}. \\
\end{array} \]

Заданное множество коалиций с доступом не является минимальным, так как одни коалиции входят в другие:
    \[ C_1 \subset C_6, ~ C_2 \subset C_6. \]
Исключая $C_6$, получим минимальное множество коалиций с доступом к секрету -- ни одна из оставшихся коалиций не входит в другую $C_i \nsubseteq C_j$ для $i \neq j$. Пользователям выдаются тени по минимальному множеству коалиций с доступом. В строках таблицы \ref{tab:secret-share-coalition-2} содержатся частичные секреты каждого из пользователей, в столбцах таблицы показаны частичные секреты, соответствующие каждой из коалиций.

\begin{table}[!ht]
    \centering
    \caption{Распределение секрета по определенным коалициям\label{tab:secret-share-coalition-2}}
    \begin{tabular}{|c||c|c|c|c|c|}
        \hline
              & $C_1$     & $C_2$     & $C_3$           & $C_4$           & $C_5$  \\
        \hline \hline
        $U_1$ & $a_1$     & $b_1$     & --              & --              & -- \\
        $U_2$ & $K - a_1$ & --        & $c_2$           & $d_2$           & --\\
        $U_3$ & --        & $K - b_1$ & $c_3$           & $d_3$           & $e_3$ \\
        $U_4$ & --        & --        & $K - c_2 - c_3$ & --              & $e_4$ \\
        $U_5$ & --        & --        & --              & $K - d_2 - d_3$ & $K - e_3 - e_4$ \\
        \hline
    \end{tabular}
\end{table}

Тени выбираются случайно из кольца $\mathbb{\Z}_m$. В результате у пользователей будут тени:
%\exampleend

\input{brickells_scheme}

\input{bloms_scheme}

\chapter{Примеры систем защиты}

\input{kerberos}

\section{Инфраструктура открытых ключей}

\input{CAs}

\input{x509}

\input{pgp}

\input{tls}

\input{ipsec}

\section[Защита персональных данных в мобильной связи]{Защита персональных данных в \protect\\ мобильной связи}

\input{gsm2}

\input{gsm3}

%\section{Беспроводная сеть Wi-Fi}
%\subsection{WPA-PSK2, 802.11n, Radix?}
%\subsection{Wimax 802.16(?)}

\chapter{Аутентификация пользователя}


\section{Многофакторная аутентификация}

Для защищенных приложений применяется \textbf{многофакторная} аутентификация одновременно по факторам различной природы:
\begin{enumerate}
    \item Свойство, которым обладает субъект. Например, биометрия, природные уникальные отличия: лицо, отпечатки пальцев, радужная оболочка глаз, капиллярные узоры, последовательность ДНК.
    \item Знание -- информация, которую знает субъект. Например, пароль, PIN-код.
    \item Владение -- вещь, которой обладает субъект. Например, электронная или магнитная карта, флеш-память.
%    \item Факторы присвоения. Например, номер машины, RFID-метка.
\end{enumerate}

В обычных массовых приложениях из-за удобства использования применяется аутентификация только по \textbf{паролю}\index{пароль}, который является общим секретом пользователя и информационной системы. Биометрическая аутентификация по отпечаткам пальцев применяется существенно реже. Как правило, аутентификация по отпечаткам пальцев является дополнительным, а не вторым обязательным фактором (тоже из-за удобства ее использования).

%Так же явно или неявно используется аутентификация по факторам:
%\begin{enumerate}
%    \item Социальная сеть. Доверие к индивидууму в личном общении или интернет на основании общих связей.
%    \item Географическое положение. Например, для проверки оплаты товаров по кредитной карте.
%    \item Время. Доступ к сервисам или местам только в определенное время.
%    \item И др.
%\end{enumerate}


\section[Энтропия и криптостойкость паролей]{Энтропия и криптостойкость \protect\\ паролей}

Стандартный набор символов паролей, которые можно набрать на клавиатуре, используя английские буквы и небуквенные символы, состоит из $D=94$ символов. При длине пароля $L$ символов и предположении равновероятного использования символов энтропия паролей равна
    \[ H = L \log_2 D. \]

Клод Шеннон, исследуя энтропию символов английского текста, изучал вероятность успешного предсказания людьми следующего символа по первым нескольким символам слов или текста. В результате Шеннон получил оценку энтропии первого символа $s_1$ текста порядка $H(s_1) \approx 4{,}6$--$4{,}7$ бит/символ и оценки энтропий последующих символов, постепенно уменьшающиеся до $H(s_9) \approx 1{,}5$ бит/символ для 9-го символа. Энтропия для длинных текстов литературных произведений получила оценку $H(s_\infty) \approx 0{,}4$ бит/символ.

Статистические исследования баз паролей показывают, что наиболее часто используются буквы <<a>>, <<e>>, <<o>>, <<r>> и цифра <<1>>.

NIST использует следующие рекомендации для оценки энтропии паролей\index{энтропия!пароля}, создаваемых людьми.
\begin{enumerate}
    \item Энтропия первого символа $H(s_1) = 4$ бит/символ.
    \item Энтропия со 2-го по 8-й символы $H(s_{2 \leq i \leq 8}) = 2$ бит/символ.
    \item Энтропия с 9-го по 20-й символы $H(s_{9 \leq i \leq 20}) = 1{,}5$ бит/символ.
    \item Энтропия с 21-го символа $H(s_{i \geq 21}) = 1$ бит/символ.
    \item Проверка композиции на использование символов разных регистров и небуквенных символов добавляет до 6 бит энтропии пароля.
    \item Словарная проверка на слова и часто используемые пароли добавляет до 6 бит энтропии для коротких паролей. Для 20-символьных и более длинных паролей прибавка к энтропии 0 бит.
\end{enumerate}

Для оценки энтропии пароля нужно сложить энтропии символов $H(s_i)$ и сделать дополнительные надбавки, если пароль удовлетворяет тестам на композицию и отсутствие в словаре.

\begin{table}[!ht]
    \centering
    \caption{Оценка NIST предполагаемой энтропии паролей\label{tab:password-entropy}}
    \resizebox{\textwidth}{!}{ \begin{tabular}{|c||c|c|c||c|}
        \hline
        \multirow{2}{*}{\parbox{1.5cm}{Длина пароля, символы}} & \multicolumn{3}{|c||}{\parbox{6cm}{Энтропия паролей пользователей по критериям NIST}} & \multirow{2}{*}{\parbox{2.5cm}{Энтропия случайных равновероятных паролей}} \\
        \cline{2-4}
        & \parbox{1.5cm}{Без проверок} & \parbox{2cm}{Словарная проверка} & \parbox{2.5cm}{Словарная и композиционная проверка} & \\
        \hline
        4  & 10 & 14 & 16 & 26.3 \\
        6  & 14 & 20 & 23 & 39.5 \\
        8  & 18 & 24 & 30 & 52.7 \\
        10 & 21 & 26 & 32 & 65.9 \\
        12 & 24 & 28 & 34 & 79.0 \\
        16 & 30 & 32 & 38 & 105.4 \\
        20 & 36 & 36 & 42 & 131.7 \\
        24 & 40 & 40 & 46 & 158.0 \\
        30 & 46 & 46 & 52 & 197.2 \\
        40 & 56 & 56 & 62 & 263.4 \\
        \hline
    \end{tabular} }
\end{table}

В табл. \ref{tab:password-entropy} приведена оценка NIST на величину энтропии пользовательских паролей в зависимости от их длины и сравнение с энтропией случайных паролей с равномерным распределением символов из набора в $D=94$ символов клавиатуры. Вероятное число попыток для подбора пароля составляет $O(2^H)$. Из таблицы видно, что по критериям NIST энтропия реальных паролей в 2--4 раза меньше энтропии случайных паролей с равномерным распределением символов.

\example
Оценим общее количество существующих паролей. Население Земли -- 7 млрд. Предположим, что все население использует компьютеры, Интернет, и у каждого человека по 10 паролей. Общее количество существующих паролей -- $7 \cdot 10^{10} \approx 2^{36}$.
%Следовательно, \emph{реальная энтропия паролей не превышает 36 бит}.

Имея доступ к наиболее массовым интернет-сервисам с количеством пользователей десятки и сотни миллионов, в которых пароли часто хранятся в открытом виде из-за необходимости обновления ПО и, в частности, выполнения аутентификации, мы 1) имеем базу паролей, покрывающую существенную часть пользователей, 2) можем статистически построить правила генерирования паролей. Даже если пароль хранится в защищенном виде, то при вводе пароль, как правило, в открытом виде пересылается по Интернету, и все преобразования пароля для аутентификации осуществляет интернет-сервис, а не веб-браузер. Следовательно, интернет-сервис имеет доступ к исходному паролю.
\exampleend

В 2002 г. был подобран ключ для 64-битового блокового шифра RC5 сетью \texttt{distributed.net} персональных компьютеров, выполнявших вычисления в фоновом режиме. Суммарное время вычислений всех компьютеров -- 1757 дней, было проверено 83\% пространства всех ключей. Это означает, что пароли с оценочной энтропией менее 64 бит, то есть \emph{все пароли} до 40 символов по критериям NIST, могут быть подобраны в настоящее время. Конечно, с оговорками на то, что 1) нет ограничений на количество и скорость попыток аутентификаций, 2) алгоритм генерирования вероятных паролей эффективен.

Строго говоря, использование даже 40-символьного пароля для аутентификации или в качестве ключа блокового шифрования является небезопасным.


\subsubsection{Число паролей}

Приведем различные оценки числа паролей, создаваемых людьми.

Пароли, создаваемые людьми, основаны на словах или закономерностях естественного языка. В английском языке всего около $1\ 000\ 000 \approx 2^{20}$ слов, включая термины.

%http://www.springerlink.com/content/bh216312577r6w64/fulltext.pdf
%http://www.antimoon.com/forum/2004/4797.htm

Используемые слоги английского языка имеют вид V, CV, VC, CVV, VCC, CVC, CCV, CVCC, CVCCC, CCVCC, CCCVCC, где C -- согласная (consonant), V -- гласная (vowel). 70\% слогов имеют структуру VC или CVC. Общее число слогов $S = 8000 - 12000$. Средняя длина слога -- 3 буквы.

Предполагая равновероятное распределение всех слогов английского языка, для числа паролей из $r$ слогов получим верхнюю оценку
    \[ N_1 = S^r = 2^{13 r} \approx 2^{4.3 L_1}. \]
Средняя длина паролей составит
    \[ L_1 \approx 3 r. \]

Теперь предположим, что пароли могут состоять только из 2--3 буквенных слогов вида CV, VC, CVV, VCC, CVC, CCV с равновероятным распределением символов. Подсчитаем число паролей $N_2$, которые могут быть построены из $r$ таких слогов. В английском алфавите $n_v = 10, n_c = 16, n = n_v + n_c = 26$. Верхняя оценка числа $r$-слоговых паролей:
    \[ N_2 = (n_c n_v + n_v n_c + n_c n_v n_v + n_v n_c n_c + n_c n_v n_c + n_c n_c n_v)^r \approx \]
        \[ \approx \left( n_c n_v(3 n_c + n_v) \right)^r, \]
    \[ N_2 \approx \left( \frac{n^3}{2} \right)^r \approx 2^{13 r} \approx 2^{4.3 L_2}. \]
Средняя длина паролей:
    \[ L_2 = \frac{n_c n_v(2 + 2 + 3 n_v + 3 n_c + 3 n_c + 3 n_c)}{n_c n_v (1 + 1 + n_v + n_c + n_c + n_c)} \cdot r \approx 3 r. \]

Как видно, получились одинаковые оценки числа и длины паролей.

Подсчитаем верхние оценки числа паролей из $L$ символов, предполагая равномерное распределение символов из алфавита в $D$ символов: a) $D_1 = 26$ строчных буквы, б) все $D_2 = 94$ печатных символа клавиатуры (латиница и небуквенные символы):
    \[ N_3 = D_1^L \approx 2^{4.7 L}, \]
    \[ N_4 = D_2^L \approx 2^{6.6 L}. \]

\begin{table}[!ht]
    \centering
    \caption{Различные верхние оценки числа паролей\label{tab:password-number}}
    \resizebox{\textwidth}{!}{ \begin{tabular}{|c||c|c|c|}
        \hline
        \multirow{2}{*}{\parbox{1.5cm}{Длина пароля}} & \multicolumn{3}{|c|}{Число паролей} \\
        \cline{2-4}
            & \parbox{3cm}{На основе слоговой композиции} &
            \parbox{3cm}{Алфавит $D=26$ символов} &
            \parbox{3cm}{Алфавит $D=94$ символа} \\
        \hline \hline
        6  & $2^{26}$ & $2^{28}$ & $2^{39}$ \\
        9  & $2^{39}$ & $2^{42}$ & $2^{59}$ \\
        12 & $2^{52}$ & $2^{56}$ & $2^{79}$ \\
        15 & $2^{65}$ & $2^{71}$ & $2^{98}$ \\
        \hline
        21 & $2^{91}$ & $2^{99}$ & $2^{137}$ \\
        \hline
        39 & $2^{169}$ & $2^{183}$ & $2^{256}$ \\
        \hline
    \end{tabular} }
\end{table}

Из таблицы \ref{tab:password-number} видно, что при доступном объеме вычислений в $2^{60 \ldots 70}$ операций пароли вплоть до 15 символов, построенные на словах, слогах, изменениях слов, вставках цифр, небольшом изменении регистров и других простейших модификациях, могут быть найдены перебором на кластере (или ПК) в настоящее время.

Для достижения криптостойкости паролей, сравнимой со 128- или 256-битовым секретным ключом, требуется выбирать пароль из 20 и 40 символов соответственно, что, как правило, не реализуется из-за сложности запоминания и ввода без ошибок.


%Подсчитаем число паролей $N_1$, которые могут могут построены из $r$ ~ 2-3 буквенных слогов: $cv, vc, ccv, cvc, vcc$, где $c$ -- согласная, $v$ -- гласная. В английском алфавите $n_v = 10, n_c = 16, n = n_v + n_c = 26$. Число паролей
%    \[ N_1 = \left( n_v n_c (1 + 1 + n_c + n_c + n_c) \right)^r \approx 3^r n_v^r n_c^{2r}. \]
%Средняя длина паролей
%    \[ L = r \left( \frac{2 + 2 + 3 n_c + 3 n_c + 3 n_c}{1 + 1 + n_c + n_c + n_c} \right) \approx 3r. \]
%
%%Учтем, что $b \leq r$ символов могут быть заглавными: $N_1 \rightarrow N_2 < N_1 \binom{L}{b} \left( \frac{n}{n_v} \right)^b$. Вставим $d$ цифр в случайные места: $N_2 \rightarrow N_3 = N_2 (10 (1 + L))^d \approx N_2 (10 L)^d$.
%%
%%Общее число паролей
%%    \[ N = N_3 = 3^r 10^r 16^{2r} \binom{3r}{b} 2.6^b \left(10 \cdot 3 r \right)^d. \]
%%
%%\begin{table}[!ht]
%%    \centering
%%    \small
%%    \begin{tabular}{|c|c|c|c|c||cr|}
%%        \hline
%%        \parbox{1.3cm}{Слогов, $r$} & \parbox{1.8cm}{Заглавных букв, $b$} & \parbox{1.5cm}{Вставок цифр, $d$} & \parbox{2.8cm}{Средняя длина пароля, $L+d$} & \parbox{3cm}{Верхняя оценка числа паролей $N$} & \multicolumn{2}{|c|}{\parbox{3.2cm}{Число всех паролей}} \\
%%        \hline
%%        $2$ & $0$ & $0$ & $6$ & $2^{26}$ & $2^{36}$ & a-z \\
%%        $2$ & $2$ & $0$ & $6$ & $2^{32}$ & $2^{48}$ & A-Z, a-z \\
%%        $2$ & $2$ & $2$ & $8$ & $2^{45}$ & $2^{48}$ & A-Z, a-z, 0-9 \\
%%        \hline
%%        $3$ & $0$ & $0$ & $9$ & $2^{39}$ & $2^{54}$ & a-z \\
%%        $3$ & $3$ & $0$ & $9$ & $2^{49}$ & $2^{54}$ & A-Z, a-z \\
%%        $3$ & $3$ & $2$ & $11$ & $2^{63}$ & $2^{65}$ & A-Z, a-z, 0-9 \\
%%        \hline
%%        $4$ & $0$ & $0$ & $12$ & $2^{52}$ & $2^{93}$ & a-z \\
%%        $4$ & $3$ & $0$ & $12$ & $2^{64}$ & $2^{186}$ & A-Z, a-z \\
%%        $4$ & $3$ & $2$ & $14$ & $2^{78}$ & $2^{222}$ & A-Z, a-z, 0-9 \\
%%        \hline
%%    \end{tabular}
%%    \caption{Сравнение верхней оценки числа паролей, построенных на слогах, со всем доступным множеством паролей.}
%%    \label{tab:password-number}
%%\end{table}
%
%Учтем, что $b$ символов в пароле могут быть взяты не из 26-символьного алфавита строчных букв, а из всего алфавита в $D=94$ печатных символа клавиатуры (латиница и небуквенные символы):
%\[
%    \begin{array}{ll}
%    b=1 & N_1 \rightarrow N_2 = \frac{n_v}{n_v+n_c} 3^r n_v^{r-1} n_c^{2r} \cdot L. \]
%
%    \[ N_1 \rightarrow N_2 < N_1 \binom{L}{b} \left( \frac{D}{n_v} \right)^b. \]
%
%
%
%Общее число паролей
%    \[ N < 3^r n_v^r n_c^{2r} \binom{L}{b} \left( \frac{D}{n_v} \right)^b = 3^r 10^r 16^{2r} \binom{3r}{b} \left( \frac{94}{10} \right)^b. \]
%
%\begin{table}[!ht]
%    \centering
%    \small
%    \begin{tabular}{|c|c|c|c||cr|}
%        \hline
%        \parbox{1.5cm}{Слогов, $r$} & \parbox{3cm}{Средняя длина пароля, $L$} & \parbox{3cm}{Символов из всего алфавита, $b$} & \parbox{3cm}{Верхняя оценка числа паролей $N$} & \multicolumn{2}{|c|}{\parbox{3.2cm}{Число всех паролей, $D^L$}} \\
%        \hline
%        \multirow{3}{*}{2} & \multirow{3}{*}{6} & $0$ & $2^{26}$ & $2^{28}$ & a-z \\
%        & & $1$ & $2^{32}$ & $2^{34}$ & A-Z, a-z \\
%        & & $3$ & $2^{40}$ & $2^{39}$ & Весь алфавит \\
%        \hline
%        \multirow{3}{*}{3} & \multirow{3}{*}{9} & $0$ & $2^{39}$ & $2^{42}$ & a-z \\
%        & & $2$ & $2^{50}$ & $2^{51}$ & A-Z, a-z \\
%        & & $4$ & $2^{59}$ & $2^{59}$ & Весь алфавит \\
%        \hline
%        \multirow{3}{*}{4} & \multirow{3}{*}{12} & $0$ & $2^{52}$ & $2^{56}$ & a-z \\
%        & & $3$ & $2^{69}$ & $2^{68}$ & A-Z, a-z \\
%        & & $6$ & $2^{81}$ & $2^{77}$ & Весь алфавит \\
%        \hline
%    \end{tabular}
%    \caption{Сравнение верхней оценки числа паролей, построенных на слогах, со всем доступным множеством паролей в алфавите из $D$ символов.}
%    \label{tab:password-number}
%\end{table}
%
%Из таблицы \ref{tab:password-number} видно, что при доступном объеме вычислений в $2^{60 \ldots 70}$ операций, пароли вплоть до 12 символов, построенные на словах, слогах, изменениях слов, вставках цифр, небольшого изменения регистров и другой простейшей обфускации, могут быть найдены перебором на кластере (или ПК) в настоящее время.


\subsubsection{Атака для подбора паролей и ключей шифрования}

В схемах аутентификации по паролю иногда используется хэширование и хранение хэша пароля на сервере. В таких случаях применима словарная атака или атака с применением заранее вычисленных таблиц для ускорения поиска.

Для нахождения пароля, прообраза хэш-функции, или для нахождения ключа блокового шифрования по атаке с выбранным шифротекстом (для одного и того же известного открытого текста и соответствующего шифротекста) может быть применен метод перебора с балансом между памятью и временем вычислений. Самый быстрый метод радужных таблиц (rainbow tables)\index{радужные таблицы}, 2003 г., заранее вычисляет следующие цепочки и хранит результат в памяти.

Для нахождения пароля, прообраза хэш-функции $H$, цепочка строится как
    \[ M_0 \xrightarrow{H(M_0)} h_0 \xrightarrow{R_0(h_0)} M_1 \ldots M_t \xrightarrow{H(M_t)} h_t \xrightarrow{R_t(h_t)} M_{t+1}, \]
где $R_i(h)$ -- функция редуцирования, преобразования хэша в пароль для следующего хэширования.

Для нахождения ключа блокового шифрования для одного и того же известного открытого текста $M$ таблица строится как
    \[ K_0 \xrightarrow{E_{K_0}(M)} c_0 \xrightarrow{R_0(c_0)} K_1 \ldots K_t \xrightarrow{E_{K_t}(M)} c_t \xrightarrow{R_t(c_t)} K_{t+1}, \]
где $R_i(c)$ -- функция редуцирования, преобразования шифротекста в новый ключ.

Функция редуцирования $R_i$ зависит от номера итерации, чтобы избежать дублирующиеся подцепочки, которые возникают в случае коллизий между значениями в разных цепочках в разных итерациях, если $R$ постоянна. Rainbow-таблица размера $(m \times 2)$ состоит из строк $(M_{0,j}, M_{t+1,j})$ или $(K_{0,j}, K_{t+1,j})$, вычисленных для разных значений стартовых паролей $M_{0,j}$ или $K_{0,j}$ соответственно.

Опишем атаку на примере нахождения прообраза $\overline{M}$ хэша $\overline{h} = H(\overline{M})$. На первой итерации исходный хэш $\overline{h}$ редуцируется в сообщение $\overline{h} \xrightarrow{R_t(\overline{h})} \overline{M}_{t+1} $ и сравнивается со всеми значениями последнего столбца $M_{t+1,j}$ таблицы. Если нет совпадения, переходим ко второй итерации. Хэш $\overline{h}$ дважды редуцируется в сообщение $\overline{h} \xrightarrow{R_{t-1}(\overline{h})} \overline{M}_t \xrightarrow{H(\overline{M}_t)} \overline{h}_t \xrightarrow{R_t(\overline{h}_t)} \overline{M}_{t+1}$ и сравнивается со всеми значениями последнего столбца $M_{t+1,j}$ таблицы. Если не совпало, то переходим к третьей итерации и т.д. Если для $r$-кратного редуцирования сообщение $\overline{M}_{t+1}$ содержится в таблице во втором столбце, то из совпавшей строки берется $M_{0,j}$, и вся цепочка пробегается заново для поиска искомого сообщения $\overline{M}: ~ \overline{h} = H(\overline{M})$.

Найдем вероятность нахождения пароля в таблице. Пусть мощность множества всех паролей $N$. Изначально в столбце $M_{0,j}$ содержится $m_0 = m$ различных паролей. Предполагая случайное отображение с пересечениями паролей $M_{0,j} \rightarrow M_{1,j}$, в $M_{1,j}$ будет $m_1$ различных паролей. Согласно задаче о размещении,
\[
    m_{i+1} = N \left( 1 - \left( 1 - \frac{1}{N} \right)^{m_i} \right) \approx N \left( 1 - e^{-\frac{m_i}{N}} \right).
\]
Вероятность нахождения пароля
\[
    P = 1 - \prod \limits_{i=1}^t \left( 1 - \frac{m_i}{N} \right).
\]

Чем больше таблица из $m$ строк, тем больше шансов найти пароль или ключ, выполнив в наихудшем случае   $O \left( m \frac{t(t+1)}{2} \right)$ операций.

Примеры применения атаки на хэш-функциях $\textrm{MD5}$\index{MD5}, $\textrm{LM} \sim \textrm{DES}_{\textrm{Password}} (\textrm{const})$ приведены в табл. \ref{tab:rainbow-tables}.

\begin{table}[!ht]
    \centering
    \caption{Атаки на радужных таблицах на \emph{одном} ПК\label{tab:rainbow-tables}}
    \resizebox{\textwidth}{!}{ \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\parbox{1.0cm}{Длина, биты}} & \multicolumn{3}{|c|}{Пароль или ключ} &
            \multicolumn{3}{|c|}{Радужная таблица} \\
        \cline{2-7}
        & \parbox{1.2cm}{Длина, симв.} & \parbox{1cm}{Множе- ство} & \parbox{1cm}{Мощн- ость} &
            Объем & \parbox{1.5cm}{Время вычисления таблиц} & \parbox{1.3cm}{Время поиска} \\
        \hline \hline
        \multicolumn{7}{|c|}{Хэш LM} \\
        \hline
        \multirow{3}{*}{$2 \times 56$} & \multirow{3}{*}{14} &
            A--Z & $2^{33}$ & 610 MB &  & 6 с \\
        & & A--Z, 0-9 & $2^{36}$ & 3 GB &  & 15 с \\
        & & все & $2^{43}$ & 64 GB & \parbox{1.5cm}{несколько лет} & 7 мин \\
        \hline \hline
        \multicolumn{7}{|c|}{Хэш MD5} \\
        \hline
        128 & 8 & a-z, 0-9 & $2^{41}$ & 36 GiB & - & 4 мин \\
        \hline
    \end{tabular} }
\end{table}


\section{Аутентификация по паролю}

Из-за малой энтропии пользовательских паролей во всех системах регистрации и аутентификации пользователей применяется специальная политика безопасности. Типичные минимальные требования:
\begin{enumerate}
    \item Длина пароля от 8 символов. Использование разных регистров и небуквенных символов в паролях. Запрет паролей из словаря слов или часто используемых паролей. Запрет паролей в виде дат, номеров машин и других номеров.
    \item Ограниченное время действия пароля. Обязательная смена пароля по истечении срока действия.
    \item Блокирование возможности аутентификации после нескольких неудачных попыток. Ограниченное число актов аутентификаций в единицу времени. Временная задержка перед выдачей результата аутентификации.
\end{enumerate}

Дополнительные рекомендации (требования) пользователям:
\begin{enumerate}
    \item Не использовать одинаковые или похожие пароли для разных систем. Например, электронная почта, вход в ОС, электронная платежная система, форумы, социальные сети. Пароль часто передается в открытом виде по сети. Пароль доступен администратору системы, возможны утечки конфиденциальной информации с серверов. Стараться выбирать случайные стойкие пароли.
    \item Не записывать пароли. Никому не сообщать пароль, даже администратору. Не передавать пароли по почте, телефону, Интернету и т.д.
    \item Не использовать одну и ту же учетную запись для разных пользователей даже в виде исключения.
    \item Всегда блокировать компьютер, когда пользователь отлучается от него даже на короткое время.
\end{enumerate}

\input{os_passwords}

\section[Аутентификация в интернет-сервисах]{Аутентификация в \protect\\ интернет-сервисах}

Взаимодействие браузера и веб-приложения происходит по протоколу HTTP\index{протокол!HTTP}, который не поддерживает состояния. Браузер, клиент, выполняет запросы к веб-серверу, а последний отсылает браузеру запрошенные файлы (HTML-страницы, изображения, стили, скрипты и вообще любые файлы). Для каждого запроса браузер указывает полный адрес (URI, Uniform Resource Identifier). Самые часто используемые запросы: GET (получение файла с указанным URI), POST (отправка данных, введенных пользователем, и получение нового HTML файла веб-страницы), PUT (отправка файлов на указанный URI). При использовании JavaScript (AJAX) отправлять и получать данные можно без перезагрузки страницы, но взаимодействие происходит по стандартным HTTP-запросам.

\emph{Односторонняя} аутентификация пользователя интернет-сервисом состоит из двух фаз:
\begin{enumerate}
    \item первичная аутентификация по паролю при первом GET-запросе к сервису;
    \item вторичная аутентификация на основе токенов аутентификации, сгенерированных веб-приложением, для \emph{каждого} последующего запроса к сервису (GET, POST и т.д.). Каждый запрос к серверу должен быть аутентифицирован, так как протокол HTTP не поддерживает состояний и сеансов. Часто аутентификацию делают через cookie.
\end{enumerate}

\emph{Взаимная} аутентификация достигается \emph{двумя} разными односторонними аутентификациями:
\begin{enumerate}
    \item аутентификация пользователя интернет-сервисом по паролю и последующим сгенерированным токенам;
    \item аутентификация интернет-сервиса пользователем производится с помощью SSL-соединения, которое обеспечивает первичную аутентификацию на основе открытых ключей и вторичные аутентификации кодами аутентификации сообщения и шифрованием на сеансовых ключах, сгенерированных при первичной аутентификации. Первичная аутентификация веб-сервиса производится сертификатом X.509, удостоверяющим принадлежность доменного имени URL веб-сервису, предотвращая фальсификацию веб-сервиса. Сертификат содержит ЭП \emph{общей доверенной} третьей стороны, вычисленной от значения открытых ключей, URL и других полей.
\end{enumerate}


\subsection{Первичная аутентификация по паролю}

Стандартная первичная аутентификация в современных интернет-сервисах происходит обычной передачей логина и пароля в открытом виде по сети. Если SSL-соединение не используется, логин и пароль могут быть перехвачены. Даже при использовании SSL-соединения веб-приложение имеет доступ к паролю в открытом виде.

Более защищенным, но мало используемым способом аутентификации является вычисление хэша от пароля $m$, соли $s$ и псевдослучайных одноразовых меток $n_1, n_2$ с помощью JavaScript в браузере и отсылка по сети только результата вычисления хэша.
\[ \begin{array}{ll}
    \text{Браузер} ~\rightarrow~ \text{Сервис:} & \text{HTTP GET-запрос} \\
    \text{Браузер} ~\leftarrow~ \text{Сервис:}  & s ~\|~ n_1 \\
    \text{Браузер} ~\rightarrow~ \text{Сервис:} & n_2 ~\|~ h( h(s ~\|~ m) ~\|~ n_1 ~\|~ n_2) \\
\end{array} \]

Если веб-приложение хранит хэш от пароля и соли $h(s ~\|~ m)$, то пароль не может быть перехвачен ни по сети, ни веб-приложением.

В массовых интернет-сервисах пароли часто хранятся в открытом виде на сервере, что не является хорошей практикой для обеспечения защиты персональных данных пользователей.


\input{openid}

\input{cookies_auth}

\chapter{Программные уязвимости}

\input{security_models}

\input{os_access_controls}

\section{Виды программных уязвимостей}

В 1949 г. фон Нейман ввел понятие самовоспроизводящихся механических машин.
%Самовоспроизводящейся программой называется программа, создающая и распространяющая свои копии.

\textbf{Вирусом} называется самовоспроизводящаяся часть кода (подпрограмма)\index{вирус}, которая встраивается в носители (другие программы) для своего исполнения и распространения. Вирус не может исполняться и передаваться без своего носителя.

\textbf{Червем} называется самовоспроизводящаяся отдельная (под)программа\index{червь}, которая может исполняться и распространяться самостоятельно, не используя программу-носитель.

Первым сетевым вирусом считается вирус Creeper 1971 г., распространявшийся в сети ARPANET, предшественнике Интернета. Для его уничтожения был создан первый антивирус, Reaper, который находил и уничтожал Creeper.

Первый червь для Интернета, червь Морриса 1988 г., уже использовал \emph{смешанные} атаки для заражения UNIX машин~\cite{EichinRochlis:1988}\cite{Spafford:1989}. Сначала программа получала доступ к удалённому запуску команд, эксплуатируя уязвимости в сервисах \texttt{sendmail}, \texttt{finger} (с использованием атаки переполнением буфера) или \texttt{rsh}. Далее с помощью механизма подбора паролей червь получал доступ к локальным аккаунтам пользователей:
\begin{itemize}
    \item получение доступа к учётным записям с очевидными паролями:
		\begin{itemize}
			\item без пароля вообще;
			\item имя аккаунта в качестве пароля;
			\item имя аккаунта в качестве пароля, повторенное дважды;
			\item использование <<ника>> (англ. <<nickname>>);
			\item фамилия (англ. <<lastname>>);
			\item фамилия, записанная задом наперёд;
		\end{itemize}
		\item перебор паролей на основе встроенного словаря из 432 слов;
		\item перебор паролей на основе системного словаря \texttt{/usr/dict/words}.
\end{itemize}

\textbf{Программной уязвимостью}\index{программная уязвимость} называется свойство программы, позволяющее нарушить ее работу. Программные уязвимости могут приводить к отказу в обслуживании\index{отказ в обслуживании}\index{DoS-атака} (denial of service, DOS), утечке и изменению данных, появлению и распространению вирусов и червей.

Одной из распространенных атак для заражения персональных компьютеров является переполнение буфера в стеке. В интернет-сервисах наиболее распространенной программной уязвимостью в настоящее время является межсайтовый скриптинг (cross-site scripting, XSS).

Наиболее распространенные программные уязвимости можно разделить на классы:
\begin{enumerate}
    \item Переполнение буфера -- копирование в буфер данных большего размера, чем длина выделенного буфера. Буфером может быть контейнер текстовой строки, массив, динамически выделяемая память и т.д. Переполнение становится возможным вследствие либо отсутствия контроля над длиной копируемых данных, либо из-за ошибок в коде. Типичная ошибка -- разница в 1 байт между длиной буфера и данных при сравнении.
    \item Некорректная обработка (парсинг) данных, введенных пользователем, является причиной большинства программных уязвимостей в веб-приложениях. Под обработкой понимаются:
        \begin{enumerate}
            \item проверка на допустимые значения и тип (числовые поля не должны содержать строки и т.д.);
            \item фильтрация и экранирование специальных символов, имеющих значения в скриптовых языках или для декодирования из одной текстовой кодировки в другую. Примеры символов: \texttt{\textbackslash},  \texttt{\%}, \texttt{<}, \texttt{>}, \texttt{"},  \texttt{'};
            \item фильтрация ключевых слов языков разметки и скриптов. Примеры: \texttt{script}, \texttt{JavaScript};
            \item декодирование различными кодировками при парсинге. Распространенный способ обхода системы контроля парсинга данных состоит в однократном или множественном последовательном кодировании текстовых данных в шестнадцатеричные кодировки \texttt{\%NN} ASCII и UTF-8. Например, браузер или веб-приложения производят $n$ -- кратные последовательные декодирования, в то время как система контроля делает $k$-кратное декодирование, $0 \leq k < n$, и, следовательно, пропускает закодированные запрещенные символы и слова.
        \end{enumerate}
    \item Некорректное использование синтаксиса функций. Например, \texttt{printf(s)} может привести к уязвимости записи в указанный адрес памяти. Если злоумышленник вместо обычной текстовой строки введет в качестве \texttt{s = "текст некоторой длины\%n"}, то функция \texttt{printf()}, ожидающая первым аргументом строку формата \texttt{printf(fmt, \dots)}, обнаружив \texttt{\%n}, возьмет значения из ячеек памяти, следующих перед текстовой строкой (устройство стека функции описано далее), и запишет в адрес памяти, равный считанному значению, количество выведенных символов на печать функцией \texttt{printf()}.
\end{enumerate}


\input{stack_overflow}

\input{xss}

\input{sql-injections}

%\chapter{Послесловие}
%Это должно быть что-то в виде заключения, объяснения, почему именно эти темы выбраны, насколько актуален материал с теоретической и практической точки зрения.


\appendix

\chapter{Математическое приложение}
\label{chap:discrete-math}

Вычисления в криптосистемах с открытым ключом, как правило, выполняются в модульной арифметике, в группе или в поле. Далее мы рассмотрим базовые примеры групп и алгоритмов, используемых в криптосистемах с открытым ключом и алгоритме блокового шифрования AES.

\section*{Общие определения}

Выражением $\mod n$ обозначается вычисление остатка от деления произвольного целого числа на целое число $n$. В полиномиальной арифметике эта операция означает вычисление остатка от деления многочленов.
%далее будем обозначать целые числа или операции с целыми числами, взятыми \textbf{по модулю}\index{модуль} целого числа $n$ (остаток от целочисленного деления). Примеры выражений:
    \[ a\mod n, \]
    \[ (a + b) c\mod n. \]
Равенство
    \[ a = b \mod n \]
означает, что выражения $a$ и $b$ равны (говорят также <<сравнимы>>, <<эквивалентны>>) по модулю $n$.

Множество
    \[ \{ 0, 1, 2, 3,  \dots,  n-1 \mod n\} \]
состоит из $n$ элементов, где каждый элемент $i$ представляет все целые числа, сравнимые с $i$ по модулю $n$.

Наибольший общий делитель (НОД) двух чисел $a,b$ обозначается $\gcd(a,b)$ (greatest common divisor).

Два числа $a,b$ называются взаимно простыми, если они не имеют общих делителей, $\gcd(a,b) = 1$.

Выражение $a \mid b$ означает, что $a$ делит $b$.

\input{groups}

\input{aes_math}

\input{modular_ariphmetics}

\input{euclidean_algorithm}

\input{chinese_remainder_theorem}

\section{Псевдопростые числа}

Функция $\pi(n)$ определяется как количество простых чисел из диапазона $[2, n]$.
Существует предел~\cite{Selberg:1949}
    \[ \lim\limits_{n \rightarrow \infty}\frac{ \pi(n)}{ \frac{n}{\ln n}}=1. \]

Для $n \geq 17$ верно неравенство $\pi(n) > \frac{n}{\ln n}$.

Идея создания простых чисел состоит в случайном выборе числа и тестировании его на простоту.

Вероятность $P_k$ того, что случайное $k$-битовое число $n$ будет простым, равна
    \[ \lim\limits_{k \rightarrow \infty} P_k = \frac{1}{\ln n} = \frac{1}{k \ln 2}. \]

\example
    Вероятность того, что случайное 500-битовое число (включая четные числа) будет простым, примерно равна $\frac{1}{347}$, вероятность простоты случайного 2000-битового числа примерно равна $\frac{1}{1836}$.
\exampleend

\input{fermas_test}

\input{miller-rabins_test}

\input{aks}

\input{pseudo-primes_generation}

\input{groups_of_ec_points_over_finite_fields}

\section[Полиномиальные и экспоненциальные алгоритмы]{Полиномиальные и \\ экспоненциальные алгоритмы}

Данный раздел поясняет обоснованность стойкости криптосистем с открытым ключом и имеет лишь косвенное отношение к дискретной математике.

Машина Тьюринга (МТ) (модель, представляющая любой вычислительный алгоритм) состоит из следующих частей:
\begin{itemize}
    \item неограниченной ленты, разделенной на клетки; в каждой клетке содержится символ из конечного алфавита, содержащего пустой символ blank; если символ ранее не был записан на ленту, то он считается blank;
    \item печатающей головки, которая может считать, записать символ $a_i$ и передвинуть ленту на 1 клетку влево-вправо $d_k$;
    \item конечной таблицы действий
    \[ (q_i, a_j) \rightarrow (q_{i1}, a_{j1}, d_k), \]
где $q$ -- состояние машины.
\end{itemize}

Если таблица переходов однозначна, то машина Тьюринга\index{машина Тьюринга} называется детерминированной. \textbf{Детерминированная} машина Тьюринга может \emph{имитировать} любую существующую детерминированную ЭВМ. Если таблица переходов не однозначна, то есть $(q_i, a_j)$ может переходить по нескольким правилам, то машина \textbf{недетерминированная}. \emph{Квантовый компьютер} является примером недетерминированной машины Тьюринга.

Класс задач $\set{P}$ -- задачи, которые могут быть решены за \emph{полиномиальное} время\index{задача!полиномиальная} на \emph{детерминированной} машине Тьюринга. Пример полиномиальной сложности (количество битовых операций)
    \[ O(k^{\textrm{const}}), \]
где $k$ -- длина входных параметров алгоритма. Операция возведения в степень в модульной арифметике $a^b \mod n$ имеет кубическую сложность $O(k^3)$, где $k$ -- двоичная длина чисел $a,b,n$.

Класс задач $\set{NP}$ -- обобщение класса $\set{P} \subseteq \set{NP}$, включает задачи, которые могут быть решены за \emph{полиномиальное} время на \emph{недетерминированной} машине Тьюринга. Пример сложности задач из $\set{NP}$ -- экспоненциальная сложность\index{задача!экспоненциальная}
    \[ O(\textrm{const}^k). \]
Описанный алгоритм Гельфонда (в разделе криптостойкости системы Эль-Гамаля\index{криптосистема!Эль-Гамаля}) решения задачи дискретного логарифма по нахождению $x$ для заданных $g \mod p$ и $a = g^x \mod p$ имеет сложность $O(e^{k/2})$, где $k$ -- двоичная длина чисел.

В криптографии полиномиальные $\set{P}$ алгоритмы считаются \emph{легкими и вычислимыми} на ЭВМ, которые являются детерминированными машинами Тьюринга. Неполиномиальные (экспоненциальные) $\set{NP}$ алгоритмы считаются \emph{трудными и невычислимыми} на ЭВМ, так как из-за экспоненциального роста сложности всегда можно выбрать такой параметр $k$, что время вычисления станет сравнимым с возрастом Вселенной.

Задача факторизации числа, задача дискретного логарифмирования в группе считаются $\set{NP}$-задачами.

Класс $\set{NP}$-полных задач -- подмножество задач из $\set{NP}$, для которых не известен полиномиальный алгоритм для детерминированной машины Тьюринга, и все задачи могут быть сведены друг к другу за полиномиальное время на \emph{детерминированной} машине Тьюринга. Например, задача об укладке рюкзака является $\set{NP}$-полной.

Стойкость криптосистем с \emph{открытым} ключом, как правило, основана на $\set{NP}$ или $\set{NP}$-полных задачах:
\begin{enumerate}
    \item RSA\index{криптосистема!RSA} -- $\set{NP}$-задача факторизации (строго говоря, на трудности извлечения корня степени $e$ по модулю $n$).
    \item Криптосистемы типа Эль-Гамаля\index{криптосистема!Эль-Гамаля} -- $\set{NP}$-задача дискретного логарифмирования.
\end{enumerate}

\emph{Нерешенной} проблемой является доказательство неравенства
    \[ \set{P} \neq \set{NP}. \]
Именно на гипотезе о том, что для для некоторых задач не существует полиномиальных алгоритмов, и основана стойкость криптосистем с открытым ключом.

\input{coincide-index_method}

%\chapter{Задачи и упражнения}
%
%К \textbf{примерам 1, 2, 3} \textbf{упражнение 1}. Указать способ расшифрования для легального получателя шифротекста и указать способ дешифрования для криптоаналитика, не знающего ключа.
%
%\textbf{Упражнение 2}. Пусть $M_1, M_2, M_3,\ldots,M_s$ -- набор перестановок. Показать, что существует единственная перестановка $M=M_1,M_2,M_3,\ldots M_s$.
%
%\textbf{Упражнение 3}. Вскрыть одиночную ячейку Фейстеля. Для этого задать конкретную функцию $F(K,R)$ и по конкретным значениям $L_{1}$ и $R_{1}$ найти $K$.
%
%\textbf{Упражнение 4}. Разделим последовательность на блоки, каждый из которых содержит 2 бита.
%
%\[\begin{array}{cc} {z_{1} } & {z_{2} } \end{array}|\begin{array}{cc} {z_{3} } & {z_{4} } \end{array}| \ldots |\begin{array}{cc} {z_{N} } & {z_{N+1} } \end{array}\]
%Блок может принимать значения $z_{1} z_{2} =\begin{array}{c} {11} \\ {10} \\ {01} \\ {00} \end{array}$
%Преобразуем последовательность символов:
% если $z_{1} z_{2} =11$ или $z_{1} z_{2} =00$, то пара выбрасывается;
%если $[z_{1} z_{2} =10$, то записываем новый символ $u=1$; если
%$z_{1} z_{2} =01$, то записываем новый символ $u=0$.
%Получаем новую двоичную последовательность.
%
%Показать, что вероятностное распределение символов в новой последовательности является равномерным.
%
%\textbf{Упражнение 5}.Предположим, что криптоаналитик знает, что период генерируемой $M$ -последовательности равен $T=2^{L} -1$. Пусть ему известен часть последовательности длины, меньшей периода: $T_{1}<2^{L} -1$.
% При каком значении $T_{1}$  криптоаналитик может найти многочлен обратной связи.
%
%\textbf{Упражнение 6}. Ответить на вопрос: <<Как подделать ЭП, не зная секретного ключа?>>
%
%\textbf{Упражнение 7}. При помощи формул Виета найти дискриминант многочлена, представляющего эллиптическую кривую.

\clearpage
\phantomsection
\addcontentsline{toc}{chapter}{Предметный указатель}
\printindex

\clearpage
\phantomsection
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{ugost2008s}
\bibliography{bibliography}

\end{document}
